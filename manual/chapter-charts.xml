<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="charts">
    <title>Vaadin Charts</title>

    <para>
        This chapter provides the documentation for the Vaadin Charts add-on.
    </para>

    <section xml:id="charts.overview">
        <title>Overview</title>

        <para>
            Vaadin Charts is a feature-rich interactive charting library for Vaadin. It
            provides a <classname>Chart</classname> and a <classname>Timeline</classname>
            component. The <classname>Chart</classname> can visualize one- and
            two-dimensional numeric data in many available chart types. The charts allow
            flexible configuration of all the chart elements as well as the visual
            style. The library includes a number of built-in visual themes, which you can
            extend further. The basic functionalities allow the user to interact with the
            chart elements in various ways, and you can define custom interaction with
            click events. The <classname>Timeline</classname> is a specialized component
            for visualizing time series, and is described in <xref
            linkend="charts.timeline"/>.
        </para>

		<figure xml:id="figure.charts.overview" float="center" floatstyle="before">
			<title>Vaadin Charts</title>
			<mediaobject>
				<imageobject>
					<imagedata scale="70" smallscale="100%" align="center" fileref="img/charts/charts-overview.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            The data displayed in a chart can be one- or two dimensional tabular data, or
            scatter data with free X and Y values. Data displayed in range charts has
            minimum and maximum values instead of singular values.
        </para>

        <para>
            This chapter covers the basic use of Vaadin Charts and the chart
            configuration. For detailed documentation of the configuration parameters and
            classes, please refer to the JavaDoc API documentation of the library.
        </para>

        <para>
            In the following basic example, which we study further in <xref
            linkend="charts.basic-use"/>, we demonstrate how to display one-dimensional
            data in a column graph and customize the X and Y axis labels and titles.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[
Chart chart = new Chart(ChartType.BAR);
chart.setWidth("400px");
chart.setHeight("300px");
        
// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Planets");
conf.setSubTitle("The bigger they are the harder they pull");
conf.getLegend().setEnabled(false); // Disable legend

// The data
ListSeries series = new ListSeries("Diameter");
series.setData(4900,  12100,  12800,
               6800,  143000, 125000,
               51100, 49500);
conf.addSeries(series);

// Set the category labels on the axis correspondingly
XAxis xaxis = new XAxis();
xaxis.setCategories("Mercury", "Venus",   "Earth",
                    "Mars",    "Jupiter", "Saturn",
                    "Uranus",  "Neptune");
xaxis.setTitle("Planet");
conf.addxAxis(xaxis);

// Set the Y axis title
YAxis yaxis = new YAxis();
yaxis.setTitle("Diameter");
yaxis.getLabels().setFormatter(
  "function() {return Math.floor(this.value/1000) + \' Mm\';}");
yaxis.getLabels().setStep(2);
conf.addyAxis(yaxis);
        
layout.addComponent(chart);]]></programlisting>

        <para>
            The resulting chart is shown in <xref
            linkend="figure.charts.overview.basicexample"/>.
        </para>

		<figure xml:id="figure.charts.overview.basicexample">
			<title>Basic Chart Example</title>
			<mediaobject>
				<imageobject>
					<imagedata scale="70" smallscale="80%" align="center" fileref="img/charts/charts-basicexample.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Vaadin Charts is based on Highcharts JS, a charting library written in
            JavaScript.
        </para>

        <simplesect xml:id="charts.overview.licensing">
            <title>Licensing</title>

            <para>
                Vaadin Charts is a commercial product licensed under the CVAL License
                (Commercial Vaadin Add-On License). A license needs to be purchased for
                all use, including web deployments as well as intranet use. Using Vaadin
                Charts does not require purchasing a separate Highcharts JS license.
            </para>

            <para>
                The commercial licenses can be purchased from the <link
                xlink:href="https://vaadin.com/directory">Vaadin Directory</link>, where
                you can also find the license details and download the Vaadin Charts.
            </para>
        </simplesect>
    </section>

    <section xml:id="charts.installing">
        <title>Installing Vaadin Charts</title>

        <para>
            Vaadin Charts is available for both Vaadin 7 and Vaadin 6. It can be installed
            from an installation package, which you can download from the Vaadin
            Directory, or as a Maven or Ivy dependency. For detailed instructions, please
            see <xref linkend="addons"/>.
        </para>

        <para>
            Once you have installed the library in your project, you need to compile the
            widget set.
        </para>
    </section>

    <section xml:id="charts.basic-use">
        <title>Basic Use</title>

        <para>
            The <classname>Chart</classname> is a regular Vaadin component, which you can
            add to a layout. You can give the chart type in the constructor or set it
            later in the chart model. A chart has a height of 400 pixels and takes full
            width by default, which settings you may often need to customize.
        </para>

        <programlisting><![CDATA[Chart chart = new Chart(ChartType.COLUMN);
chart.setWidth("400px");  // 100% by default
chart.setHeight("300px"); // 400px by default]]></programlisting>

        <para>
            The chart types are described in <xref linkend="charts.charttypes"/>.
        </para>

        <simplesect xml:id="charts.basic-use.configuration">
            <title>Configuration</title>

            <para>
                After creating a chart, you need to configure it further. At the least,
                you need to specify the data series to be displayed in the configuration.
            </para>

            <para>
                Most methods available in the <classname>Chart</classname> object handle
                its basic Vaadin component properties. All the chart-specific properties
                are in a separate <classname>Configuration</classname> object, which you
                can access with the <methodname>getConfiguration()</methodname> method.
            </para>

            <programlisting><![CDATA[Configuration conf = chart.getConfiguration();
conf.setTitle("Reindeer Kills by Predators");
conf.setSubTitle("Kills Grouped by Counties");]]></programlisting>

            <para>
                The configuration properties are described in more detail in <xref
                linkend="charts.configuration"/>.
            </para>
        </simplesect>

        <simplesect xml:id="charts.basic-use.plotoptions">
            <title>Plot Options</title>

            <para>
                Many chart settings can be configured in the <emphasis>plot
                options</emphasis> of the chart or data series. Some of the options are
                chart type specific, as described later for each chart type, while many
                are shared.
            </para>

            <para>
                For example, for line charts, you could disable the point markers as
                follows:
            </para>

            <programlisting><![CDATA[// Disable markers from lines
PlotOptionsLine plotOptions = new PlotOptionsLine();
plotOptions.setMarker(new Marker(false));
conf.setPlotOptions(plotOptions);]]></programlisting>

            <para>
                You can set the plot options for the entire chart or for each data series
                separately, allowing also mixed-type charts, as described in <xref
                linkend="charts.basic-use.mixed"/>.
            </para>

            <para>
                The shared plot options are described in <xref
                linkend="charts.configuration.plotoptions"/>.
            </para>
        </simplesect>

        <simplesect xml:id="charts.basic-use.data">
            <title>Chart Data</title>

            <para>
                The data displayed in a chart is stored in the chart configuration as a list
                of <classname>Series</classname> objects. A new data series is added in a
                chart with the <methodname>addSeries()</methodname> method.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[ListSeries series = new ListSeries("Diameter");
series.setData(4900,  12100,  12800,
               6800,  143000, 125000,
               51100, 49500);
conf.addSeries(series);]]></programlisting>

            <para>
                The data can be specified with a number of different series types
                <classname>DataSeries</classname>, <classname>ListSeries</classname>,
                <classname>AreaListSeries</classname>, and <classname>RangeSeries</classname>.
                The data configuration is described in more detail in <xref
                    linkend="charts.data"/>.
            </para>
        </simplesect>

        <simplesect xml:id="charts.basic-use.axis">
            <title>Axis Configuration</title>

            <para>
                One of the most common tasks for charts is customizing its axes. At the
                least, you usually want to set the axis titles. Usually you also want to
                specify labels for data values in the axes.
            </para>

            <para>
                When an axis is categorical rather than numeric, you can define category
                labels for the items. They must be in the same order and the same number
                as you have values in your data series.
            </para>

            <programlisting><![CDATA[XAxis xaxis = new XAxis();
xaxis.setCategories("Mercury", "Venus",   "Earth",
                    "Mars",    "Jupiter", "Saturn",
                    "Uranus",  "Neptune");
xaxis.setTitle("Planet");
conf.addxAxis(xaxis);]]></programlisting>

            <para>
                Formatting of numeric labels can be done with JavaScript expressions, for
                example as follows:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Set the Y axis title
YAxis yaxis = new YAxis();
yaxis.setTitle("Diameter");
yaxis.getLabels().setFormatter(
  "function() {return Math.floor(this.value/1000) + \'Mm\';}");
yaxis.getLabels().setStep(2);
conf.addyAxis(yaxis);]]></programlisting>
        </simplesect>

        <section xml:id="charts.basic-use.two-dimensional">
            <title>Displaying Multiple Series</title>

            <para>
                The simplest data, which we saw in the examples earlier in this chapter,
                is one-dimensional and can be represented with a single data series. Most
                chart types support multiple data series, which are used for representing
                two-dimensional data. For example, in line charts, you can have multiple
                lines and in column charts the columns for different series are grouped by
                category. Different chart types can offer alternative display modes, such
                as stacked columns. The legend displays the symbols for each series.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// The data
// Source: V. Maijala, H. Norberg, J. Kumpula, M. Nieminen
// Calf production and mortality in the Finnish
// reindeer herding area. 2002.
String predators[] = {"Bear", "Wolf", "Wolverine", "Lynx"};
int kills[][] = {        // Location:
        {8,   0,  7, 0}, // Muddusjarvi
        {30,  1, 30, 2}, // Ivalo
        {37,  0, 22, 2}, // Oraniemi
        {13, 23,  4, 1}, // Salla
        {3,  10,  9, 0}, // Alakitka
};    

// Create a data series for each numeric column in the table
for (int predator = 0; predator < 4; predator++) {
    ListSeries series = new ListSeries();
    series.setName(predators[predator]);
    
    // The rows of the table
    for (int location = 0; location < kills.length; location++)
        series.addData(kills[location][predator]);
    conf.addSeries(series);
}]]></programlisting>

            <para>
                The result for both regular and stacked column chart is shown in <xref
                linkend="figure.charts.basic-use.two-dimensional"/>. Stacking is enabled
                with <methodname>setStacking()</methodname> in
                <classname>PlotOptionsColumn</classname>.
            </para>

            <figure xml:id="figure.charts.basic-use.two-dimensional">
                <title>Multiple Series in a Chart</title>
                <mediaobject>
                    <imageobject>
					<imagedata scale="70" smallscale="100%" align="center" fileref="img/charts/charts-twodimensional.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="charts.basic-use.mixed">
            <title>Mixed Type Charts</title>

            <para>
                Each data series has a <classname>PlotOptions</classname> object, just
                like the entire chart has, which allows using different settings for each
                series. This includes the chart type, so you can mix series with different
                chart types in the same chart.
            </para>

            <para>
                The chart type of a series is determined by the type of the plot
                options. For example, to get a line chart, you need to use
                <classname>PlotOptionsLine</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A data series as column graph
DataSeries series1 = new DataSeries();
PlotOptionsColumn options1 = new PlotOptionsColumn();
options1.setFillColor(SolidColor.BLUE);
series1.setPlotOptions(options1);
series1.setData(4900,  12100,  12800,
    6800,  143000, 125000,
    51100, 49500);
conf.addSeries(series1);

// A data series as line graph
ListSeries series2 = new ListSeries("Diameter");
PlotOptionsLine options2 = new PlotOptionsLine();
options2.setLineColor(SolidColor.RED);
series2.setPlotOptions(options2);
series2.setData(4900,  12100,  12800,
    6800,  143000, 125000,
    51100, 49500);
conf.addSeries(series2);]]></programlisting>

        </section>

        <section xml:id="charts.basic-use.themes">
            <title>Chart Themes</title>

            <para>
                The visual style and essentially any other chart configuration can be
                defined in a <emphasis>theme</emphasis>. All charts shown in a UI may have
                only one theme, which can be set with <methodname>setTheme()</methodname>
                in the <classname>ChartOptions</classname>.
            </para>

            <para>
                In Vaadin 7, the <classname>ChartOptions</classname> is a
                <classname>UI</classname> extension that is created and referenced by
                calling the <methodname>get()</methodname> as follows:
            </para>

            <programlisting><![CDATA[// Set Charts theme for the current UI
ChartOptions.get().setTheme(new SkiesTheme());]]></programlisting>

            <para>
                In Vaadin 6, it is an invisible component that you need to create and add
                to the window. There may be only one such component in the window and it
                must be before any <classname>Chart</classname> component.
            </para>

            <programlisting><![CDATA[ChartOptions options = new ChartOptions();
options.setTheme(new SkiesTheme());
content.addComponent(options);]]></programlisting>

            <para>
                The <classname>VaadinTheme</classname> is the default chart theme in
                Vaadin Charts. Other available themes are
                <classname>GrayTheme</classname>, <classname>GridTheme</classname>, and
                <classname>SkiesTheme</classname>. The default theme in Highcharts can be
                set with the <classname>HighChartsDefaultTheme</classname>.
            </para>

            <para>
                A theme is a Vaadin Charts configuration that is used as a template for
                the configuration when rendering the chart.
            </para>
        </section>
    </section>

    <section xml:id="charts.charttypes">
        <title>Chart Types</title>

        <para>
            Vaadin Charts comes with over a dozen different chart types.  You normally
            specify the chart type in the constructor of the <classname>Chart</classname>
            object. The available chart types are defined in the
            <classname>ChartType</classname> enum. You can later read or set the chart
            type with the <literal>chartType</literal> property of the chart model, which
            you can get with <methodname>getConfiguration().getChart()</methodname>.
        </para>

        <para>
            Each chart type has its specific plot options and support its specific
            collection of chart features. They also have specific requirements for the
            data series.
        </para>

        <para>
            The basic chart types and their variants are covered in the following
            subsections.
        </para>

        <section xml:id="charts.charttypes.line">
            <title>Line and Spline Charts</title>

            <para>
                Line charts connect the series of data points with lines. In the basic
                line charts the lines are straight, while in spline charts the lines are
                smooth polynomial interpolations between the data points.
            </para>

            <table xml:id="table.charttypes.line.subtypes">
                <title>Line Chart Subtypes</title>
                <tgroup cols="2" align="left">
                    <colspec colnum="1" colname="col1" colwidth="1*"/>
                    <colspec colnum="2" colname="col2" colwidth="2*"/>
                    <thead>
                        <row valign="top">
                            <entry>ChartType</entry>
                            <entry>Plot Options Class</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row valign="top">
                            <entry><parameter>LINE</parameter></entry>
                            <entry><classname>PlotOptionsLine</classname></entry>
                        </row>
                        <row valign="top">
                            <entry><parameter>SPLINE</parameter></entry>
                            <entry><classname>PlotOptionsSpline</classname></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <section xml:id="charts.charttypes.line.plotoptions">
                <title>Plot Options</title>

                <para>
                    The <parameter>color</parameter> property in the line plot options
                    defines the line color, <parameter>lineWidth</parameter> the line
                    width, and <parameter>dashStyle</parameter> the dash pattern for the
                    lines.
                </para>

                <para>
                    See <xref linkend="charts.charttypes.scatter"/> for plot options
                    regarding markers and other data point properties. The markers can
                    also be configured for each data point.
                </para>
            </section>
        </section>

        <section xml:id="charts.charttypes.area">
            <title>Area Charts</title>

            <para>
                Area charts are like line charts, except that the area between the line
                and the Y axis is painted with a transparent color.  In addition to the
                base type, chart type combinations for spline interpolation and ranges are
                supported.
            </para>

            <table xml:id="table.charttypes.area.subtypes">
                <title>Area Chart Subtypes</title>
                <tgroup cols="2" align="left">
                    <colspec colnum="1" colname="col1" colwidth="1*"/>
                    <colspec colnum="2" colname="col2" colwidth="2*"/>
                    <thead>
                        <row valign="top">
                            <entry>ChartType</entry>
                            <entry>Plot Options Class</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row valign="top">
                            <entry><parameter>AREA</parameter></entry>
                            <entry><classname>PlotOptionsArea</classname></entry>
                        </row>
                        <row valign="top">
                            <entry><parameter>AREASPLINE</parameter></entry>
                            <entry><classname>PlotOptionsAreaSpline</classname></entry>
                        </row>
                        <row valign="top">
                            <entry><parameter>AREARANGE</parameter></entry>
                            <entry><classname>PlotOptionsAreaRange</classname></entry>
                        </row>
                        <row valign="top">
                            <entry><parameter>AREASPLINERANGE</parameter></entry>
                            <entry><classname>PlotOptionsAreaSplineRange</classname></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>
                In area range charts, the area between a lower and upper value is painted
                with a transparent color. The data series must specify the minimum and
                maximum values for the Y coordinates, defined either with
                <classname>RangeSeries</classname>, as described in <xref
                linkend="charts.data.rangeseries"/>, or with
                <classname>DataSeries</classname>, described in <xref
                linkend="charts.data.dataseries"/>.
            </para>

            <section xml:id="charts.charttypes.area.plotoptions">
                <title>Plot Options</title>

                <para>
                    Area charts support <emphasis>stacking</emphasis>, so that multiple
                    series are piled on top of each other. You enable stacking from the
                    plot options with <methodname>setStacking()</methodname>. The
                    <parameter>Stacking.NORMAL</parameter> stacking mode does a normal
                    summative stacking, while the <parameter>Stacking.PERCENT</parameter>
                    handles them as proportions.
                </para>

                <para>
                    The fill color for the area is defined with the
                    <parameter>fillColor</parameter> property and its transparency with
                    <parameter>fillOpacity</parameter> (the opposite of transparency) with
                    a value between 0.0 and 1.0.
                </para>

                <para>
                    The <parameter>color</parameter> property in the line plot options
                    defines the line color, <parameter>lineWidth</parameter> the line
                    width, and <parameter>dashStyle</parameter> the dash pattern for the
                    lines.
                </para>

                <para>
                    See <xref linkend="charts.charttypes.scatter"/> for plot options
                    regarding markers and other data point properties. The markers can
                    also be configured for each data point.
                </para>
            </section>
        </section>

        <section xml:id="charts.charttypes.columnbar">
            <title>Column and Bar Charts</title>

            <para>
                Column and bar charts illustrate values as vertical or horizontal bars,
                respectively. The two chart types are essentially equivalent, just as if
                the orientation of the axes was inverted.
            </para>

            <para>
                Multiple data series, that is, two-dimensional data, are shown with
                thinner bars or columns grouped by their category, as described in <xref
                linkend="charts.basic-use.two-dimensional"/>. Enabling stacking with
                <methodname>setStacking()</methodname> in plot options stacks the columns
                or bars of different series on top of each other.
            </para>

            <para>
                You can also have <parameter>COLUMNRANGE</parameter> charts that
                illustrate a range between a lower and an upper value, as described in
                <xref linkend="charts.charttypes.rangecharts"/>. They require the use of
                <classname>RangeSeries</classname> for defining the lower and upper
                values.
            </para>

            <table xml:id="table.charttypes.columnbar.subtypes">
                <title>Column and Bar Chart Subtypes</title>
                <tgroup cols="2" align="left">
                    <colspec colnum="1" colname="col1" colwidth="1*"/>
                    <colspec colnum="2" colname="col2" colwidth="2*"/>
                    <thead>
                        <row valign="top">
                            <entry>ChartType</entry>
                            <entry>Plot Options Class</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row valign="top">
                            <entry><parameter>COLUMN</parameter></entry>
                            <entry><classname>PlotOptionsColumn</classname></entry>
                        </row>
                        <row valign="top">
                            <entry><parameter>COLUMNRANGE</parameter></entry>
                            <entry><classname>PlotOptionsColumnRange</classname></entry>
                        </row>
                        <row valign="top">
                            <entry><parameter>BAR</parameter></entry>
                            <entry><classname>PlotOptionsBar</classname></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>
                See the API documentation for details regarding the plot options.
            </para>
        </section>

        <section xml:id="charts.charttypes.errorbar">
            <title>Error Bars</title>

            <para>
                An error bars visualize errors, or high and low values, in statistical
                data. They typically represent high and low values in data or a multitude
                of standard deviation, a percentile, or a quantile. The high and low
                values are represented as horizontal lines, or "whiskers", connected by a
                vertical stem.
            </para>

            <para>
                While error bars technically are a chart type
                (<literal>ChartType.ERRORBAR</literal>), you normally use them together
                with some primary chart type, such as a scatter or column chart.
            </para>

            <figure xml:id="figure.charts.charttypes.errorbar">
                <title>Error Bars in a Scatter Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="60" smallscale="80%" align="center" fileref="img/charts/charts-errorbar.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                To display the error bars for data points, you need to have a separate
                data series for the low and high values. The data series needs to use the
                <classname>PlotOptionsErrorBar</classname> plot options type.
            </para>

            <programlisting><?pocket-size 70% ?><![CDATA[// Create a chart of some primary type
Chart chart = new Chart(ChartType.SCATTER);
chart.setWidth("600px");
chart.setHeight("400px");

// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Average Temperatures in Turku");
conf.getLegend().setEnabled(false);

// The primary data series
ListSeries averages = new ListSeries(
    -6, -6.5, -4, 3, 9, 14, 17, 16, 11, 6, 2, -2.5);

// Error bar data series with low and high values
DataSeries errors = new DataSeries();
errors.add(new DataSeriesItem(0,  -9, -3));
errors.add(new DataSeriesItem(1, -10, -3));
errors.add(new DataSeriesItem(2,  -8,  1));
...

// Configure the stem and whiskers in error bars 
PlotOptionsErrorBar barOptions = new PlotOptionsErrorBar();
barOptions.setStemColor(SolidColor.GREY);
barOptions.setStemWidth(2);
barOptions.setStemDashStyle(DashStyle.DASH);
barOptions.setWhiskerColor(SolidColor.BROWN);
barOptions.setWhiskerLength(80); // 80% of category width
barOptions.setWhiskerWidth(2); // Pixels
errors.setPlotOptions(barOptions);

// The errors should be drawn lower
conf.addSeries(errors);
conf.addSeries(averages);]]></programlisting>

            <para>
                Note that you should add the error bar series first, to have it rendered
                lower in the chart.
            </para>

            <section xml:id="charts.charttypes.errorbar.plotoptions">
                <title>Plot Options</title>

                <para>
                    Plot options for error bar charts have type
                    <classname>PlotOptionsErrorBar</classname>. It has the following
                    chart-specific plot option properties:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><parameter>whiskerColor</parameter>, <parameter>whiskerWidth</parameter>, and <parameter>whiskerLength</parameter></term>
                        <listitem>
                            <para>
                                The color, width (vertical thickness), and length of the
                                horizontal "whiskers" that indicate high and low values.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>stemColor</parameter>, <parameter>stemWidth</parameter>, and <parameter>stemDashStyle</parameter></term>
                        <listitem>
                            <para>
                                The color, width (thickness), and line style of the
                                vertical "stems" that connect the whiskers. In box plot
                                charts, which also have stems, they extend from the
                                quadrintile box.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>

        <section xml:id="charts.charttypes.boxplot">
            <title>Box Plot Charts</title>

            <para>
                Box plot charts display the distribution of statistical variables. A data
                point has a median, represented with a horizontal line, upper and lower
                quartiles, represented by a box, and a low and high value, represented
                with T-shaped "whiskers". The exact semantics of the box symbols are up to
                you.
            </para>

            <para>
                Box plot chart is closely related to the error bar chart described in
                <xref linkend="charts.charttypes.errorbar"/>, sharing the box and whisker
                elements.
            </para>

            <figure xml:id="figure.charts.charttypes.boxplot">
                <title>Box Plot Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="60" smallscale="80%" align="center" fileref="img/charts/charts-boxplot.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The chart type for box plot charts is
                <literal>ChartType.BOXPLOT</literal>. You normally have just one data
                series, so it is meaningful to disable the legend.
            </para>

            <programlisting><?pocket-size 70% ?><![CDATA[Chart chart = new Chart(ChartType.BOXPLOT);
chart.setWidth("400px");
chart.setHeight("300px");

// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Orienteering Split Times");
conf.getLegend().setEnabled(false);]]></programlisting>

            <section xml:id="charts.charttypes.boxplot.plotoptions">
                <title>Plot Options</title>

                <para>
                    The plot options for box plots have type
                    <classname>PlotOptionsBoxPlot</classname>, which extends the slightly
                    more generic <classname>PlotOptionsErrorBar</classname>. They have the
                    following plot option properties:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><parameter>medianColor</parameter>, <parameter>medianWidth</parameter></term>
                        <listitem>
                            <para>
                                Color and width (vertical thickness) of the horizontal
                                median indicator line.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 70% ?><![CDATA[// Set median line color and thickness
PlotOptionsBoxPlot plotOptions = new PlotOptionsBoxPlot();
plotOptions.setMedianColor(SolidColor.BLUE);
plotOptions.setMedianWidth(3);
conf.setPlotOptions(plotOptions);]]></programlisting>
            </section>

            <section xml:id="charts.charttypes.boxplot.datamodel">
                <title>Data Model</title>

                <para>
                    As the data points in box plots have five different values instead of
                    the usual one, they require using a special
                    <classname>BoxPlotItem</classname>. You can give the different values
                    with the setters, or all at once in the constructor.
                </para>

                <programlisting><?pocket-size 70% ?><![CDATA[// Orienteering control point times for runners
double data[][] = orienteeringdata(); 

DataSeries series = new DataSeries();
for (double cpointtimes[]: data) {
    StatAnalysis analysis = new StatAnalysis(cpointtimes);
    series.add(new BoxPlotItem(analysis.low(),
                               analysis.firstQuartile(),
                               analysis.median(),
                               analysis.thirdQuartile(),
                               analysis.high()));
}
conf.setSeries(series);]]></programlisting>

                <para>
                    If the "low" and "high" attributes represent an even smaller quantile,
                    or a larger multiple of standard deviation, you can have outliers. You
                    can plot them with a separate data series, with 
                </para>
            </section>
        </section>

        <section xml:id="charts.charttypes.scatter">
            <title>Scatter Charts</title>

            <para>
                Scatter charts display a set of unconnected data points. The name refers
                to freely given X and Y coordinates, so the
                <classname>DataSeries</classname> or
                <classname>ContainerSeries</classname> are usually the most meaningful
                data series types for scatter charts.
            </para>

            <figure xml:id="figure.charts.charttypes.scatter">
                <title>Scatter Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="60" smallscale="65%" align="center" fileref="img/charts/charts-scatter.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The chart type of a scatter chart is
                <parameter>ChartType.SCATTER</parameter>. Its options can be configured in
                a <classname>PlotOptionsScatter</classname> object, although it does not
                have any chart-type specific options.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[Chart chart = new Chart(ChartType.SCATTER);
chart.setWidth("500px");
chart.setHeight("500px");
        
// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Random Sphere");
conf.getLegend().setEnabled(false); // Disable legend

PlotOptionsScatter options = new PlotOptionsScatter();
// ... Give overall plot options here ...
conf.setPlotOptions(options);
        
DataSeries series = new DataSeries();
for (int i=0; i<300; i++) {
    double lng = Math.random() * 2 * Math.PI;
    double lat = Math.random() * Math.PI - Math.PI/2;
    double x   = Math.cos(lat) * Math.sin(lng);
    double y   = Math.sin(lat);
    double z   = Math.cos(lng) * Math.cos(lat);
    
    DataSeriesItem point = new DataSeriesItem(x,y);
    Marker marker = new Marker();
    // Make settings as described later
    point.setMarker(marker);
    series.add(point);
}
conf.addSeries(series);]]></programlisting>

            <para>
                The result was shown in <xref linkend="figure.charts.charttypes.scatter"/>.
            </para>

            <section xml:id="charts.charttypes.scatter.markers">
                <title>Data Point Markers</title>

                <para>
                    Scatter charts and other charts that display data points, such as line
                    and spline charts, visualize the points with
                    <emphasis>markers</emphasis>. The markers can be configured with the
                    <classname>Marker</classname> property objects available from the plot
                    options of the relevant chart types, as well as at the level of each
                    data point, in the <classname>DataSeriesItem</classname>. You need to
                    create the marker and apply it with the
                    <methodname>setMarker()</methodname> method in the plot options or the
                    data series item.
                </para>

                <para>
                    For example, to set the marker for an individual data point:
                </para>

                <programlisting><![CDATA[DataSeriesItem point = new DataSeriesItem(x,y);
Marker marker = new Marker();
// ... Make any settings ...
point.setMarker(marker);
series.add(point);]]></programlisting>
            </section>

            <section xml:id="charts.charttypes.scatter.markerproperties">
                <title>Marker Shape Properties</title>

                <para>
                    A marker has a <parameter>lineColor</parameter> and a
                    <parameter>fillColor</parameter>, which are set using a
                    <classname>Color</classname> object. Both solid colors and gradients
                    are supported.  You can use a <classname>SolidColor</classname> to
                    specify a solid fill color by RGB values or choose from a selection of
                    predefined colors in the class.
                </para>

                <programlisting><![CDATA[// Set line width and color
marker.setLineWidth(1); // Normally zero width
marker.setLineColor(SolidColor.BLACK);

// Set RGB fill color
int level = (int) Math.round((1-z)*127);
marker.setFillColor(
        new SolidColor(255-level, 0, level));
point.setMarker(marker);
series.add(point);]]></programlisting>

                <para>
                    You can also use a color gradient with
                    <classname>GradientColor</classname>. Both linear and radial gradients
                    are supported, with multiple color stops.
                </para>

                <para>
                    Marker size is determined by the <parameter>radius</parameter>
                    parameter, which is given in pixels. The actual visual radius includes
                    also the line width.
                </para>

                <programlisting><![CDATA[marker.setRadius((z+1)*5);]]></programlisting>
            </section>

            <section xml:id="charts.charttypes.scatter.markersymbols">
                <title>Marker Symbols</title>

                <para>
                    Markers are visualized either with a shape or an image symbol. You can
                    choose the shape from a number of built-in shapes defined in the
                    <classname>MarkerSymbolEnum</classname> enum
                    (<parameter>CIRCLE</parameter>, <parameter>SQUARE</parameter>,
                    <parameter>DIAMOND</parameter>, <parameter>TRIANGLE</parameter>, or
                    <parameter>TRIANGLE_DOWN</parameter>). These shapes are drawn with a
                    line and fill, which you can set as described above.
                </para>

                <programlisting><![CDATA[marker.setSymbol(MarkerSymbolEnum.DIAMOND);]]></programlisting>

                <para>
                    You can also use any image accessible by a URL by using a
                    <classname>MarkerSymbolUrl</classname> symbol. If the image is
                    deployed with your application, such as in a theme folder, you can
                    determine its URL as follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[String url = VaadinServlet.getCurrent().getServletContext()
    .getContextPath() + "/VAADIN/themes/mytheme/img/smiley.png";
marker.setSymbol(new MarkerSymbolUrl(url));]]></programlisting>

                <para>
                    The line, radius, and color properties are not applicable to image
                    symbols.
                </para>
            </section>
        </section>

        <section xml:id="charts.charttypes.bubble">
            <title>Bubble Charts</title>

            <para>
                Bubble charts are a special type of scatter charts for representing
                three-dimensional data points with different point sizes. We demonstrated
                the same possibility with scatter charts in <xref
                linkend="charts.charttypes.scatter"/>, but the bubble charts make it
                easier to define the size of a point by its third (Z) dimension, instead
                of the radius property. The bubble size is scaled automatically, just like
                for other dimensions. The default point style is also more bubbly.
            </para>

            <figure xml:id="figure.charts.charttypes.bubble">
                <title>Bubble Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="60" smallscale="85%" align="center" fileref="img/charts/charts-bubble.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The chart type of a bubble chart is
                <parameter>ChartType.BUBBLE</parameter>. Its options can be configured in
                a <classname>PlotOptionsBubble</classname> object, which has a single
                chart-specific property, <parameter>displayNegative</parameter>, which
                controls whether bubbles with negative values are displayed at all. More
                typically, you want to configure the bubble
                <parameter>marker</parameter>. The bubble tooltip is configured in the
                basic configuration. The Z coordinate value is available in the formatter
                JavaScript with <literal>this.point.z</literal> reference.
            </para>

            <para>
                The bubble radius is scaled linearly between a minimum and maximum
                radius. If you would rather scale by the area of the bubble, you can
                approximate that by taking square root of the Z values.
            </para>

            <para condition="web">
                In the following example, we overlay a bubble chart over a world map
                background. We customize the bubbles to be more round with spherical color
                gradient. Note that square root is taken of the Z coordinate to 
            </para>

            <programlisting condition="web"><?pocket-size 65% ?><![CDATA[// Create a bubble chart 
Chart chart = new Chart(ChartType.BUBBLE);
chart.setWidth("640px"); chart.setHeight("350px");
        
// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Champagne Consumption by Country");
conf.getLegend().setEnabled(false); // Disable legend
conf.getTooltip().setFormatter("this.point.name + ': ' + " +
  "Math.round(100*(this.point.z * this.point.z))/100.0 + " +
  "' M bottles'");
        
// World map as background
String url = VaadinServlet.getCurrent().getServletContext()
    .getContextPath() + "/VAADIN/themes/mytheme/img/map.png";
conf.getChart().setPlotBackgroundImage(url);

// Show more bubbly bubbles with spherical color gradient
PlotOptionsBubble plotOptions = new PlotOptionsBubble();
Marker marker = new Marker();
GradientColor color = GradientColor.createRadial(0.4, 0.3, 0.7);
color.addColorStop(0.0, new SolidColor(255, 255, 255, 0.5));
color.addColorStop(1.0, new SolidColor(170, 70, 67, 0.5));
marker.setFillColor(color);
plotOptions.setMarker(marker);
conf.setPlotOptions(plotOptions);
        
// Source: CIVC - Les expeditions de vins de Champagne en 2011
DataSeries series = new DataSeries("Countries");
Object data[][] = {
        {"France",         181.6},
        {"United Kingdom",  34.53},
        {"United States",   19.37},
        ...
};
for (Object[] country: data) {
    String name = (String) country[0];
    double amount = (Double) country[1];
    Coordinate pos = getCountryCoordinates(name); 

    DataSeriesItem3d item = new DataSeriesItem3d();
    item.setX(pos.longitude * Math.cos(pos.latitude/2.0 *
                                       (Math.PI/160)));
    item.setY(pos.latitude * 1.2);
    item.setZ(Math.sqrt(amount));
    item.setName(name);
    series.add(item);
}
conf.addSeries(series);
        
// Set the category labels on the axis correspondingly
XAxis xaxis = new XAxis();
xaxis.setExtremes(-180, 180);
...
conf.addxAxis(xaxis);

// Set the Y axis title
YAxis yaxis = new YAxis();
yaxis.setExtremes(-90, 90);
...
conf.addyAxis(yaxis);]]></programlisting>
        </section>

        <section xml:id="charts.charttypes.pie">
            <title>Pie Charts</title>

            <para>
                A pie chart illustrates data values as sectors of size proportionate to
                the sum of all values. The pie chart is enabled with
                <parameter>ChartType.PIE</parameter> and you can make type-specific
                settings in the <classname>PlotOptionsPie</classname> object as described
                later.
            </para>

            <programlisting><![CDATA[Chart chart = new Chart(ChartType.PIE);
Configuration conf = chart.getConfiguration();
...]]></programlisting>

            <para>
                A ready pie chart is shown in <xref
                linkend="figure.charts.charttypes.pie"/>.
            </para>

            <figure xml:id="figure.charts.charttypes.pie">
                <title>Pie Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="60" smallscale="80%" align="center" fileref="img/charts/charts-pie.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section xml:id="charts.charttypes.pie.plotoptions">
                <title>Plot Options</title>

                <para>
                    The chart-specific options of a pie chart are configured with
                    a <classname>PlotOptionsPie</classname>.
                </para>

            <programlisting><![CDATA[PlotOptionsPie options = new PlotOptionsPie();
options.setInnerSize(0); // Non-0 results in a donut
options.setSize("75%");  // Default
options.setCenter("50%", "50%"); // Default
conf.setPlotOptions(options);]]></programlisting>

                <variablelist>
                    <varlistentry>
                        <term><parameter>innerSize</parameter></term>
                        <listitem>
                            A pie with inner size greater than zero is a "donut". The
                            inner size can be expressed either as number of pixels or as a
                            relative percentage of the chart area with a string (such as
                            "60%") See the section later on donuts.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>size</parameter></term>
                        <listitem>
                            The size of the pie can be expressed either as number of
                            pixels or as a relative percentage of the chart area with a
                            string (such as "80%"). The default size is 75%, to leave
                            space for the labels.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>center</parameter></term>
                        <listitem>
                            The X and Y coordinates of the center of the pie can be
                            expressed either as numbers of pixels or as a relative
                            percentage of the chart sizes with a string. The default is
                            "50%", "50%".
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>

            <section xml:id="charts.charttypes.pie.data">
                <title>Data Model</title>

                <para>
                    The labels for the pie sectors are determined from the labels of the data
                    points. The <classname>DataSeries</classname> or
                    <classname>ContainerSeries</classname>, which allow labeling the data
                    points, should be used for pie charts.
                </para>

            <programlisting><?pocket-size 75% ?><![CDATA[DataSeries series = new DataSeries();
series.add(new DataSeriesItem("Mercury", 4900));
series.add(new DataSeriesItem("Venus", 12100));
...
conf.addSeries(series);]]></programlisting>

                <para>
                    If a data point, as defined as a <classname>DataSeriesItem</classname> in
                    a <classname>DataSeries</classname>, has the <emphasis>sliced</emphasis>
                    property enabled, it is shown as slightly cut away from the pie.
                </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Slice one sector out
DataSeriesItem earth = new DataSeriesItem("Earth", 12800);
earth.setSliced(true);
series.add(earth);]]></programlisting>
            </section>

            <section xml:id="charts.charttypes.pie.donut">
                <title>Donut Charts</title>

                <para>
                    Setting the <parameter>innerSize</parameter> of the plot options of a
                    pie chart to a larger than zero value results in an empty hole at the
                    center of the pie.
                </para>

                <programlisting><![CDATA[PlotOptionsPie options = new PlotOptionsPie();
options.setInnerSize("60%");
conf.setPlotOptions(options);]]></programlisting>

                <para>
                    As you can set the plot options also for each data series, you can put
                    two pie charts on top of each other, with a smaller one fitted in the
                    "hole" of the donut. This way, you can make pie charts with more
                    details on the outer rim, as done in the example below:
                </para>

                <programlisting><![CDATA[// The inner pie
DataSeries innerSeries = new DataSeries();
innerSeries.setName("Browsers");
PlotOptionsPie innerOptions = new PlotOptionsPie();
innerPieOptions.setSize("60%");
innerSeries.setPlotOptions(innerPieOptions);
...

DataSeries outerSeries = new DataSeries();
outerSeries.setName("Versions");
PlotOptionsPie outerOptions = new PlotOptionsPie();
outerOptions.setInnerSize("60%");
outerSeries.setPlotOptions(outerSeriesOptions);
...]]></programlisting>

                <para>
                    The result is illustrated in <xref
                    linkend="figure.charts.charttypes.pie.donut"/>.
                </para>

                <figure xml:id="figure.charts.charttypes.pie.donut">
                    <title>Overlaid Pie and Donut Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata scale="70" smallscale="80%" align="center" fileref="img/charts/charts-donut.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>
        </section>

        <section xml:id="charts.charttypes.gauge">
            <title>Gauges</title>

            <para>
                A gauge is an one-dimensional chart with a circular Y-axis, where a
                rotating pointer points to a value on the axis. A gauge can, in fact, have
                multiple Y-axes to display multiple scales.
            </para>

            <para>
                Let us consider the following gauge:
            </para>

            <programlisting><![CDATA[Chart chart = new Chart(ChartType.GAUGE);
chart.setWidth("400px");
chart.setHeight("400px");]]></programlisting>

            <para>
                After the settings done in the subsequent sections, it will show as in
                <xref linkend="figure.charts.charttypes.gauge"/>.
            </para>

            <figure xml:id="figure.charts.charttypes.gauge">
                <title>A Gauge</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="70" smallscale="60%" align="center" fileref="img/charts/charts-gauge.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section xml:id="charts.charttypes.gauge.conf">
                <title>Gauge Configuration</title>

                <para>
                    The start and end angles of the gauge can be configured in the
                    <classname>Pane</classname> object of the chart configuration. The
                    angles can be given as -360 to 360 degrees, with 0 at the top of the
                    circle.
                </para>

                <programlisting><![CDATA[Configuration conf = chart.getConfiguration();
conf.setTitle("Speedometer");
conf.getPane().setStartAngle(-135);
conf.getPane().setEndAngle(135);]]></programlisting>

            </section>

            <section xml:id="charts.charttypes.gauge.axis">
                <title>Axis Configuration</title>

                <para>
                    A gauge has only an Y-axis. You need to provide both a minimum and
                    maximum value for it.
                </para>

                <programlisting><![CDATA[YAxis yaxis = new YAxis();
yaxis.setTitle("km/h");

// The limits are mandatory
yaxis.setMin(0);
yaxis.setMax(100);

// Other configuration
yaxis.getLabels().setStep(1);
yaxis.setTickInterval(10);
yaxis.setPlotBands(new PlotBand[]{
        new PlotBand(0,  60,  SolidColor.GREEN),
        new PlotBand(60, 80,  SolidColor.YELLOW),
        new PlotBand(80, 100, SolidColor.RED)});

conf.addyAxis(yaxis);]]></programlisting>

                <para>
                    You can do all kinds of other configuration to the axis - please see
                    the API documentation for all the available parameters.
                </para>
            </section>

            <section xml:id="charts.charttypes.gauge.data">
                <title>Setting and Updating Gauge Data</title>

                <para>
                    A gauge only displays a single value, which you can define as a data
                    series of length one, such as as follows:
                </para>

                <programlisting><![CDATA[ListSeries series = new ListSeries("Speed", 80);
conf.addSeries(series);]]></programlisting>

                <para>
                    Gauges are especially meaningful for displaying changing values. You
                    can use the <methodname>updatePoint()</methodname> method in the data
                    series to update the single value.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[final TextField tf = new TextField("Enter a new value");
layout.addComponent(tf);

Button update = new Button("Update", new ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        Integer newValue = new Integer((String)tf.getValue());
        series.updatePoint(0, newValue);
    }
}); 
layout.addComponent(update);]]></programlisting>
            </section>
        </section>

        <section xml:id="charts.charttypes.rangecharts">
            <title>Area and Column Range Charts</title>

            <para>
                Ranged charts display an area or column between a minimum and maximum
                value, instead of a singular data point. They require the use of
                <classname>RangeSeries</classname>, as described in <xref
                linkend="charts.data.rangeseries"/>. An area range is created with
                <parameter>AREARANGE</parameter> chart type, and a column range with
                <parameter>COLUMNRANGE</parameter> chart type.
            </para>
            
            <para>
                Consider the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Chart chart = new Chart(ChartType.AREARANGE);
chart.setWidth("400px");
chart.setHeight("300px");

// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Extreme Temperature Range in Finland");
...

// Create the range series
// Source: http://ilmatieteenlaitos.fi/lampotilaennatyksia
RangeSeries series = new RangeSeries("Temperature Extremes",
    new Double[]{-51.5,10.9},
    new Double[]{-49.0,11.8},
    ...
    new Double[]{-47.0,10.8});//
conf.addSeries(series);]]></programlisting>

            <para>
                The resulting chart, as well as the same chart with a column range, is
                shown in <xref linkend="figure.charts.charttypes.rangecharts"/>.
            </para>

            <figure xml:id="figure.charts.charttypes.rangecharts">
                <title>Area and Column Range Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/charts/charts-arearange.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="charts.charttypes.polar">
            <title>Polar, Wind Rose, and Spiderweb Charts</title>

            <para>
                Most chart types having two axes can be displayed in
                <emphasis>polar</emphasis> coordinates, where the X axis is curved on a
                circle and Y axis from the center of the circle to its rim. Polar chart is
                not a chart type in itself, but can be enabled for most chart types with
                <methodname>setPolar(true)</methodname> in the chart model
                parameters. Therefore all chart type specific features are usable with
                polar charts.
            </para>

            <para>
                Vaadin Charts allows many sorts of typical polar chart types, such as
                <emphasis>wind rose</emphasis>, a polar column graph, or
                <emphasis>spiderweb</emphasis>, a polar chart with categorical data and a
                more polygonal visual style.
            </para>

            <programlisting><![CDATA[// Create a chart of some type
Chart char = new Chart(ChartType.LINE);

// Enable the polar projection
Configuration conf = chart.getConfiguration();
conf.getChart().setPolar(true);]]></programlisting>

            <para>
                You need to define the sector of the polar projection with a
                <classname>Pane</classname> object in the configuration. The sector is
                defined as degrees from the north direction. You also need to define the
                value range for the X axis with <methodname>setMin()</methodname> and
                <methodname>setMax()</methodname>.
            </para>

            <programlisting><![CDATA[// Define the sector of the polar projection
Pane pane = new Pane(0, 360); // Full circle
conf.addPane(pane);

// Define the X axis and set its value range
XAxis axis = new XAxis();
axis.setMin(0);
axis.setMax(360);]]></programlisting>

            <para>
                The polar and spiderweb charts are illustrated in <xref
                linkend="figure.charts.charttypes.polar"/>.
            </para>

            <figure xml:id="figure.charts.charttypes.polar">
                <title>Wind Rose and Spiderweb Charts</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/charts/charts-polarspiderweb.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section xml:id="charts.charttypes.polar.spiderweb">
                <title>Spiderweb Charts</title>

                <para>
                    A <emphasis>spiderweb</emphasis> chart is a commonly used visual style
                    of a polar chart with a polygonal shape rather than a circle. The data
                    and the X axis should be categorical to make the polygonal
                    interpolation meaningful. The sector is assumed to be full circle, so
                    no angles for the pane need to be specified. <phrase condition="web">Note the style settings
                    done in the axis in the example below:</phrase>
                </para>

                <programlisting condition="web"><?pocket-size 75% ?><![CDATA[Chart chart = new Chart(ChartType.LINE);
...

// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.getChart().setPolar(true);
...

// Create the range series
// Source: http://ilmatieteenlaitos.fi/lampotilaennatyksia
ListSeries series = new ListSeries("Temperature Extremes",
    10.9, 11.8, 17.5, 25.5, 31.0, 33.8,
    37.2, 33.8, 28.8, 19.4, 14.1, 10.8);
conf.addSeries(series);

// Set the category labels on the X axis correspondingly
XAxis xaxis = new XAxis();
xaxis.setCategories("Jan", "Feb", "Mar",
    "Apr", "May", "Jun", "Jul", "Aug", "Sep",
    "Oct", "Nov", "Dec");
xaxis.setTickmarkPlacement(TickmarkPlacement.ON);
xaxis.setLineWidth(0);
conf.addxAxis(xaxis);

// Configure the Y axis
YAxis yaxis = new YAxis();
yaxis.setGridLineInterpolation("polygon"); // Webby look
yaxis.setMin(0);
yaxis.setTickInterval(10);
yaxis.getLabels().setStep(1);
conf.addyAxis(yaxis);]]></programlisting>

            </section>
        </section>

        <section xml:id="charts.charttypes.funnel">
            <title>Funnel Charts</title>

            <para>
                Funnel charts are typically used to visualize stages in a sales processes,
                and for other purposes to visualize subsets of diminishing size. A funnel
                chart has layers much like a stacked column, but has a funnel shape. The
                top of the funnel has width of the drawing area of the chart, and
                dinimishes in size down to a neck, and then continues as a column to the
                bottom.
            </para>

            <figure xml:id="figure.charts.charttypes.funnel">
                <title>Funnel Charts</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="80" smallscale="75%" align="center" fileref="img/charts/charts-funnel.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Funnel charts have chart type <parameter>FUNNEL</parameter>.
            </para>

            <para>
                The labels of the funnel blocks are by default placed on the right side of
                the blocks, together with a connector. You can configure their style in
                the plot options<phrase condition="web">, as is done in the following example</phrase>.
            </para>

            <programlisting condition="web"><?pocket-size 75% ?><![CDATA[Chart chart = new Chart(ChartType.FUNNEL);
chart.setWidth("500px");
chart.setHeight("350px");
        
// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Monster Utilization");
conf.getLegend().setEnabled(false);
        
// Give more room for the labels
conf.getChart().setSpacingRight(120);

// Configure the funnel neck shape 
PlotOptionsFunnel options = new PlotOptionsFunnel();
options.setNeckHeightPercentage(20);
options.setNeckWidthPercentage(20);

// Style the data labels
Labels dataLabels = new Labels();
dataLabels.setFormat("<b>{point.name}</b> ({point.y:,.0f})");
dataLabels.setSoftConnector(false);
dataLabels.setColor(SolidColor.BLACK);
options.setDataLabels(dataLabels);
      
conf.setPlotOptions(options);

// Create the range series
DataSeries series = new DataSeries();
series.add(new DataSeriesItem("Monsters Met", 340));
series.add(new DataSeriesItem("Engaged", 235));
series.add(new DataSeriesItem("Killed", 187));
series.add(new DataSeriesItem("Tinned", 70));
series.add(new DataSeriesItem("Eaten", 55));
conf.addSeries(series);]]></programlisting>

            <section xml:id="charts.charttypes.funnel.plotoptions" condition="web">
                <title>Plot Options</title>

                <para>
                    The chart-specific options of a funnel chart are configured with a
                    <classname>PlotOptionsFunnel</classname>. It extends the generic
                    <classname>AbstractLinePlotOptions</classname> and has the following
                    chart type specific properties:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><parameter>neckHeight</parameter> or <parameter>neckHeightPercentage</parameter></term>
                        <listitem>
                            Height of the neck part of the funnel either as pixels or as
                            percentage of the entire funnel height.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>neckWidth</parameter> or <parameter>neckWidthPercentage</parameter></term>
                        <listitem>
                            Width of the neck part of the funnel either as pixels or as
                            percentage of the top of the funnel.
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>

        <section xml:id="charts.charttypes.waterfall">
            <title>Waterfall Charts</title>

            <para>
                Waterfall charts are used for visualizing level changes from an initial
                level to a final level through a number of changes in the level. The
                changes are given as delta values, and you can have a number of
                intermediate totals, which are calculated automatically.
            </para>

            <figure xml:id="figure.charts.charttypes.waterfall">
                <title>Waterfall Charts</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="80" smallscale="80%" align="center" fileref="img/charts/charts-waterfall.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Waterfall charts have chart type <literal>WATERFALL</literal>. <phrase condition="web">For
                example:</phrase>
            </para>

            <programlisting condition="web"><?pocket-size 75% ?><![CDATA[Chart chart = new Chart(ChartType.WATERFALL);
chart.setWidth("500px");
chart.setHeight("350px");

// Modify the default configuration a bit
Configuration conf = chart.getConfiguration();
conf.setTitle("Changes in Reindeer Population in 2011");
conf.getLegend().setEnabled(false);

// Configure X axis
XAxis xaxis = new XAxis();
xaxis.setCategories("Start", "Predators", "Slaughter",
    "Reproduction", "End");
conf.addxAxis(xaxis);

// Configure Y axis
YAxis yaxis = new YAxis();
yaxis.setTitle("Population (thousands)");
conf.addyAxis(yaxis);
...]]></programlisting>

            <para condition="web">
                The example continues in the following subsections.
            </para>

            <section xml:id="charts.charttypes.waterfall.plotoptions" condition="web">
                <title>Plot Options</title>

                <para>
                    Waterfall charts have plot options type
                    <classname>PlotOptionsWaterfall</classname>, which extends the more
                    general options defined in
                    <classname>PlotOptionsColumn</classname>. It has the following chart
                    type specific properties:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><parameter>upColor</parameter></term>
                        <listitem>
                            Color for the positive values. For negative values, the
                            <literal>negativeColor</literal> defined in
                            <classname>PlotOptionsColumn</classname> is used.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In the following, we define the colors, as well as the style and
                    placement of the labels for the columns:
                </para>

                <programlisting condition="web"><?pocket-size 75% ?><![CDATA[// Define the colors
final Color balanceColor = SolidColor.BLACK;
final Color positiveColor = SolidColor.BLUE;
final Color negativeColor = SolidColor.RED;

// Configure the colors 
PlotOptionsWaterfall options = new PlotOptionsWaterfall();
options.setUpColor(positiveColor);
options.setNegativeColor(negativeColor);

// Configure the labels
Labels labels = new Labels(true);
labels.setVerticalAlign(VerticalAlign.TOP);
labels.setY(-20);
labels.setFormatter("Math.floor(this.y/1000) + 'k'");
Style style = new Style();
style.setColor(SolidColor.BLACK);
style.setFontWeight(FontWeight.BOLD);
labels.setStyle(style);
options.setDataLabels(labels);
options.setPointPadding(0);
conf.setPlotOptions(options);]]></programlisting>
            </section>

            <section xml:id="charts.charttypes.waterfall.datamodel" condition="web">
                <title>Data Series</title>

                <para>
                    The data series for waterfall charts consists of changes (deltas)
                    starting from an initial value and one or more cumulative sums. There
                    should be at least a final sum, and optionally intermediate sums. The
                    sums are represented as <classname>WaterFallSum</classname> data
                    items, and no value is needed for them as they are calculated
                    automatically. For intermediate sums, you should set the
                    <parameter>intermediate</parameter> property to
                    <literal>true</literal>.
                </para>

                <programlisting condition="web"><?pocket-size 75% ?><![CDATA[// The data
DataSeries series = new DataSeries();

// The beginning balance
DataSeriesItem start = new DataSeriesItem("Start", 306503);
start.setColor(balanceColor);
series.add(start);

// Deltas
series.add(new DataSeriesItem("Predators", -3330));
series.add(new DataSeriesItem("Slaughter", -103332));
series.add(new DataSeriesItem("Reproduction", +104052));

WaterFallSum end = new WaterFallSum("End");
end.setColor(balanceColor);
end.setIntermediate(false); // Not intermediate (default)
series.add(end);

conf.addSeries(series);]]></programlisting>
            </section>
        </section>
    </section>

    <section xml:id="charts.configuration">
        <title>Chart Configuration</title>

        <para>
            All the chart content configuration of charts is defined in a <emphasis>chart
            model</emphasis> in a <classname>Configuration</classname> object. You can
            access the model with the <methodname>getConfiguration()</methodname> method.
        </para>

        <para>
            The configuration properties in the <classname>Configuration</classname> class
            are summarized in the following:
        </para>

        <itemizedlist>
            <listitem>
                <para><methodname>credits</methodname>: <classname>Credits</classname> (text, position, href, enabled)</para>
            </listitem>
            <listitem>
                <para><methodname>labels</methodname>: <classname>HTMLLabels</classname> (html, style)</para>
            </listitem>
            <listitem>
                <para><methodname>lang</methodname>: <classname>Lang</classname> (decimalPoint, thousandsSep, loading)</para>
            </listitem>
            <listitem>
                <para><methodname>legend</methodname>: <classname>Legend</classname> (see <xref linkend="charts.configuration.legend"/>)</para>
            </listitem>
            <listitem>
                <para><methodname>pane</methodname>: <classname>Pane</classname> </para>
            </listitem>
            <listitem>
                <para><methodname>plotoptions</methodname>: <classname>PlotOptions</classname> (see <xref linkend="charts.configuration.plotoptions"/></para>
            </listitem>
            <listitem>
                <para><methodname>series</methodname>: <interfacename>Series</interfacename></para>
            </listitem>
            <listitem>
                <para><methodname>subTitle</methodname>: <classname>SubTitle</classname></para>
            </listitem>
            <listitem>
                <para><methodname>title</methodname>: <classname>Title</classname></para>
            </listitem>
            <listitem>
                <para><methodname>tooltip</methodname>: <classname>Tooltip</classname></para>
            </listitem>
            <listitem>
                <para><methodname>xAxis</methodname>: <classname>XAxis</classname> (see <xref linkend="charts.configuration.axes"/></para>
            </listitem>
            <listitem>
                <para><methodname>yAxis</methodname>: <classname>YAxis</classname> (see <xref linkend="charts.configuration.axes"/></para>
            </listitem>
        </itemizedlist>

        <para>
            For data configuration, see <xref linkend="charts.data"/>.
        </para>

        <section xml:id="charts.configuration.plotoptions">
            <title>Plot Options</title>

            <para>
                The plot options can be set in the configuration of the entire chart or
                for each data series separately. Some of the plot options are chart type
                specific, defined in type-specific options classes, which all extend
                <classname>AbstractPlotOptions</classname>.
            </para>

            <para>
                You need to create the plot options object and set them either for the
                entire chart or for a data series with
                <methodname>setPlotOptions()</methodname>.
            </para>

            <para>
                For example, the following enables stacking in column charts:
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[PlotOptionsColumn plotOptions = new PlotOptionsColumn();
plotOptions.setStacking(Stacking.NORMAL);
conf.setPlotOptions(plotOptions);]]></programlisting>

            <para>
                See the API documentation of each chart type and its plot options class
                for more information about the chart-specific options, and the
                <classname>AbstractPlotOptions</classname> for the shared plot options.
            </para>

        </section>

        <section xml:id="charts.configuration.axes">
            <title>Axes</title>

            <para>
                Many chart types have two axes, X and Y, which are represented by
                <classname>XAxis</classname> and <classname>YAxis</classname> classes. The
                X axis is usually horizontal, representing the iteration over the data
                series, and Y vertical, representing the values in the data series. Some
                chart types invert the axes and they can be explicitly inverted with
                <methodname>getChart().setInverted()</methodname> in the chart
                configuration. An axis has a caption and tick marks at intervals
                indicating either numeric values or symbolic categories. Some chart types,
                such as gauge, have only Y-axis, which is circular in the gauge, and some
                such as a pie chart have none.
            </para>

            <para>
                Axis objects are created and added to the configuration object with
                <methodname>addxAxis()</methodname> and
                <methodname>addyAxis()</methodname>.
            </para>

            <programlisting><![CDATA[XAxis xaxis = new XAxis();
xaxis.setTitle("Axis title");
conf.addxAxis(xaxis);]]></programlisting>

            <para>
                A chart can have more than one Y-axis, usually when different series
                displayed in a graph have different units or scales. The association of a
                data series with an axis is done in the data series object with
                <methodname>setyAxis()</methodname>.
            </para>

            <para>
                For a complete reference of the many configuration parameters for the
                axes, please refer to the JavaDoc API documentation of Vaadin Charts.
            </para>

            <section xml:id="charts.configuration.axes.categories">
                <title>Categories</title>

                <para>
                    The X axis displays, in most chart types, tick marks and labels at
                    some numeric interval by default. If the items in a data series have a
                    symbolic meaning rather than numeric, you can associate
                    <emphasis>categories</emphasis> with the data items. The category
                    label is displayed between two axis tick marks and aligned with the
                    data point. In certain charts, such as column chart, where the
                    corresponding values in different data series are grouped under the
                    same category. You can set the category labels with
                    <methodname>setCategories()</methodname>, which takes the categories
                    as (an ellipsis) parameter list, or as an iterable. The list should
                    match the items in the data series.
                </para>

                <programlisting><![CDATA[XAxis xaxis = new XAxis();
xaxis.setCategories("Mercury", "Venus", "Earth",
                    "Mars", "Jupiter", "Saturn",
                    "Uranus", "Neptune");]]></programlisting>
            </section>

            <section xml:id="charts.configuration.axes.labels">
                <title>Labels</title>

                <para>
                    The axes display, in most chart types, tick marks and labels at some
                    numeric interval by default. The format and style of labels in an axis
                    is defined in a <classname>Labels</classname> object, which you can
                    get with <methodname>getLabels()</methodname> from the axis.
                </para>

                <para>
                    For a complete reference of the many configuration parameters for the
                    labels, please refer to the JavaDoc API documentation of Vaadin
                    Charts.
                </para>
            </section>

            <section xml:id="charts.configuration.axes.extremes">
                <title>Axis Range</title>

                <para>
                    The axis range is normally set automatically to fit the data, but can
                    also be set explicitly. The <emphasis>extremes</emphasis> property in
                    the axis configuration defines the minimum and maximum values of the
                    axis range. You can set them either individually with
                    <methodname>setMin()</methodname> and
                    <methodname>setMax()</methodname>, or together with
                    <methodname>setExtremes()</methodname>. Changing the extremes
                    programmatically requires redrawing the chart with
                    <methodname>drawChart()</methodname>.
                </para>
            </section>
        </section>

        <section xml:id="charts.configuration.legend">
            <title>Legend</title>

            <para>
                The legend is a box that describes the data series shown in the chart. It
                is enabled by default and is automatically populated with the names of the
                data series as defined in the series objects, and the corresponding color
                symbol of the series.
            </para>
        </section>
    </section>

    <section xml:id="charts.data">
        <title>Chart Data</title>

        <para>
            Chart data is stored in data series model, which contains visual
            representation information about the data points in addition to their values.
            There are a number of different types of series -
            <classname>DataSeries</classname>, <classname>ListSeries</classname>,
            <classname>AreaListSeries</classname>, and <classname>RangeSeries</classname>.
        </para>

        <section xml:id="charts.data.listseries">
            <title>List Series</title>

            <para>
                The <classname>ListSeries</classname> is essentially a helper type that
                makes the handling of simple sequential data easier than with
                <classname>DataSeries</classname>. The data points are assumed to be at a
                constant interval on the X axis, starting from the value specified with
                the <literal>pointStart</literal> property (default is 0) at intervals
                specified with the <literal>pointInterval</literal> property (default is
                1.0). The two properties are defined in the
                <classname>PlotOptions</classname> for the series.
            </para>

            <para>
                The Y axis values are given in a
                <classname>List&lt;Number&gt;</classname>, or with ellipsis or an
                array.
            </para>

            <programlisting><![CDATA[ListSeries series = new ListSeries(
      "Total Reindeer Population",
      181091, 201485, 188105, ...);
series.getPlotOptions().setPointStart(1959);
conf.addSeries(series);]]></programlisting>

            <para>
                You can also add them one by one with the
                <methodname>addData()</methodname> method, which is typical when
                converting from some other representation.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Original representation
int data[][] = reindeerData();

// Create a list series with X values starting from 1959
ListSeries series = new ListSeries("Reindeer Population");
series.getPlotOptions().setPointStart(1959);

// Add the data points
for (int row[]: data)
    series.addData(data[1]);

conf.addSeries(series);]]></programlisting>

            <para>
                If the chart has multiple Y axes, you can specify the axis for the series
                by its index number with <methodname>setyAxis()</methodname>.
            </para>
        </section>

        <section xml:id="charts.data.dataseries">
            <title>Generic Data Series</title>

            <para>
                The <classname>DataSeries</classname> can represent a sequence of data
                points at an interval as well as scatter data. Data points are represented
                with the <classname>DataSeriesItem</classname> class, which has
                <parameter>x</parameter> and <parameter>y</parameter> properties for
                representing the data value. Each item can be given a category name.
            </para>

            <programlisting><![CDATA[DataSeries series = new DataSeries();
series.setName("Total Reindeer Population");
series.add(new DataSeriesItem(1959, 181091));
series.add(new DataSeriesItem(1960, 201485));
series.add(new DataSeriesItem(1961, 188105));
series.add(new DataSeriesItem(1962, 177206));

// Modify the color of one point
series.get(1960, 201485)
    .getMarker().setFillColor(SolidColor.RED);
conf.addSeries(series);]]></programlisting>

            <para>
                Data points are associated with some visual representation parameters:
                marker style, selected state, legend index, and dial style (for
                gauges). Most of them can be configured at the level of individual data
                series items, the series, or in the overall plot options for the
                chart. The configuration options are described in <xref
                linkend="charts.configuration"/>. Some parameters, such as the sliced
                option for pie charts is only meaningful to configure at item level.
            </para>

            <section xml:id="charts.data.dataseries.add">
                <title>Adding and Removing Data Items</title>

                <para>
                    New <classname>DataSeriesItem</classname> items are added to a series
                    with the <methodname>add()</methodname> method. The basic method takes
                    just the data item, but the other method takes also two boolean
                    parameters. If the <parameter>updateChart</parameter> parameter is
                    <literal>false</literal>, the chart is not updated immediately. This
                    is useful if you are adding many points in the same request.
                </para>

                <para>
                    The <parameter>shift</parameter> parameter, when
                    <literal>true</literal>, causes removal of the first data point in the
                    series in an optimized manner, thereby allowing an animated chart that
                    moves to left as new points are added. This is most meaningful with
                    data with even intervals.
                </para>

                <para>
                    You can remove data points with the <methodname>remove()</methodname>
                    method in the series. Removal is generally not animated, unless a data
                    point is added in the same change, as is caused by the
                    <parameter>shift</parameter> parameter for the
                    <methodname>add()</methodname>.
                </para>
            </section>

            <section xml:id="charts.data.dataseries.update">
                <title>Updating Data Items</title>
                
                <para>
                    If you update the properties of a
                    <classname>DataSeriesItem</classname> object, you need to call
                    <methodname>update()</methodname> method for the series with the item
                    as the parameter. Changing the coordinates of a data point in this way
                    causes animation of the change.
                </para>
            </section>

            <section xml:id="charts.data.dataseries.range">
                <title>Range Data</title>

                <para>
                    Range charts expect the Y values to be specified as minimum-maximum
                    value pairs. The <classname>DataSeriesItem</classname> provides
                    <methodname>setLow()</methodname> and
                    <methodname>setHigh()</methodname> methods to set the minimum and
                    maximum values of a data point, as well as a number of constructors
                    that accept the values.
                </para>

            <programlisting><![CDATA[RangeSeries series =
    new RangeSeries("Temperature Extremes");

// Give low-high values in constructor
series2.add(new DataSeriesItem(0, -51.5, 10.9));
series2.add(new DataSeriesItem(1, -49.0, 11.8));

// Set low-high values with setters
DataSeriesItem point2 = new DataSeriesItem();
point2.setX(2);
point2.setLow(-44.3);
point2.setHigh(17.5);
series2.add(point2);]]></programlisting>

                <para>
                    The <classname>RangeSeries</classname> offers a slightly simplified
                    way of adding ranged data points, as described in <xref
                    linkend="charts.data.rangeseries"/>.
                </para>
            </section>
        </section>

        <section xml:id="charts.data.rangeseries">
            <title>Range Series</title>

            <para>
                The <classname>RangeSeries</classname> is a helper class that extends
                <classname>DataSeries</classname> to allow specifying interval data a bit
                easier, with a list of minimum-maximum value ranges in the Y axis. You can
                use the series in range charts, as described in <xref
                linkend="charts.charttypes.rangecharts"/>.
            </para>

            <para>
                For X axis, the coordinates are generated at fixed intervals starting from
                the value specified with the <literal>pointStart</literal> property
                (default is 0) at intervals specified with the
                <literal>pointInterval</literal> property (default is 1.0).
            </para>

            <section xml:id="charts.data.rangeseries.data">
                <title>Setting the Data</title>

                <para>
                    The data in a <classname>RangeSeries</classname> is given as an array
                    of minimum-maximum value pairs for the Y value axis. The pairs are
                    also represented as arrays. You can pass the data using the ellipsis
                    in the constructor or the <methodname>setData()</methodname>:
                </para>

                <programlisting><![CDATA[RangeSeries series =
    new RangeSeries("Temperature Ranges",
    new Double[]{-51.5,10.9},
    new Double[]{-49.0,11.8},
    ...
    new Double[]{-47.0,10.8});
conf.addSeries(series);]]></programlisting>

                <para>
                    Or, as always with variable arguments, you can also pass them in an
                    array, in the following for the <methodname>setData()</methodname>:
                </para>

                <programlisting><![CDATA[series.setData(new Double[][] {
    new Double[]{-51.5,10.9},
    new Double[]{-49.0,11.8},
    ...
    new Double[]{-47.0,10.8}});]]></programlisting>
            </section>
        </section>

        <section xml:id="charts.data.containerseries">
            <title>Container Data Series</title>

            <para>
                The <classname>ContainerDataSeries</classname> is an adapter for binding
                Vaadin <interfacename>Container</interfacename> data sources to
                charts. The container needs to have properties that define the name,
                X-value, and Y-value of a data point. The default property IDs of the
                three properties are "<literal>name</literal>", "<literal>x</literal>",
                and "<literal>y</literal>", respectively. You can set the property IDs
                with <methodname>setNamePropertyId()</methodname>,
                <methodname>setYPropertyId()</methodname>, and
                <methodname>setXPropertyId()</methodname>, respectively. If the container
                has no <literal>x</literal> property, the data is assumed to be
                categorical.
            </para>

            <para>
                In the following example, we have a
                <classname>BeanItemContainer</classname> with
                <classname>Planet</classname> items, which have a <literal>name</literal>
                and <literal>diameter</literal> property. We display the container data
                both in a Vaadin <classname>Table</classname> and a chart.
            </para>

            <programlisting><![CDATA[// The data
BeanItemContainer<Planet> container =
        new BeanItemContainer<Planet>(Planet.class);
container.addBean(new Planet("Mercury", 4900));
container.addBean(new Planet("Venus", 12100));
container.addBean(new Planet("Earth", 12800));
...

// Display it in a table
Table table = new Table("Planets", container);
table.setPageLength(container.size());
table.setVisibleColumns(new String[]{"name","diameter"});
layout.addComponent(table);

// Display it in a chart
Chart chart = new Chart(ChartType.COLUMN);
... Configure it ...

// Wrap the container in a data series
ContainerDataSeries series =
        new ContainerDataSeries(container);

// Set up the name and Y properties
series.setNamePropertyId("name");
series.setYPropertyId("diameter");

conf.addSeries(series);]]></programlisting>

            <para>
                As the X axis holds categories rather than numeric values, we need to set
                up the category labels with an array of string. There are a few ways to do
                that, some more efficient than others, below is one way:
            </para>

            <programlisting><![CDATA[// Set the category labels on the axis correspondingly
XAxis xaxis = new XAxis();
String names[] = new String[container.size()];
List<Planet> planets = container.getItemIds();
for (int i=0; i<planets.size(); i++)
    names[i] = planets.get(i).getName();
xaxis.setCategories(names);
xaxis.setTitle("Planet");
conf.addxAxis(xaxis);]]></programlisting>

            <para>
                The result can be seen in <xref
                linkend="figure.charts.data.containerseries"/>.
            </para>

            <figure xml:id="figure.charts.data.containerseries">
                <title>Table and Chart Bound to a Container</title>
                <mediaobject>
                    <imageobject>
					<imagedata scale="70" smallscale="100%" align="center" fileref="img/charts/charts-containerdataseries.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

        </section>
    </section>

    <section xml:id="charts.advanced">
        <title>Advanced Uses</title>

        <section xml:id="charts.advanced.export">
            <title>Server-Side Rendering and Exporting</title>

            <para>
                In addition to using charts in Vaadin UIs, you may also need to provide
                them as images or in downloadable documents. Vaadin Charts can be rendered
                on the server-side using a headless JavaScript execution environment, such
                as <link xlink:href="http://phantomjs.org/">PhantomJS</link>. 
            </para>

            <para>
                Vaadin Charts supports a HighCharts remote export service, but the SVG
                Generator based on PhantomJS is almost as easy to use and allows much more
                powerful uses.
            </para>

            <section xml:id="charts.advanced.export.exporting">
                <title>Using a Remote Export Service</title>

                <para>
                    HighCharts has a simple built-in export functionality that does the
                    export in a remote export server. HighCharts provides a default export
                    service, but you can also configure your own.
                </para>

                <para>
                    You can enable the built-in export function by setting
                    <methodname>setExporting(true)</methodname> in the chart
                    configuration.
                </para>

                <programlisting><![CDATA[chart.getConfiguration().setExporting(true);]]></programlisting>

                <para>
                    To configure it further, you can provide a
                    <classname>Exporting</classname> object with custom settings.
                </para>

                <programlisting><![CDATA[// Create the export configuration
Exporting exporting = new Exporting(true);
        
// Customize the file name of the download file
exporting.setFilename("mychartfile.pdf");

// Enable export of raster images 
exporting.setEnableImages(true);

// Use the exporting configuration in the chart
chart.getConfiguration().setExporting(exporting);]]></programlisting>

                <para>
                    If you only want to enable download, you can disable the print button
                    as follows:
                </para>

                <programlisting><![CDATA[ExportButton printButton = new ExportButton();
printButton.setEnabled(false);
exporting.setPrintButton(printButton);]]></programlisting>

                <para>
                    The functionality uses a HighCharts export service by default. To use
                    your own, you need to set up one and then configure it in the
                    exporting configuration as follows:
                </para>

                <programlisting><![CDATA[exporting.setUrl("http://my.own.server.com");]]></programlisting>
            </section>

            <section xml:id="charts.advanced.export.svggenerator">
                <title>Using the SVG Generator</title>

                <para>
                    The <classname>SVGGenerator</classname> in Vaadin Charts provides an
                    advanced way to render the Chart into SVG format on the
                    server-side. SVG is well supported by many applications, can be
                    converted to virtually any other graphics format, and can be passed to
                    PDF report generators.
                </para>

                <para>
                    The generator uses PhantomJS to render the chart on the
                    server-side. You need to install it from <link
                    xlink:href="http://phantomjs.org/">phantomjs.org</link>. After
                    installation, PhantomJS should be in your system path. If not, you can
                    set the <parameter>phantom.exec</parameter> system property for the
                    JRE to point to the PhantomJS binary.
                </para>

                <para>
                    To generate the SVG image content as a string (it's XML), simply call
                    the <methodname>generate()</methodname> method in the
                    <classname>SVGGenerator</classname> singleton and pass it the chart
                    configuration.
                </para>

                <programlisting><![CDATA[String svg = SVGGenerator.getInstance()
    .generate(chart.getConfiguration());]]></programlisting>

                <para>
                    You can then use the SVG image as you like, for example, for download
                    from a <classname>StreamResource</classname>, or include it in a HTML,
                    PDF, or other document. You can use SVG tools such as the <link
                    xlink:href="http://xmlgraphics.apache.org/batik/">Batik</link> or
                    <link xlink:href="http://itextpdf.com/">iText</link> libraries to
                    generate documents. For a complete example, you can check out the
                    Charts Export Demo from the Subversion repository at
                    <uri>http://dev.vaadin.com/svn/addons/vaadin-charts/chart-export-demo</uri>.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="charts.timeline">
        <title>Timeline</title>

        <para>
            The <classname>Timeline</classname> is a charting component in the Vaadin
            Charts add-on separate from the <classname>Chart</classname> component. Its
            purpose is to give the user an intuitive understanding of events and trends on
            a horizontal timeline axis.
        </para>

        <para>
            <classname>Timeline</classname> uses its own representation for the data
            series, different from the <classname>Chart</classname> and more optimized for
            updating.  You can represent almost any time-related statistical data that has
            a time-value mapping.  Multiple data sources can be used to allow comparison
            between data.
        </para>

        <figure xml:id="figure.charts.timeline">
            <title>Timeline Component</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/addons/timeline-overview.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="80" smallscale="100%" align="center" fileref="img/addons/timeline-overview.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            A timeline allows representing time-related data visually as graphs instead of
            numerical values. They are used commonly in almost all fields of business,
            science, and technology, such as in project management to map out milestones and
            goals, in geology to map out historical events, and perhaps most prominently in
            the stock market.
        </para>

        <para>
            With Timeline, you can represent almost any time-related statistical data
            that has a time-value mapping. Even several data sources can be used for
            comparison between data. This allows the user to better grasp of changes in the
            data and antipate forthcoming trends and problems.
        </para>

        <section xml:id="charts.timeline.graphtypes">
            <title>Graph types</title>

            <para>
                The Vaadin Timeline supports three graph types:
            </para>

            <variablelist>
                <varlistentry>
                    <term><emphasis>Line graphs</emphasis></term>
                    <listitem>
                        Useful for representing continuous data, such as temperature changes
                        or changes in stock price.
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><emphasis>Bar graphs</emphasis></term>
                    <listitem>
                        Useful for representing discrete or discontinuous data, such as market
                        share or forum posts.
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><emphasis>Scatter graphs</emphasis></term>
                    <listitem>
                    Useful for representing discrete or discontinuous data.
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                If you have several graphs in the timeline, you can also stack them on top
                of each other instead of drawing them on top of each other by setting
                <methodname>setGraphStacking()</methodname> in
                <classname>Timeline</classname> to <literal>true</literal>.
            </para>
        </section>

        <section xml:id="charts.timeline.interaction">
            <title>Interaction Elements</title>

            <para>
                The user can interact with the Vaadin Timeline in several ways.
            </para>

            <para>
                On the bottom of the timeline there is a <emphasis>scrollbar area</emphasis>
                where you can move the time forward or backward in time by dragging the time
                range box or by clicking the left and right arrow buttons. You can change the
                time range by resizing the range box in the scrollbar area. You can also zoom
                with the mouse wheel when the pointer is inside the component.
            </para>

            <figure xml:id="figure.charts.timeline.interaction.scrollbar">
                <title>Scrollbar Area</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/addons/timeline-interaction-scrollarea.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The middle area of the timeline is the <emphasis>main area</emphasis> where
                the selected time range is displayed. Time scale is shown below the main
                area. The time scale used depends on the zoom level and can be a time unit
                from hours to years. Value scale is displayed on the right side of the main
                area. The scale can be either a static value range or a range calculated from
                the displayed data set. The user can move in time by dragging the main area
                with the mouse left and right and zoom in and out by using the mouse wheel.
            </para>

            <figure xml:id="figure.charts.timeline.interaction.mainarea">
                <title>Main Area</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="75%" align="center" fileref="img/addons/timeline-interaction-mainarea.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can select a <emphasis>preset zoom level</emphasis> with the buttons on
                the top the Timeline. This will change the displayed time range to match the
                zoom level. The zoom levels are fully customizable to suit the time range in
                the API.
            </para>

            <figure xml:id="figure.charts.timeline.interaction.presetzooms">
                <title>Preset Zoom Buttons</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="75%" align="center" fileref="img/addons/timeline-interaction-presetzooms.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The <emphasis>current time range</emphasis> is shown at the top-right corner
                of the component. Clicking the dates makes them editable, so that you can
                manually change them. <emphasis>Graph legend</emphasis> is shown below the
                time range. The legend explains what is represented by each bar on the graph
                and displays the current value when the user moves the mouse cursor over the
                graph.
            </para>

            <figure xml:id="figure.charts.timeline.interaction.timerange">
                <title>Current Time Range and Graph Legend</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="75%" align="center" fileref="img/addons/timeline-interaction-timerange.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Finally, the available <emphasis>chart modes</emphasis> are shown below the
                preset zoom levels options. The available graph modes can be set from the API.
            </para>

            <figure xml:id="figure.charts.timeline.interaction.chartmode">
                <title>Chart Mode</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="85%" align="center" fileref="img/addons/timeline-interaction-chartmode.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can use or hide any of the features above can be shown or hidden depending
                on your needs. For example, if you only need to display a graph without any
                controls, you can hide all them from the API.
            </para>
        </section>

        <section xml:id="charts.timeline.events">
            <title>Event Markers</title>
        
            <para>
                In addition to graphs, the timeline can have events. An event can be, for
                example, the time of a published advertisement in a graph that displays
                website hits. Combining the event data with the graphs enables the user to
                observe the relevance of the advertisement to the website hits visually.
            </para>

            <para>
                Vaadin Timeline provides two types of event markers, as illustrated in <xref
                    linkend="figure.charts.timeline.events"/>.
            </para>

            <figure xml:id="figure.charts.timeline.events">
                <title>Timeline Event Markers</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/addons/timeline-event-markers.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="75" smallscale="100%" align="center" fileref="img/addons/timeline-event-markers.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                (On left) Marker with a customizable marker sign, for example, letter 'E'. The
                marker displays a caption which appears when the user hovers the pointer over
                the event.
            </para>

            <para>
                (On right) Marker with button-like appearance with a marker sign and a
                caption.
            </para>
        </section>

        <section xml:id="charts.timeline.efficiency" condition="web">
            <title>Efficiency</title>

            <para>
                Vaadin Timeline reduces the traffic between the server and the client by
                using two methods. First, all the data that is presented in the component
                is dynamically fetched from the server as needed. This means that when the
                user scrolls the timeline view, the component continuously fetches data
                from the server. Also, only data that is visible to the user is
                transferred to the client. For example, if the timeline has data that has
                been measured once a second for an entire year, not all the data will be
                sent to the client. Only the data which can be rendered on the screen
                without overlapping is sent. This ensures that, even for large data sets,
                the loading time is small and only the necessary data is actually
                transferred over the network.
            </para>

            <para>
                Second, Vaadin Timeline caches the data received from the server in the
                browser, so that the data is transferred over the network only once, if
                possible. This speeds up the time-range browsing when data can be fetched from
                the cache instead of reloading it over the network.
            </para>
        </section>

        <section xml:id="charts.timeline.data-source">
            <title>Data Source Requirements</title>

            <para>
                Vaadin Timeline uses Vaadin containers as data sources for both the graphs
                and the events. There are, however, some requirements for the containers
                to make them compatible with the Vaadin Timeline.
            </para>

            <para>
                The containers have to implement
                <interfacename>Container.Indexed</interfacename> for the Vaadin Timeline
                to be able to use them. This is because the Vaadin Timeline dynamically
                fetches the data from the server when needed. This way large data sets can
                be used without having to load all data to the client-side at once and it
                brings a huge performance increase.
            </para>

            <para>
                Another requirement is that the container has one property of type
                <classname>java.util.Date</classname> (or a class that can be cast to it),
                which contains the timestamp when a data point or event occurred. This
                property has to be set by using the
                <methodname>setGraphTimestampPropertyId()</methodname> in
                <classname>Timeline</classname>. The default property ID
                <constant>timeline.PropertyId.TIMESTAMP</constant> is
                used if no timestamp-property ID has been set.
            </para>

            <para>
                A graph container also needs to have a <emphasis>value</emphasis> property
                that defines the value of the data point. This value can be any numerical
                value. The value property can be set with
                <methodname>setGraphValuePropertyId()</methodname> in
                <classname>Timeline</classname>. The default property ID
                <constant>Timeline.PropertyId.VALUE</constant> is used if no value
                property is given.
            </para>

            <para>
                Below is an example of how a graph container could be constructed:
            </para>
	 
            <programlisting><?pocket-size 65% ?><![CDATA[// Construct a container which implements Container.Indexed       
IndexedContainer container = new IndexedContainer();

// Add the Timestamp property to the container
Object timestampProperty = "Our timestamp property";
container.addContainerProperty(timestampProperty,
                               java.util.Date.class, null);

// Add the value property
Object valueProperty = "Our value property";
container.addContainerProperty(valueProperty, Float.class, null);

// Our timeline
Timeline timeline = new Timeline();

// Add the container as a graph container
timeline.addGraphDataSource(container, timestampProperty,
                                       valueProperty);]]></programlisting>

            <para>
                The event and marker containers are similar. They both need the
                <parameter>timestamp</parameter> property which should be of type
                <classname>java.util.Date</classname> and the
                <parameter>caption</parameter> property which should be a string. The
                marker container additionally needs a <parameter>value</parameter>
                property which is displayed in the marker popup.
            </para>

            <para>
                Below is an example on how a marker or event container can be constructed:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create the container
IndexedContainer container = new IndexedContainer();
        
// Add the timestamp property
container.addContainerProperty(Timeline.PropertyId.TIMESTAMP,
                               Date.class, null);
        
// Add the caption property
container.addContainerProperty(Timeline.PropertyId.CAPTION,
                              String.class, "");

// Add the marker specific value property.
// Not needed for a event containers.
container.addContainerProperty(Timeline.PropertyId.VALUE,
                               String.class, "");

// Create the timeline with the container as both the marker
// and event data source
Timeline timeline = new Timeline();
timeline.setMarkerDataSource(container, 
	Timeline.PropertyId.TIMESTAMP,
	Timeline.PropertyId.CAPTION,
	Timeline.PropertyId.VALUE);

timeline.setEventDataSource(container,
	Timeline.PropertyId.TIMESTAMP,
	Timeline.PropertyId.CAPTION);]]></programlisting>

            <para>
                The above example uses the default property IDs. You can change them to
                suit your needs.
            </para>

            <para>
                The <classname>Timeline</classname> listens for changes in the containers
                and updates the graph accordingly. When it updates the graph and items are
                added or removed from the container, the currently selected date range
                will remain selected. The selection bar in the browser area moves to keep
                the current selection selected. If you want the selection to change when
                the contents of the container changes and keep the selection area
                stationary, you can disable the selection lock by setting
                <methodname>setBrowserSelectionLock()</methodname> to
                <parameter>false</parameter>.
            </para>
        </section>

        <section xml:id="charts.timeline.events">
            <title>Events and Listeners</title>

            <para>
                Two types of events are available when using the Vaadin Timeline.
            </para>

            <section xml:id="charts.timeline.events.daterange">
                <title>Date Range Changes</title>

                <para>
                    When the user modifies the selected date range by moving the date
                    range selector, dragging the timeline, or by manually entering new
                    dates, an event will be sent to the server with the information of
                    what the current displayed date range is. To listen to these events
                    you can attach a <classname>DateRangeListener</classname> which will
                    receive the start and end dates of the current selection.
                </para>
            </section>

            <section xml:id="charts.timeline.events.eventclick">
                <title>Event Clicks</title>

                <para>
                    If the timeline has events, you can add an
                    <classname>EventClickListener</classname> to listen for clicks on the
                    events.  The listener will receive a list of item IDs which are
                    related to the click event from the event data source. Multiple events
                    can be combined into a single event icon if space is not sufficient
                    for displaying them all, in which case many item IDs can be returned.
                </para>
            </section>
        </section>

        <section xml:id="charts.timeline.configurability">
            <title>Configurability</title>

            <para>
                The Vaadin Timeline is highly customizable and its outlook can be easily
                changed to suit your needs. The default view of the Timeline contains all
                the controls available but often all of them are not needed and can be
                hidden.
            </para>

            <para>
                The following list contains the components that can be shown or hidden at your preference:
            </para>

            <itemizedlist>
                <listitem>Chart modes</listitem>
                <listitem>Textual date select</listitem>
                <listitem>Browser area (bottom part of the Timeline)</listitem>
                <listitem>Legend</listitem>
                <listitem>Zoom levels</listitem>
                <listitem>Caption</listitem>
            </itemizedlist>

            <para>
                The outlook of the graphs themselves can also be changed for both the
                browser area and the main view. The following settings are available
                through the API:
            </para>

            <itemizedlist>
                <listitem>Graph outline color</listitem>
                <listitem>Graph outline width</listitem>
                <listitem>Graph caps (in line graphs only)</listitem>
                <listitem>Graph fill color</listitem>
                <listitem>Graph visibility</listitem>
                <listitem>Graph shadows</listitem>
            </itemizedlist>

            <para>
                Other changes to the outlook of the component can easily be done by CSS.
            </para>

            <para>
                Zoom levels are also fully customizable. Zoom levels are defined as
                milliseconds and can be added by calling the
                <methodname>addZoomLevel()</methodname> method. A zoom level always has a
                caption, which is the visible part in the zoom panel, and a millisecond
                amount.
            </para>

            <para>
                By default the grid divides the graph into five equally spaced parts with
                a gray color. However, you can fully customize how the grid is drawn by
                using <methodname>setGridColor()</methodname> and
                <methodname>setVerticalGridLines()</methodname>.
            </para>
        </section>

        <section xml:id="charts.timeline.localization">
            <title>Localization</title>

            <para>
                By default the Vaadin Timeline uses English as its primary language for
                the captions and the default locale for the application to display the
                dates in the timeline.
            </para>

            <para>
                You can change the different captions in the Timeline by using their
                corresponding setters:
            </para>

            <itemizedlist>
                <listitem><methodname>setZoomLevelsCaption()</methodname> --  The caption appearing before the zoom levels</listitem>
                <listitem><methodname>setChartModesCaption()</methodname> --  The caption appearing before the chart modes</listitem>
            </itemizedlist>

            <para>
                Furthermore, you can also change the locale in which the Timeline shows
                the dates in the horizontal scale by specifying a valid locale using the
                <methodname>setLocale()</methodname> method of the timeline.
            </para>

            <para>
                You can also configure in what format the dates appear in the horizontal
                scale or in the date select in the top-right corner by using the
                <methodname>getDateFormats()</methodname>-method which will return a
                <classname>DateFormatInfo</classname> object.  By using its setters you
                can set specific formats for each date range in the scale. Please note
                that if you are using long date formats they might get clipped if the
                scale does not fit the whole formatted date.
            </para>
        </section>
	
        <section xml:id="charts.timeline.code-example" condition="web">
            <title>Timeline Tutorial</title>

            <para>
                In the following tutorial, we look step-by-step how to create a timeline.
            </para>

            <section xml:id="charts.timeline.code-example.data-sources">
                <title>Create the Data Sources</title>
                
                <para>
                    To use the Timeline, you need to create some data sources for it.
                    Timeline uses <interfacename>Container.Indexed</interfacename>
                    containers as data sources for both the graphs and the markers and
                    events. So lets start by creating a datasource which represents the
                    graph we want to draw in the timeline.
                </para>

                <para>
                    For the Timeline to understand how the data is constructed in the
                    container we need to use specific property ids which describe what
                    kind of data each property represents. For the Vaadin Timeline to work
                    properly we will need to add two property ids, one for when the value
                    was acquired and one for the value itself. The Vaadin Timeline has
                    these both properties predefined as
                    <parameter>Timeline.PropertyId.TIMESTAMP</parameter> and
                    <parameter>Timeline.PropertyId.VALUE</parameter>. You can use the
                    predefined ones or create your own if you wish.
                </para>

                <para>
                    So, lets create a container which meets the above stated
                    specification. Open the main UI class which was automatically created
                    when we created the project and add the following method.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[/**
 * Creates a graph container with a month of random data
 */
public Container.Indexed createGraphDataSource(){
        
    // Create the container
    Container.Indexed container = new IndexedContainer();
        
    // Add the required property ids (use the default ones here)
    container.addContainerProperty(Timeline.PropertyId.TIMESTAMP, 
        Date.class, null);
    container.addContainerProperty(Timeline.PropertyId.VALUE, 
        Float.class, 0f);
        
    // Add some random data to the container
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.MONTH, -1);
    Date today = new Date();
    Random generator = new Random();
        
    while(cal.getTime().before(today)){
        // Create  a point in time
        Item item = container.addItem(cal.getTime());
            
        // Set the timestamp property
        item.getItemProperty(Timeline.PropertyId.TIMESTAMP)
            .setValue(cal.getTime());
            
        // Set the value property
        item.getItemProperty(Timeline.PropertyId.VALUE)
            .setValue(generator.nextFloat());
        
        cal.add(Calendar.DAY_OF_MONTH, 1);            
    }
        
    return container;        
}]]></programlisting>

                <para>
                    This method will create an indexed container with some random
                    points. As you can see we are using an
                    <classname>IndexedContainer</classname> and define two properties to
                    it which was discussed earlier. Then we just generate some random data
                    in the container. Here we are using the default property ids for the
                    timestamp and value but you could use your own if you wished. We'll
                    see later how you would tell the Timeline which property ids to use if
                    you used your own.
                </para>

                <para>
                    Next, lets add some markers to our graph. Markers are arrow like
                    shapes in the bottom of the timeline with which you can mark some
                    occurrence that happened at that time. To create markers you again
                    have to create a data source for them. I'll first show you how the
                    code to create them and then explain what it all means. Add the
                    following method to the UI class:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[/**
 * Creates a marker container with a marker for each seven days
 */
public Container.Indexed createMarkerDataSource(){
        
    // Create the container
    Container.Indexed container = new IndexedContainer();
        
    // Add the required property IDs (use the default ones here)
    container.addContainerProperty(Timeline.PropertyId.TIMESTAMP,
            Date.class, null);
    container.addContainerProperty(Timeline.PropertyId.CAPTION, 
            String.class, "Our marker symbol");
    container.addContainerProperty(Timeline.PropertyId.VALUE, 
            String.class, "Our description");
        
    // Add a marker for every seven days
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.MONTH, -1);
    Date today = new Date();
    SimpleDateFormat formatter =
            new SimpleDateFormat("EEE, MMM d, ''yy");
    while(cal.getTime().before(today)){
        // Create a point in time
        Item item = container.addItem(cal.getTime());
        
        // Set the timestamp property
        item.getItemProperty(Timeline.PropertyId.TIMESTAMP)
                .setValue(cal.getTime());
        
        // Set the caption property
        item.getItemProperty(Timeline.PropertyId.CAPTION)
                .setValue("M");
            
        // Set the value property
        item.getItemProperty(Timeline.PropertyId.VALUE).
           setValue("Today is "+formatter.format(cal.getTime()));

        cal.add(Calendar.DAY_OF_MONTH, 7);
    }
    
    return container;        
}]]></programlisting>

                <para>
                    Here we start the same as in the example with the graph container by
                    creating an indexed container. Remember, all containers must be indexed
                    containers when using the graph component.
                </para>

                <para>
                    We then add the timestamp property, caption property and value property. 
                </para>

                <para>
                    The timestamp property is the same as in the graph container but the
                    caption and value property differ. The caption property describes what
                    kind of marker it is. The caption is displayed on top of the arrow
                    shape in the Timeline so it should be a short symbol, preferably only
                    one character long. The class of the caption property must be String.
                </para>

                <para>
                    The value property should also be a string and is displayed when the
                    user hovers the mouse over the marker. This string can be arbitrarily
                    long and normally should represent some kind of description of the
                    marker.
                </para>

                <para>
                    The third kind of data sources are the event data sources. The events
                    are displayed on top of the timeline and supports grouping and are
                    clickable. They are represented as button like icons in the Timeline.
                </para>

                <para>
                    The event data sources are almost identical the to marker data sources
                    except the value property is missing. Lets create an event data source
                    and add events for each Sunday in out graph:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[/**
 * Creates a event container with a marker for each sunday
 */
public Container.Indexed createEventDataSource(){

    // Create the container
    Container.Indexed container = new IndexedContainer();
	
    // Add the required property IDs (use default ones here)
    container.addContainerProperty(
            Timeline.PropertyId.TIMESTAMP, Date.class, null);
    container.addContainerProperty(
            Timeline.PropertyId.CAPTION,
            String.class, "Our marker symbol");
			
    // Add a marker for every seven days
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.MONTH, -1);
    Date today = new Date();		
    while(cal.getTime().before(today)){
        if (cal.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY){
            // Create a point in time
            Item item = container.addItem(cal.getTime());

            // Set the timestamp property
            item.getItemProperty(Timeline.PropertyId.TIMESTAMP)
                .setValue(cal.getTime());
				
            // Set the caption property
            item.getItemProperty(Timeline.PropertyId.CAPTION)
                .setValue("Sunday");			
        }			
        cal.add(Calendar.DAY_OF_MONTH, 1);
    }
		
    return container;		
}]]></programlisting>

                <para>
                    As you can see the event container does not differ a whole lot from
                    the marker containers. In use however they differ since they are
                    groupable they can be closely put together and still be usable and you
                    can add click listeners to them so you can catch user events. More on
                    the click listeners later.
                </para>

                <para>
                    So now we have our three data sources ready to be displayed in our
                    application. In the next chapter we will use them with our Timeline and
                    see how they integrate with it.
                </para>
            </section>

            <section xml:id="charts.timeline.code-example.timeline">
                <title>Create the Timeline</title>

                <para>
                    Okay, now that we have out data sources lets look at the init-method
                    in our Vaadin Application. Lets start by creating our timeline, so add
                    the following line to the end of the init-method in
                    <classname>MytimelinedemoApplication</classname>:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[Timeline timeline = new Timeline("Our timeline");
timeline.setWidth("100%");]]></programlisting>

                <para>
                    This will create the timeline we want with a 100 percent width. Now
                    lets add our data sources to the timeline:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[timeline.addGraphDataSource(createGraphDataSource(), 
                        Timeline.PropertyId.TIMESTAMP,
                        Timeline.PropertyId.VALUE);

timeline.setMarkerDataSource(createMarkerDataSource(), 
                        Timeline.PropertyId.TIMESTAMP, 
                        Timeline.PropertyId.CAPTION,
                        Timeline.PropertyId.VALUE);

timeline.setEventDataSource(createEventDataSource(), 
                        Timeline.PropertyId.TIMESTAMP,
                        Timeline.PropertyId.CAPTION);]]></programlisting>


                <para>
                    And finally add the timeline to the UI. Here is the complete
                    init-method:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[@Override
protected void init(VaadinRequest request) {
    VerticalLayout content = new VerticalLayout();
    setContent(content);
        
    // Create the timeline
    Timeline timeline = new Timeline("Our timeline");

    // Create the data sources
    Container.Indexed graphDS  = createGraphDataSource();
    Container.Indexed markerDS = createMarkerDataSource();
    Container.Indexed eventDS  = createEventDataSource();
        
    // Add our data sources
    timeline.addGraphDataSource(graphDS, 
                                Timeline.PropertyId.TIMESTAMP,
                                Timeline.PropertyId.VALUE);
    timeline.setMarkerDataSource(markerDS, 
                                 Timeline.PropertyId.TIMESTAMP,
                                 Timeline.PropertyId.CAPTION,     
                                 Timeline.PropertyId.VALUE);
    timeline.setEventDataSource(eventDS, 
                                Timeline.PropertyId.TIMESTAMP,
                                Timeline.PropertyId.CAPTION);
        
    content.addComponent(timeline);        
}]]></programlisting>

                <para>
                    Now you should be able to start the application and browse the
                    timeline. The result is shown in <xref
                        linkend="figure.charts.timeline.code-example.timeline"/>.
                </para>

                <figure xml:id="figure.charts.timeline.code-example.timeline">
                    <title>Timeline Example Application</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/timeline/timeline-example-timeline.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="60" smallscale="100%" align="center" fileref="img/timeline/timeline-example-timeline.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>
        
            <section xml:id="charts.timeline.code-example.final">
                <title>Final Touches</title>

                <para>
                    Now that we have our timeline we would probably like to customize it a
                    bit. There are many things you can do but lets start by giving our graph
                    some style properties and a caption in the legend. This can be done as
                    follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Set the caption of the graph
timeline.setGraphLegend(graphDataSource, "Our cool graph");
        
// Set the color of the graph
timeline.setGraphOutlineColor(graphDataSource, Color.RED);

// Set the fill color of the graph
timeline.setGraphFillColor(graphDataSource, new Color(255,0,0,128));
        
// Set the width of the graph
timeline.setGraphOutlineThickness(2.0);]]></programlisting>

                <para>
                    Lets do the same to the browser areas graph:
                </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Set the color of the browser graph
timeline.setBrowserOutlineColor(graphDataSource, Color.BLACK);

// Set the fill color of the graph
timeline.setBrowserFillColor(graphDataSource,
                             new Color(0,0,0,128));]]></programlisting>

                <para>
                    And the result looks like this:
                </para>

                <figure xml:id="figure.code-example.final.styling">
                    <title>Styling Timeline</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/timeline/timeline-example-result.png"/>
                        </imageobject>
                    <imageobject role="fo">
                            <imagedata scale="60" smallscale="100%" align="center" fileref="img/timeline/timeline-example-result.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    Okay, now that looks different. But there is still something
                    missing. If you look in the upper left corner you will not see any
                    zoom levels. No zoom levels are predefined so we will have to make our
                    own. Since we are dealing with a month of data lets make a zoom level
                    for a day, a week and a month.  Zoom levels are given in milliseconds
                    so we will have to calculate how many milliseconds each of the zoom
                    levels are. So lets add them by adding the following lines:
                </para>

                <programlisting><![CDATA[// Add some zoom levels
timeline.addZoomLevel("Day", 86400000L);
timeline.addZoomLevel("Week", 7 * 86400000L);
timeline.addZoomLevel("Month", 2629743830L);]]></programlisting>

                <para>
                    Remember the events we added? You can now see them in the graph but
                    their functionality is still a bit incomplete. We can add an event
                    listener to the graph which will send an event each time the user
                    clicks on one of the event buttons. To demonstrate this feature lets
                    add an event listener which notifies the user what date the
                    Sunday-button represents. Here is the code for that:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Listen to click events from events
timeline.addListener(new Timeline.EventClickListener() {
    @Override
    public void eventClick(EventButtonClickEvent event) {
        Item item = eventDataSource.getItem(event.getItemIds()
                                   .iterator().next());
        Date sunday = (Date) item.getItemProperty(
                      Timeline.PropertyId.TIMESTAMP).getValue();
        SimpleDateFormat formatter =
            new SimpleDateFormat("EEE, MMM d, ''yy");
        
        Notification.show(formatter.format(sunday));
    }        
});]]></programlisting>

                <para>
                    Now try clicking on the events and see what happens!
                </para>

                <para>
                    And here is the final demo application, yours will probably look a bit
                    different since we are using random data.
                </para>
    
                <figure xml:id="figure.code-example.final.final">
                    <title>Final Example</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/timeline/timeline-example-final.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="60" smallscale="100%" align="center" fileref="img/timeline/timeline-example-final.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    Now we hope you have a basic understanding of how the Timeline works
                    and how it can be customized. There are still a few features we left
                    out of this tutorial like hiding unnecessary components from the
                    timeline and adding multiple graphs to the timeline, but these are
                    pretty self explanatory features and you probably can look them up in
                    the JavaDoc.
                </para>
            </section>
        </section>
    </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
