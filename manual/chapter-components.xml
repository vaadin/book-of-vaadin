<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="components">
	<title>User Interface Components</title>
	
	<para>
		This chapter provides an overview and a detailed description of all
		non-layout components in Vaadin.
	</para>
	
    <para>
        <emphasis>Because of pressing release schedules to get this edition to your hands,
        some topics still require revision for Vaadin 7, especially the data binding of
        the <classname>Table</classname> component. Please consult the web version once it
        is updated, or the next print edition.</emphasis>
    </para>

	<section xml:id="components.overview">
		<title>Overview</title>

		<para>
			Vaadin provides a comprehensive set of user interface components and allows
			you to define custom components. <xref linkend="figure.uicomponents"/>
			illustrates the inheritance hierarchy of the UI component classes and
			interfaces. Interfaces are displayed in gray, abstract classes in orange, and
			regular classes in blue. An annotated version of the diagram is featured in
			the <emphasis>Vaadin Cheat Sheet</emphasis>.
		</para>

		<figure xml:id="figure.uicomponents" float="center" floatstyle="before">
			<title>User Interface Component Class Hierarchy</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/component-diagram-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/component-diagram-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            <indexterm><primary><classname>Component</classname></primary></indexterm>

			At the top of the interface hierarchy, we have the
			<classname>Component</classname> interface.

            <indexterm><primary><classname>AbstractComponent</classname></primary></indexterm>

            At the top of the class hierarchy, we have the
            <classname>AbstractComponent</classname> class.

            <indexterm><primary><classname>AbstractField</classname></primary></indexterm>
            <indexterm><primary><classname>AbstractComponentContainer</classname></primary></indexterm>

            It is inherited by two other abstract classes:
            <classname>AbstractField</classname>, inherited further by field components,
            and <classname>AbstractComponentContainer</classname>, inherited by various
            container and layout components. Components that are not bound to a content
            data model, such as labels and links, inherit
            <classname>AbstractComponent</classname> directly.
		</para>

		<para>
            <indexterm><primary>layout</primary></indexterm>
            <indexterm><primary><classname>Layout</classname></primary></indexterm>

			The layout of the various components in a window is controlled,
			logically, by layout components, just like in conventional Java UI
			toolkits for desktop applications. In addition, with the <classname>CustomLayout</classname>
			component, you can write a custom layout as an HTML template that
			includes the locations of any contained components. Looking at the
			inheritance diagram, we can see that layout components inherit the
			<classname>AbstractComponentContainer</classname> and the
			<classname>Layout</classname> interface. Layout components are
			described in detail in <xref linkend="layout"/>.
		</para>

		<para>
            <indexterm><primary><classname>Window</classname></primary></indexterm>

			Looking at it from the perspective of an object hierarchy, we would
			have a <classname>Window</classname> object, which contains a hierachy of
			layout components, which again contain other layout components, field
			components, and other visible components.
		</para>

		<para>
            <indexterm><primary>Sampler</primary></indexterm>
            <indexterm><primary>JavaDoc</primary></indexterm>

			You can browse the built-in UI components of Vaadin library in the
			<application>Sampler</application> application of the <application>Vaadin
			Demo</application>. The Sampler shows a description, JavaDoc documentation,
			and a code samples for each of the components.
		</para>

		<para>
            In addition to the built-in components, many components are available as
            add-ons, either from the Vaadin Directory or from independent sources. Both
            commercial and free components exist. The installation of add-ons is described
            in <xref linkend="addons"/>.
        </para>

        <note>
            <title>Vaadin Cheat Sheet and Refcard</title>

            <para>
                <xref linkend="figure.uicomponents"/> is included in the Vaadin Cheat
                Sheet that illustrates the basic relationship hierarchy of the user
                interface components and data binding classes and interfaces. You can
                download it at <link
                xlink:href="http://vaadin.com/book">http://vaadin.com/book</link>.
            </para>

            <para>
                The diagram is also included in the six-page DZone Refcard, which you can
                find at <link
                xlink:href="https://vaadin.com/refcard">https://vaadin.com/refcard</link>.
            </para>
        </note>
	</section>

	<section xml:id="components.interfaces">
		<title>Interfaces and Abstractions</title>

        <para>
            <indexterm><primary>interfaces</primary></indexterm>

			Vaadin user interface components are built on a skeleton of interfaces and
			abstract classes that define and implement the features common to all
			components and the basic logic how the component states are serialized between
			the server and the client.
        </para>
        
        <para>
			This section gives details on the basic component interfaces and
			abstractions. The layout and other component container abstractions are
			described in <xref linkend="layout"/>. The interfaces that define the Vaadin
			data model are described in <xref linkend="datamodel"/>.
        </para>

		<figure xml:id="figure.components.interfaces" float="center" floatstyle="before">
			<title>Component Interfaces and Abstractions</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/component-abstractions-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/component-abstractions-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            <indexterm><primary><classname>Paintable</classname></primary></indexterm>
            <indexterm><primary><classname>VariableOwner</classname></primary></indexterm>

			All components also implement the <classname>Paintable</classname> interface,
			which is used for serializing ("painting") the components to the client, and
			the reverse <classname>VariableOwner</classname> interface, which is needed
			for deserializing component state or user interaction from the client.
        </para>

        <para>
            <indexterm><primary><classname>Serializable</classname></primary></indexterm>

			In addition to the interfaces defined within the Vaadin framework, all
			components implement the <classname>java.io.Serializable</classname> interface
			to allow serialization. Serialization is needed in many clustering and cloud
			computing solutions.
		</para>

        <section xml:id="components.interfaces.component">
            <title><classname>Component</classname> Interface</title>

            <indexterm xml:id="term.components.interfaces.component" class="startofterm">
                <primary><classname>Component</classname> interface</primary>
            </indexterm>

            <para>
                The <classname>Component</classname> interface is paired with the
                <classname>AbstractComponent</classname> class, which implements all the
                methods defined in the interface.
            </para>

			<section>
				<title>Component Tree Management</title>

				<para>
					Components are laid out in the user interface hierarchically. The
					layout is managed by layout components, or more generally components
					that implement the <classname>ComponentContainer</classname>
					interface. Such a container is the parent of the contained components.
				</para>

				<para>
					The <methodname>getParent()</methodname> method allows retrieving the
					parent component of a component. While there is a
					<methodname>setParent()</methodname>, you rarely need it as you
					usually add components with the
					<methodname>addComponent()</methodname> method of the
					<classname>ComponentContainer</classname> interface, which
					automatically sets the parent.
				</para>

				<para>
					A component does not know its parent when the component is still being
					created, so you can not refer to the parent in the constructor with
					<methodname>getParent()</methodname>.
                </para>

				<para>
					Attaching a component to an UI triggers a call to its
					<methodname>attach()</methodname> method. Correspondingly, removing a
					component from a container triggers calling the
					<methodname>detach()</methodname> method. If the parent of an added
					component is already connected to the UI, the
					<methodname>attach()</methodname> is called immediately from
					<methodname>setParent()</methodname>.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[public class AttachExample extends CustomComponent {
    public AttachExample() {
    }
    
    @Override
    public void attach() {
        super.attach(); // Must call.
        
        // Now we know who ultimately owns us.
        ClassResource r = new ClassResource("smiley.jpg");
        Image image = new Image("Image:", r); 
        setCompositionRoot(image);
    }
}]]></programlisting>

				<para>
					The attachment logic is implemented in
					<classname>AbstractComponent</classname>, as described in <xref
					linkend="components.interfaces.abstractcomponent"/>.
				</para>

			</section>

            <indexterm startref="term.components.interfaces.component" class="endofterm">
                <primary><classname>Component</classname> interface</primary>
            </indexterm>
        </section>

        <section xml:id="components.interfaces.abstractcomponent">
            <title><classname>AbstractComponent</classname></title>

            <indexterm xml:id="term.components.interfaces.abstractcomponent" class="startofrange">
                <primary><classname>AbstractComponent</classname></primary>
            </indexterm>

            <para>
                <classname>AbstractComponent</classname> is the base class for all user
                interface components. It is the (only) implementation of the
                <classname>Component</classname> interface, implementing all the methods
                defined in the interface.
            </para>
			
			<para>
				<classname>AbstractComponent</classname> has a single abstract method,
				<methodname>getTag()</methodname>, which returns the serialization
				identifier of a particular component class. It needs to be implemented
				when (and only when) creating entirely new
				components. <classname>AbstractComponent</classname> manages much of the
				serialization of component states between the client and the
				server. Creation of new components and serialization is described in <xref
				linkend="gwt"/>.
			</para>

            <indexterm startref="term.components.interfaces.abstractcomponent" class="endofrange"/>
        </section>
    </section>

	<section xml:id="components.features">
		<title>Common Component Features</title>

        <para>
            The component base classes and interfaces provide a large number of
            features. Let us look at some of the most commonly needed features. Features
            not documented here can be found from the Java API Reference.
        </para>

        <para>
            The interface defines a number of properties, which you can retrieve
            or manipulate with the corresponding setters and getters.
        </para>

        <section xml:id="components.features.caption">
            <title>Caption</title>

            <indexterm zone="components.features.caption">
                <primary>caption property</primary>
            </indexterm>

            <indexterm zone="components.features.caption">
                <primary>Component interface</primary>
                <secondary>caption</secondary>
            </indexterm>

            <para>
                A caption is an explanatory textual label accompanying a user interface
                component, usually shown above, left of, or inside the component. The
                contents of a caption are automatically quoted, so no raw HTML can be
                rendered in a caption.
            </para>

            <para>
                The caption text can usually be given as the first parameter of a
                constructor of a component or with <methodname>setCaption()</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// New text field with caption "Name"
TextField name = new TextField("Name");
layout.addComponent(name);]]></programlisting>

            <para>
                The caption of a component is, by default, managed and displayed by the
                layout component or component container inside which the component is
                placed. For example, the <classname>VerticalLayout</classname> component
                shows the captions left-aligned above the contained components, while the
                <classname>FormLayout</classname> component shows the captions on the left
                side of the vertically laid components, with the captions and their
                associated components left-aligned in their own columns. The
                <classname>CustomComponent</classname> does not manage the caption of its
                composition root, so if the root component has a caption, it will not be
                rendered.
            </para>

			<figure xml:id="figure.components.features.caption.layoutmanaged" float="center" floatstyle="before">
				<title>Caption Management by <classname>VerticalLayout</classname> and <classname>FormLayout</classname>.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-caption-layoutmanaged.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="60%" align="center" fileref="img/components/features-caption-layoutmanaged.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Some components, such as <classname>Button</classname> and
                <classname>Panel</classname>, manage the caption themselves and display it
                inside the component.
            </para>

            <para>
                Icon (see <xref linkend="components.features.icon"/>) is closely related
                to caption and is usually displayed horizontally before or after it,
                depending on the component and the containing layout. Also the required
                indicator in field components is usually shown before or after the
                caption.
            </para>

            <para>
                An alternative way to implement a caption is to use another component as
                the caption, typically a <classname>Label</classname>, a
                <classname>TextField</classname>, or a <classname>Panel</classname>. A
                <classname>Label</classname>, for example, allows highlighting a shortcut
                key with HTML markup or to bind the caption to a data source. The
                <classname>Panel</classname> provides an easy way to add both a caption
                and a border around a component.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-caption {}
  .v-captiontext {}
  .v-caption-clearelem {}
  .v-required-field-indicator {}]]></programlisting>

                <para>
                    A caption is be rendered inside an HTML element that has the
                    <literal>v-caption</literal> CSS style class. The containing layout
                    may enclose a caption inside other caption-related elements.
                </para>

                <para>
                    Some layouts put the caption text in a
                    <literal>v-captiontext</literal> element. A
                    <literal>v-caption-clearelem</literal> is used in some layouts to
                    clear a CSS <literal>float</literal> property in captions. An optional
                    required indicator in field components is contained in a separate
                    element with <literal>v-required-field-indicator</literal> style.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.features.description">
			<title>Description and Tooltips</title>

            <indexterm zone="components.features.description">
                <primary>description property</primary>
            </indexterm>

            <indexterm zone="components.features.description">
                <primary>Component interface</primary>
                <secondary>description</secondary>
            </indexterm>

            <indexterm zone="components.features.description">
                <primary>tooltips</primary>
            </indexterm>

			<para>
				All components (that inherit <classname>AbstractComponent</classname>)
				have a description separate from their caption. The description is usually
				shown as a tooltip that appears when the mouse pointer hovers over the
				component for a short time.
			</para>

			<para>
				You can set the description with <methodname>setDescription()</methodname>
				and retrieve with <methodname>getDescription()</methodname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Button button = new Button("A Button");
button.setDescription("This is the tooltip");]]></programlisting>

			<para>
				The tooltip is shown in <xref
				linkend="figure.components.tooltip.plain"/>.
			</para>

			<figure xml:id="figure.components.tooltip.plain">
				<title>Component Description as a Tooltip</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/tooltip-plain-withpointer-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="85%" align="center" fileref="img/components/tooltip-plain-withpointer-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				A description is rendered as a tooltip in most
				components.
			</para>

			<para>
				When a component error has been set with
				<methodname>setComponentError()</methodname>, the error is usually also
				displayed in the tooltip, below the description. Components that are in
				error state will also display the error indicator. See <xref
				linkend="application.errors.error-indicator"/>.
			</para>

			<para>
				The description is actually not plain text, but you can use HTML tags to
				format it. Such a rich text description can contain any HTML elements,
				including images.
			</para>

            <book-example eid="component.features.description.richtext"></book-example>
			<programlisting><?pocket-size 60% ?><![CDATA[button.setDescription(
    "<h2><img src=\"../VAADIN/themes/sampler/icons/comment_yellow.gif\"/>"+
    "A richtext tooltip</h2>"+
    "<ul>"+
    "  <li>Use rich formatting with HTML</li>"+
    "  <li>Include images from themes</li>"+
    "  <li>etc.</li>"+
    "</ul>");]]></programlisting>

			<para>
				The result is shown in <xref
				linkend="figure.components.tooltip.richtext"/>.
			</para>

			<figure xml:id="figure.components.tooltip.richtext">
				<title>A Rich Text Tooltip</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/tooltip-richtext-withpointer-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="70%" align="center" fileref="img/components/tooltip-richtext-withpointer-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Notice that the setter and getter are defined for all fields in the
				<classname>Field</classname> interface, not for all components in the
				<classname>Component</classname> interface.
			</para>
		</section>

        <section xml:id="components.features.enabled">
            <title>Enabled</title>
            
            <indexterm zone="components.features.enabled">
                <primary>enabled property</primary>
            </indexterm>

            <indexterm zone="components.features.enabled">
                <primary>Component interface</primary>
                <secondary>enabled</secondary>
            </indexterm>

            <para>
                The <emphasis>enabled</emphasis> property controls whether the user can
                actually use the component. A disabled component is visible, but grayed to
                indicate the disabled state.
            </para>

            <para>
                Components are always enabled by default. You can disable a component with
                <methodname>setEnabled(false)</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[Button enabled = new Button("Enabled");
enabled.setEnabled(true); // The default
layout.addComponent(enabled);
        
Button disabled = new Button("Disabled");
disabled.setEnabled(false);
layout.addComponent(disabled);]]></programlisting>

            <para>
                <xref linkend="figure.components.features.enabled.simple"/> shows the
                enabled and disabled buttons.
            </para>

			<figure xml:id="figure.components.features.enabled.simple">
				<title>An Enabled and Disabled <classname>Button</classname></title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-enabled-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="50%" align="center" fileref="img/components/features-enabled-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                A disabled component is automatically put in read-only state. No client
                interaction with such a component is sent to the server and, as an
                important security feature, the server-side components do not receive
                state updates from the client in the read-only state. This feature exists
                in all built-in components in Vaadin and is automatically handled for all
                <classname>Field</classname> components for the field property value. For
                custom widgets, you need to make sure that the read-only state is checked
                on the server-side for all safety-critical variables.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    Disabled components have the <literal>v-disabled</literal> CSS style
                    in addition to the component-specific style. To match a component with
                    both the styles, you have to join the style class names with a dot as
                    done in the example below.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[.v-textfield.v-disabled {
    border: dotted;
}]]></programlisting>

                <para>
                    This would make the border of all disabled text fields dotted.
                </para>
            </simplesect>

            <para>
                <!-- TODO This may change to $v-button-disabled-opacity --> In Valo theme,
                the opacity of disabled components is specified with the
                <varname>$v-disabled-opacity</varname> parameter<phrase condition="web">,
                as described in <xref linkend="themes.valo.variables"/></phrase>.
            </para>
        </section>
        
        <section xml:id="components.features.icon">
            <title>Icon</title>
            
            <indexterm zone="components.features.icon">
                <primary>icon property</primary>
            </indexterm>

            <indexterm zone="components.features.icon">
                <primary>Component interface</primary>
                <secondary>icon</secondary>
            </indexterm>

            <para>
                An icon is an explanatory graphical label accompanying a user interface
                component, usually shown above, left of, or inside the component. Icon is
                closely related to caption (see <xref
                linkend="components.features.caption"/>) and is usually displayed
                horizontally before or after it, depending on the component and the
                containing layout.
            </para>

            <para>
                The icon of a component can be set with the
                <methodname>setIcon()</methodname> method. The image is provided as a
                resource, perhaps most typically a <classname>ThemeResource</classname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Component with an icon from a custom theme
TextField name = new TextField("Name");
name.setIcon(new ThemeResource("icons/user.png"));
layout.addComponent(name);
        
// Component with an icon from another theme ('runo')
Button ok = new Button("OK");
ok.setIcon(new ThemeResource("../runo/icons/16/ok.png"));
layout.addComponent(ok);]]></programlisting>

            <para>
                The icon of a component is, by default, managed and displayed by the
                layout component or component container in which the component is
                placed. For example, the <classname>VerticalLayout</classname> component
                shows the icons left-aligned above the contained components, while the
                <classname>FormLayout</classname> component shows the icons on the left
                side of the vertically laid components, with the icons and their
                associated components left-aligned in their own columns. The
                <classname>CustomComponent</classname> does not manage the icon of its
                composition root, so if the root component has an icon, it will not be
                rendered.
            </para>

            <figure xml:id="figure.components.features.icon">
                <title>Displaying an Icon from a Theme Resource.</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/features-icon.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="80" smallscale="60%" align="center" fileref="img/components/features-icon.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            
            <para>
                Some components, such as <classname>Button</classname> and
                <classname>Panel</classname>, manage the icon themselves and display it
                inside the component.
            </para>

            <para>
                In addition to image resources, you can use <emphasis>font
                icons</emphasis>, which are icons included in special fonts, but which are
                handled as special resources. See <xref linkend="themes.fonticon"/> for
                more details.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    An icon will be rendered inside an HTML element that has the
                    <literal>v-icon</literal> CSS style class. The containing layout may
                    enclose an icon and a caption inside elements related to the caption,
                    such as <literal>v-caption</literal>.
                </para>
            </simplesect>
        </section>
        
        <section xml:id="components.features.locale">
            <title>Locale</title>
            
            <indexterm zone="components.features.locale">
                <primary>locale property</primary>
                <secondary>in <classname>Component</classname></secondary>
            </indexterm>

            <indexterm zone="components.features.locale">
                <primary>Component interface</primary>
                <secondary>locale</secondary>
            </indexterm>

            <para>
                The locale property defines the country and language used in a
                component. You can use the locale information in conjunction with an
                internationalization scheme to acquire localized resources. Some
                components, such as <classname>DateField</classname>, use the locale for
                component localization.
            </para>

            <para>
                You can set the locale of a component (or the application) with
                <methodname>setLocale()</methodname> as follows:
            </para>

            <book-example eid="component.features.locale.simple"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// Component for which the locale is meaningful
InlineDateField date = new InlineDateField("Datum");
        
// German language specified with ISO 639-1 language
// code and ISO 3166-1 alpha-2 country code. 
date.setLocale(new Locale("de", "DE"));
        
date.setResolution(Resolution.DAY);
layout.addComponent(date);]]></programlisting>

            <para>
                The resulting date field is shown in <xref
                linkend="figure.components.features.locale.simple"/>.
            </para>
            
			<figure xml:id="figure.components.features.locale.simple">
				<title>Set Locale for <classname>InlineDateField</classname></title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-locale-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="60%" align="center" fileref="img/components/features-locale-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <simplesect xml:id="components.features.locale.get" condition="web">
                <title>Getting the Locale</title>

                <para>
                    <indexterm><primary><methodname>getLocale()</methodname></primary></indexterm>

                    You can get the locale of a component with
                    <methodname>getLocale()</methodname>. If the locale is undefined for a
                    component, that is, not explicitly set, the locale of the parent
                    component is used. If none of the parent components have a locale set,
                    the locale of the UI is used, and if that is not set, the default
                    system locale is set, as given by
                    <methodname>Locale.getDefault()</methodname>.
                </para>

                <para>
                    The <methodname>getLocale()</methodname> returns null if the component
                    is not yet attached to the UI, which is usually the case in most
                    constructors, so it is a bit awkward to use it for
                    internationalization. You can get the locale in
                    <methodname>attach()</methodname>, as shown in the following example:
                </para>

                <book-example eid="component.features.locale.get-attach"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[Button cancel = new Button() {
    @Override
    public void attach() {
        super.attach();
        ResourceBundle bundle = ResourceBundle.getBundle(
            MyAppCaptions.class.getName(), getLocale());
        setCaption(bundle.getString(MyAppCaptions.CancelKey));
    }
};
layout.addComponent(cancel);]]></programlisting>

                <para>
                    However, it is normally a better practice to use the locale of the
                    current UI to get the localized resource right when the component is
                    created.
                </para>

                <book-example eid="component.features.locale.get-ui"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[// Captions are stored in MyAppCaptions resource bundle
// and the UI object is known in this context.
ResourceBundle bundle =
    ResourceBundle.getBundle(MyAppCaptions.class.getName(),
        UI.getCurrent().getLocale());
        
// Get a localized resource from the bundle
Button cancel =
    new Button(bundle.getString(MyAppCaptions.CancelKey));
layout.addComponent(cancel);]]></programlisting>
            </simplesect>

            <simplesect xml:id="component.features.locale.selecting" condition="web">
                <title>Selecting a Locale</title>

                <para>
                    A common task in many applications is selecting a locale. This is done
                    in the following example with a <classname>ComboBox</classname>, which
                    gets the available locales in Java.
                </para>

                <book-example eid="component.features.locale.selection"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[// The locale in which we want to have the language
// selection list
Locale displayLocale = Locale.ENGLISH;
        
// All known locales
final Locale[] locales = Locale.getAvailableLocales();
        
// Allow selecting a language. We are in a constructor of a
// CustomComponent, so preselecting the current
// language of the application can not be done before
// this (and the selection) component are attached to
// the application.
final ComboBox select = new ComboBox("Select a language") {
    @Override
    public void attach() {
        super.attach();
        setValue(getLocale());
    }
};
for (int i=0; i<locales.length; i++) {
    select.addItem(locales[i]);
    select.setItemCaption(locales[i],
                          locales[i].getDisplayName(displayLocale));
    
    // Automatically select the current locale
    if (locales[i].equals(getLocale()))
        select.setValue(locales[i]);
}
layout.addComponent(select);

// Locale code of the selected locale
final Label localeCode = new Label("");
layout.addComponent(localeCode);

// A date field which language the selection will change
final InlineDateField date =
    new InlineDateField("Calendar in the selected language");
date.setResolution(Resolution.DAY);
layout.addComponent(date);
        
// Handle language selection
select.addValueChangeListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        Locale locale = (Locale) select.getValue();
        date.setLocale(locale);
        localeCode.setValue("Locale code: " +
                            locale.getLanguage() + "_" +
                            locale.getCountry());
    }
});
select.setImmediate(true);]]></programlisting>

                <para>
                    The user interface is shown in <xref
                    linkend="figure.components.features.locale.selection"/>.
                </para>

                <figure xml:id="figure.components.features.locale.selection">
                    <title>Selecting a Locale</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/features-locale-selection.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-locale-selection.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

            </simplesect>
        </section>

        <section xml:id="components.features.readonly">
            <title>Read-Only</title>

            <indexterm zone="components.features.readonly">
                <primary>read-only property</primary>
            </indexterm>

            <indexterm zone="components.features.readonly">
                <primary>Component interface</primary>
                <secondary>read-only</secondary>
            </indexterm>

            <para>
                The property defines whether the value of a component can be changed. The
                property is mainly applicable to <classname>Field</classname> components,
                as they have a value that can be edited by the user.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[TextField readwrite = new TextField("Read-Write");
readwrite.setValue("You can change this");
readwrite.setReadOnly(false); // The default
layout.addComponent(readwrite);
        
TextField readonly = new TextField("Read-Only");
readonly.setValue("You can't touch this!");
readonly.setReadOnly(true);
layout.addComponent(readonly);]]></programlisting>

            <para>
                The resulting read-only text field is shown in <xref
                linkend="figure.components.features.readonly.simple"/>.
            </para>

			<figure xml:id="figure.components.features.readonly.simple">
				<title>A Read-Only Component.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-readonly-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="75%" align="center" fileref="img/components/features-readonly-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Setting a layout or some other component container as read-only does not
                usually make the contained components read-only recursively. This is
                different from, for example, the disabled state, which is usually applied
                recursively.
            </para>

            <para>
                Notice that the value of a selection component is the selection, not its
                items. A read-only selection component doesn't therefore allow its
                selection to be changed, but other changes are possible. For example, if
                you have a read-only <classname>Table</classname> in editable mode, its
                contained fields and the underlying data model can still be edited, and
                the user could sort it or reorder the columns.
            </para>

            <para>
                Client-side state modifications will not be communicated to the
                server-side and, more importantly, server-side field components will not
                accept changes to the value of a read-only <classname>Field</classname>
                component. The latter is an important security feature, because a
                malicious user can not fabricate state changes in a read-only field. This
                is handled at the level of <classname>AbstractField</classname> in
                <methodname>setValue()</methodname>, so you can not change the value
                programmatically either. Calling <methodname>setValue()</methodname> on a
                read-only field results in
                <classname>Property.ReadOnlyException</classname>. 
            </para>

            <para>
                Also notice that while the read-only status applies automatically to the
                property value of a field, it does not apply to other component
                variables. A read-only component can accept some other variable changes
                from the client-side and some of such changes could be acceptable, such as
                change in the scroll bar position of a
                <classname>Table</classname>. Custom widgets should check the read-only
                state for variables bound to business data.

                <!-- TODO: Note this also in the Advanced: Security section and
                   possibly also in the GWT chapter. -->
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    Setting a normally editable component to read-only state can change
                    its appearance to disallow editing the value. In addition to CSS
                    styling, also the HTML structure can change. For example,
                    <classname>TextField</classname> loses the edit box and appears much
                    like a <classname>Label</classname>.
                </para>

                <para>
                    A read-only component will have the <literal>v-readonly</literal>
                    style. The following CSS rule would make the text in all read-only
                    <classname>TextField</classname> components appear in italic.
                </para>

                <programlisting><![CDATA[.v-textfield.v-readonly {
    font-style: italic;
}]]></programlisting>
            </simplesect>
        </section>

        <section xml:id="components.features.stylename">
            <title>Style Name</title>

            <indexterm zone="components.features.stylename">
                <primary>style name property</primary>
            </indexterm>

            <indexterm zone="components.features.stylename">
                <primary>Component interface</primary>
                <secondary>style name</secondary>
            </indexterm>

            <para>
                The <emphasis>style name</emphasis> property defines one or more custom
                CSS style class names for the component. The
                <methodname>getStyleName()</methodname> returns the current style names as
                a space-separated list. The <methodname>setStyleName()</methodname>
                replaces all the styles with the given style name or a space-separated
                list of style names. You can also add and remove individual style names
                with <methodname>addStylename()</methodname> and
                <methodname>removeStyleName()</methodname>. A style name must be a valid
                CSS style name.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Label label = new Label("This text has a lot of style");
label.addStyleName("mystyle");
layout.addComponent(label);]]></programlisting>

            <para>
                The style name will appear in the component's HTML element in two forms:
                literally as given and prefixed with the component-specific style
                name. For example, if you add a style name <literal>mystyle</literal> to a
                <classname>Button</classname>, the component would get both
                <literal>mystyle</literal> and <literal>v-button-mystyle</literal>
                styles. Neither form may conflict with built-in style names of Vaadin. For
                example, <literal>focus</literal> style would conflict with a built-in
                style of the same name, and an <literal>content</literal> style for a
                <classname>Panel</classname> component would conflict with the built-in
                <literal>v-panel-content</literal> style.
            </para>

            <para>
                The following CSS rule would apply the style to any component that has the
                <literal>mystyle</literal> style.
            </para>

            <programlisting><![CDATA[.mystyle {
    font-family: fantasy;
    font-style:  italic;
    font-size:   25px;
    font-weight: bolder;
    line-height: 30px;
}]]></programlisting>

            <para>
                The resulting styled component is shown in <xref
                linkend="figure.components.features.stylename"/>
            </para>

			<figure xml:id="figure.components.features.stylename">
				<title>Component with a Custom Style</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-stylename-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="70%" align="center" fileref="img/components/features-stylename-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="components.features.visible">
            <title>Visible</title>
            
            <indexterm zone="components.features.visible">
                <primary>visible property</primary>
            </indexterm>

            <indexterm zone="components.features.visible">
                <primary>Component interface</primary>
                <secondary>visible</secondary>
            </indexterm>

            <para>
                Components can be hidden by setting the <emphasis>visible</emphasis>
                property to <emphasis>false</emphasis>. Also the caption, icon and any
                other component features are made hidden. Hidden components are not just
                invisible, but their content is not communicated to the browser at
                all. That is, they are not made invisible cosmetically with only CSS
                rules. This feature is important for security if you have components that
                contain security-critical information that must only be shown in specific
                application states.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField invisible = new TextField("No-see-um");
invisible.setValue("You can't see this!");
invisible.setVisible(false);
layout.addComponent(invisible);]]></programlisting>

            <para>
                The resulting invisible component is shown in <xref
                linkend="figure.components.features.visible.simple"/>.
            </para>

            <!-- TODO IMPORTANT Update to use Valo theme -->
			<figure xml:id="figure.components.features.visible.simple">
				<title>An Invisible Component.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-visible-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-visible-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Beware that invisible beings can leave footprints. The containing layout
                cell that holds the invisible component will not go away, but will show in
                the layout as extra empty space. Also expand ratios work just like if the
                component was visible - it is the layout cell that expands, not the
                component.
            </para>

            <para>
                If you need to make a component only cosmetically invisible, you should
                use a custom theme to set it <literal>display: none</literal> style. This
                is mainly useful for some special components that have effects even when
                made invisible in CSS. If the hidden component has undefined size and is
                enclosed in a layout that also has undefined size, the containing layout
                will collapse when the component disappears. If you want to have the
                component keep its size, you have to make it invisible by setting all its
                font and other attributes to be transparent. In such cases, the invisible
                content of the component can be made visible easily in the browser.
            </para>

            <para>
                A component made invisible with the <emphasis>visible</emphasis> property
                has no particular CSS style class to indicate that it is hidden. The
                element does exist though, but has <literal>display: none</literal> style,
                which overrides any CSS styling.
            </para>
        </section>

		<section xml:id="components.features.sizeable">
			<title>Sizing Components</title>

            <indexterm zone="components.features.sizeable">
                <primary><classname>Sizeable</classname> interface</primary>
            </indexterm>

			<para>
				Vaadin components are sizeable; not in the sense that they were
				fairly large or that the number of the components and their features are
				sizeable, but in the sense that you can make them fairly large on the
				screen if you like, or small or whatever size.
			</para>

			<para>
				The <classname>Sizeable</classname> interface, shared by all components,
				provides a number of manipulation methods and constants for setting the
				height and width of a component in absolute or relative units, or for
				leaving the size undefined.
			</para>

			<para>
				The size of a component can be set with
				<methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname> methods. The methods take the size as
				a floating-point value. You need to give the unit of the measure as the
				second parameter for the above methods. The available units are listed in
				<xref linkend="components.features.sizeable.units.table"/> below.
			</para>

			<programlisting><![CDATA[mycomponent.setWidth(100, Sizeable.UNITS_PERCENTAGE);
mycomponent.setWidth(400, Sizeable.UNITS_PIXELS);]]></programlisting>

			<para>
				Alternatively, you can speficy the size as a string. The format of such a
				string must follow the HTML/CSS standards for specifying measures.
			</para>

			<programlisting><![CDATA[mycomponent.setWidth("100%");
mycomponent.setHeight("400px");]]></programlisting>

			<para>
				The "<literal>100%</literal>" percentage value makes the component take
				all available size in the particular direction (see the description of
				<parameter>Sizeable.UNITS_PERCENTAGE</parameter> in the table below). You
				can also use the shorthand method <methodname>setSizeFull()</methodname>
				to set the size to 100% in both directions.
			</para>

			<para>
				The size can be <emphasis>undefined</emphasis> in either or both
				dimensions, which means that the component will take the minimum necessary
				space. Most components have undefined size by default, but some layouts
				have full size in horizontal direction. You can set the height or width as
				undefined with <parameter>Sizeable.SIZE_UNDEFINED</parameter> parameter
				for <methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname>.
			</para>

			<para>
				You always need to keep in mind that <emphasis>a layout with undefined
				size may not contain components with defined relative size</emphasis>,
				such as "full size". See <xref linkend="layout.settings.size"/> for
				details.
			</para>

			<para>
				The <xref linkend="components.features.sizeable.units.table"/> lists the
				available units and their codes defined in the
				<classname>Sizeable</classname> interface.
			</para>

			<table xml:id="components.features.sizeable.units.table">
				<title>Size Units</title>
				<tgroup cols="3" align="left">
                    <colspec colnum="1" colname="col1" colwidth="13*"/>
                    <colspec colnum="2" colname="col2" colwidth="3*"/>
                    <colspec colnum="3" colname="col3" colwidth="30*"/>
					<tbody>
						<row valign="top">
							<entry><parameter>Unit.PIXELS</parameter></entry>
							<entry>px</entry>

							<entry>The <emphasis>pixel</emphasis> is the basic
							hardware-specific measure of one physical display
							pixel.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.POINTS</parameter></entry>
							<entry>pt</entry>

							<entry>The <emphasis>point</emphasis> is a typographical unit,
							which is usually defined as 1/72 inches or about 0.35
							mm. However, on displays the size can vary significantly
							depending on display metrics.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.PICAS</parameter></entry>
							<entry>pc</entry>

							<entry>The <emphasis>pica</emphasis> is a typographical unit,
							defined as 12 points, or 1/7 inches or about 4.233 mm. On
							displays, the size can vary depending on display
							metrics.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.EM</parameter></entry>
							<entry>em</entry>

							<entry>A unit relative to the used font, the width of the
							upper-case "M" letter.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.EX</parameter></entry>
							<entry>ex</entry>

							<entry>A unit relative to the used font, the height of the
							lower-case "x" letter.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.MM</parameter></entry>
							<entry>mm</entry>

							<entry>A physical length unit, millimeters on the surface of a
							display device. However, the actual size depends on the
							display, its metrics in the operating system, and the
							browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.CM</parameter></entry>
							<entry>cm</entry>

							<entry>A physical length unit,
							<emphasis>centimeters</emphasis> on the surface of a display
							device. However, the actual size depends on the display, its
							metrics in the operating system, and the browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.INCH</parameter></entry>
							<entry>in</entry>

							<entry>A physical length unit, <emphasis>inches</emphasis> on the surface of a
							display device. However, the actual size depends on the
							display, its metrics in the operating system, and the
							browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>Unit.PERCENTAGE</parameter></entry>
							<entry>%</entry>

							<entry>A relative percentage of the available size. For
							example, for the top-level layout <parameter>100%</parameter>
							would be the full width or height of the browser window. The
							percentage value must be between 0 and 100.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				If a component inside <classname>HorizontalLayout</classname> or
				<classname>VerticalLayout</classname> has full size in the namesake
				direction of the layout, the component will expand to take all available
				space not needed by the other components. See <xref
				linkend="layout.settings.size"/> for details.
			</para>
		</section>

		<!-- section>
			<title>Buffering Data (<classname>Buffered</classname> interface)</title>
		</section>
				
		<section>
			<title>Validating Fields (<classname>Validatable</classname> interface)</title>
		</section -->
				
		<section>
			<title>Managing Input Focus</title>

			<para>
				When the user clicks on a component, the component gets the
				<emphasis>input focus</emphasis>, which is indicated by highlighting
				according to style definitions. If the component allows inputting text,
				the focus and insertion point are indicated by a cursor. Pressing the
				<keycap>Tab</keycap> key moves the focus to the component next in the
				<emphasis>focus order</emphasis>.
			</para>

			<para>
				Focusing is supported by all <classname>Field</classname> components and
				also by <classname>Upload</classname>.
			</para>

			<para>
				The focus order or <emphasis>tab index</emphasis> of a component is
				defined as a positive integer value, which you can set with
				<methodname>setTabIndex()</methodname> and get with
				<methodname>getTabIndex()</methodname>. The tab index is managed in the
				context of the page in which the components are contained. The focus order
				can therefore jump between two any lower-level component containers, such
				as sub-windows or panels.
			</para>

			<para>
				The default focus order is determined by the natural hierarchical order of
				components in the order in which they were added under their parents. The
				default tab index is 0 (zero).
			</para>

			<para>
				Giving a negative integer as the tab index removes the component from the
				focus order entirely.
			</para>

			<simplesect>
				<title>CSS Style Rules</title>

				<para>
					The component having the focus will have an additional style class
					with the <literal>-focus</literal> suffix. For example, a
					<classname>TextField</classname>, which normally has the
					<literal>v-textfield</literal> style, would additionally have the
					<literal>v-textfield-focus</literal> style.
				</para>

				<para>
					For example, the following would make a text field blue when it has
					focus.
				</para>

				<programlisting><![CDATA[.v-textfield-focus {
    background: lightblue;
}]]></programlisting>
            </simplesect>
        </section>
	</section>

    <section xml:id="components.fields">
        <title>Field Components</title>

        <indexterm xml:id="term.components.fields" class="startofrange">
            <primary><classname>Field</classname></primary>
        </indexterm>

        <para>
            <emphasis>Fields</emphasis> are components that have a value that the user can
            change through the user interface. <xref
            linkend="figure.components.fields"/> illustrates the inheritance
            relationships and the important interfaces and base classes.
        </para>

        <figure xml:id="figure.components.fields" float="center" floatstyle="before">
            <title>Field Components</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/field-diagram-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/components/field-diagram-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Field components are built upon the framework defined in the
            <classname>Field</classname> interface and the
            <classname>AbstractField</classname> base class.
            <classname>AbstractField</classname> is the base class for all field
            components. In addition to the component features inherited from
            <classname>AbstractComponent</classname>, it implements a number of features
            defined in <classname>Property</classname>, <classname>Buffered</classname>,
            <classname>Validatable</classname>, and
            <classname>Component.Focusable</classname> interfaces.
        </para>

        <para>
            The description of the field interfaces and base classes is broken down in
            the following sections.
        </para>

        <section xml:id="components.fields.field">
            <title><classname>Field</classname> Interface</title>

            <para>
                The <classname>Field</classname> interface inherits the
                <classname>Component</classname> superinterface and also the
                <classname>Property</classname> interface to have a value for the
                field. <classname>AbstractField</classname> is the only class implementing
                the <classname>Field</classname> interface directly.  The relationships
                are illustrated in <xref
                linkend="figure.components.fields.field"/>.
            </para>

            <figure xml:id="figure.components.fields.field" float="center" floatstyle="before">
                <title><classname>Field</classname> Interface Inheritance Diagram</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/field-interface-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/components/field-interface-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can set the field value with the <methodname>setValue()</methodname>
                and read with the <methodname>getValue()</methodname> method defined in
                the <classname>Property</classname> interface. The actual value type
                depends on the component.
            </para>

            <para>
                The <classname>Field</classname> interface defines a number of
                attributes, which you can retrieve or manipulate with the
                corresponding setters and getters.
            </para>

            <variablelist>
                <varlistentry>
                    <term><methodname>description</methodname></term>
                    <listitem>
                        <para>
                            All fields have a description. Notice that while this
                            attribute is defined in the
                            <classname>Field</classname> component, it is
                            implemented in <classname>AbstractField</classname>,
                            which does not directly implement
                            <classname>Field</classname>, but only through the
                            <classname>AbstractField</classname> class.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>required</methodname></term>
                    <listitem>
                        <para>
                            When enabled, a required indicator (usually the asterisk *
                            character) is displayed on the left, above, or right the
                            field, depending on the containing layout and whether the
                            field has a caption. If such fields are validated but are
                            empty and the <methodname>requiredError</methodname>
                            property (see below) is set, an error indicator is shown
                            and the component error is set to the text defined with
                            the error property. Without validation, the required
                            indicator is merely a visual guide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>requiredError</methodname></term>
                    <listitem>
                        <para>
                            Defines the error message to show when a value is
                            required, but none is entered. The error message is set as
                            the component error for the field and is usually displayed
                            in a tooltip when the mouse pointer hovers over the error
                            indicator.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>

        <section xml:id="components.fields.databinding">
            <title>Data Binding and Conversions</title>

            <para>
                Fields are strongly coupled with the Vaadin data model. The field value is
                handled as a <classname>Property</classname> of the field component, as
                documented in <xref linkend="datamodel.properties"/>. Selection fields
                allow management of the selectable items through the
                <classname>Container</classname> interface.
            </para>

            <para>
                Fields are <emphasis>editors</emphasis> for some particular type. For
                example, <classname>TextField</classname> allows editing
                <classname>String</classname> values. When bound to a data source, the
                property type of the data model can be something different, say an
                <classname>Integer</classname>. <emphasis>Converters</emphasis> are used
                for converting the values between the representation and the model. They
                are described in <xref linkend="datamodel.properties.converter"/>.
            </para>
        </section>

        <section xml:id="components.fields.valuechanges">
            <title>Handling Field Value Changes</title>
				
            <para>
                <classname>Field</classname> inherits
                <classname>Property.ValueChangeListener</classname> to allow listening
                for field value changes and <classname>Property.Editor</classname> to
                allow editing values.
            </para>

            <para>
                When the value of a field changes, a
                <classname>Property.ValueChangeEvent</classname> is triggered for the
                field. You should not implement the <methodname>valueChange()</methodname>
                method in a class inheriting <classname>AbstractField</classname>, as it
                is already implemented in <classname>AbstractField</classname>. You should
                instead implement the method explicitly by adding the implementing object
                as a listener.
            </para>
        </section>

        <section xml:id="components.fields.buffering">
            <title>Field Buffering</title>

            <para>
                Field components implement the <interfacename>Buffered</interfacename> and
                <interfacename>BufferedValidatable</interfacename> interfaces.  When
                buffering is enabled for a field with
                <methodname>setBuffered(true)</methodname>, the value is not written to
                the property data source before the <methodname>commit()</methodname>
                method is called for the field. Calling <methodname>commit()</methodname>
                also runs validators added to the field, and if any fail (and the
                <parameter>invalidCommitted</parameter> is disabled), the value is not
                written.
            </para>

            <book-example eid="component.field.buffering.basic" style="float: right"></book-example>
            <programlisting><![CDATA[form.addComponent(new Button("Commit",
    new Button.ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        try {
            editor.commit();
        } catch (InvalidValueException e) {
            Notification.show(e.getMessage());
        }
    }
}));]]></programlisting>

            <para>
                Calling <methodname>discard()</methodname> reads the value from the
                property date source to the current input.
            </para>

            <para>
                If the fields are bound in a <classname>FieldGroup</classname> that has
                buffering enabled, calling <methodname>commit()</methodname> for the group
                runs validation on all fields in the group, and if successful, all the
                field values are written to the item data source. See <xref
                linkend="datamodel.itembinding.buffering"/>.
            </para>
        </section>

        <section xml:id="components.fields.validation">
            <title>Field Validation</title>

            <para>
                The input for a field component can be syntactically or semantically
                invalid. Fields implement the <interfacename>Validatable</interfacename>
                interface, which allows checking validity of the input with
                <emphasis>validators</emphasis> that implement the
                <interfacename>Validator</interfacename> interface. You can add validators
                to fields with <methodname>addValidator()</methodname>.
            </para>

            <book-example eid="component.field.validation.basic" style="float: right"></book-example>
            <programlisting><![CDATA[TextField field = new TextField("Name");
field.addValidator(new StringLengthValidator(
    "The name must be 1-10 letters (was {0})",
    1, 10, true));
layout.addComponent(field);]]></programlisting>

            <para>
                Failed validation is indicated with the error indicator of the field,
                described in <xref linkend="application.errors.error-indicator"/>, unless
                disabled with
                <methodname>setValidationVisible(false)</methodname>. Hovering mouse on
                the field displays the error message given as a parameter for the
                validator. If validated explicitly with
                <methodname>validate()</methodname>, as described later, the
                <classname>InvalidValueException</classname> is thrown if the validation
                fails, also carrying the error message. The value <literal>{0}</literal>
                in the error message string is replaced with the invalid input value.
            </para>

            <para>
                Validators validate the property type of the field after a possible
                conversion, not the presentation type. For example, an
                <classname>IntegerRangeValidator</classname> requires that the value type
                of the property data source is <classname>Integer</classname>.
            </para>

            <section xml:id="components.fields.validation.builtin">
                <title>Built-in Validators</title>

                <para>
                    Vaadin includes the following built-in validators. The property value
                    type is indicated.
                </para>



                <variablelist>
                    <varlistentry>
                        <term><classname>BeanValidator</classname></term>
                        <listitem>
                            <para>
                                Validates a bean property according to annotations defined
                                in the Bean Validation API 1.0 (JSR-303). This validator
                                is usually not used explicitly, but they are created
                                implicitly when binding fields in a
                                <classname>BeanFieldGroup</classname>. Using bean
                                validation requires an implementation library of the
                                API. See <xref
                                linkend="datamodel.itembinding.beanvalidation"/> for
                                details.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>CompositeValidator</classname></term>
                        <listitem>
                            <para>
                                Combines validators using logical AND and OR operators.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>DateRangeValidator</classname>: <classname>Date</classname></term>
                        <listitem>
                            <para>
                                Checks that the date value is within the range at or
                                between two given dates/times.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>DoubleRangeValidator</classname>: <classname>Double</classname></term>
                        <listitem>
                            <para>
                                Checks that the double value is at or between two given values.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>EmailValidator</classname>: <classname>String</classname></term>
                        <listitem>
                            <para>
                                Checks that the string value is a syntactically valid
                                email address. The validated syntax is close to the RFC
                                822 standard regarding email addresses.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>IntegerRangeValidator</classname>: <classname>Integer</classname></term>
                        <listitem>
                            <para>
                                Checks that the integer value is at or between two given values.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>NullValidator</classname></term>
                        <listitem>
                            <para>
                                Checks that the value is or is not a null value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>RegexpValidator</classname>: <classname>String</classname></term>
                        <listitem>
                            <para>
                                Checks that the value matches with the given regular expression.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>StringLengthValidator</classname>: <classname>String</classname></term>
                        <listitem>
                            <para>
                                Checks that the length of the input string is at or
                                between two given lengths.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    Please see the API documentation for more details.
                </para>
            </section>

            <section xml:id="components.fields.validation.automatic">
                <title>Automatic Validation</title>
                
                <para>
                    The validators are normally, when <literal>validationVisible</literal>
                    is true for the field, executed implicitly on the next server request
                    if the input has changed. If the field is in immediate mode, it (and
                    any other fields with changed value) are validated immediately when
                    the focus leaves the field.
                </para>

                <book-example eid="component.field.validation.basic" style="float: right"></book-example>
                <programlisting><![CDATA[TextField field = new TextField("Name");
field.addValidator(new StringLengthValidator(
    "The name must be 1-10 letters (was {0})",
    1, 10, true));
field.setImmediate(true);
layout.addComponent(field);]]></programlisting>
            </section>

            <section xml:id="components.fields.validation.explicit">
                <title>Explicit Validation</title>

                <para>
                    The validators are executed when the
                    <methodname>validate()</methodname> or
                    <methodname>commit()</methodname> methods are called for the field.
                </para>

                <book-example eid="component.field.validation.explicit" style="float: right"></book-example>
                <programlisting><![CDATA[// A field with automatic validation disabled
final TextField field = new TextField("Name");
layout.addComponent(field);
        
// Define validation as usual
field.addValidator(new StringLengthValidator(
    "The name must be 1-10 letters (was {0})",
    1, 10, true));
        
// Run validation explicitly
Button validate = new Button("Validate");
validate.addClickListener(new ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        field.setValidationVisible(false);
        try {
            field.validate();
        } catch (InvalidValueException e) {
            Notification.show(e.getMessage());
            field.setValidationVisible(true);
        }
    }
});
layout.addComponent(validate);]]></programlisting>

            </section>

            <section xml:id="components.fields.validation.custom">
                <title>Implementing a Custom Validator</title>

                <para>
                    You can create custom validators by implementing the
                    <interfacename>Validator</interfacename> interface and implementing
                    its <methodname>validate()</methodname> method. If the validation
                    fails, the method should throw either
                    <classname>InvalidValueException</classname> or
                    <classname>EmptyValueException</classname>.
                </para>

                <book-example eid="component.field.validation.customvalidator" style="float: right"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[class MyValidator implements Validator {
    @Override
    public void validate(Object value)
            throws InvalidValueException {
        if (!(value instanceof String &&
                ((String)value).equals("hello")))
            throw new InvalidValueException("You're impolite");
    }
}

final TextField field = new TextField("Say hello");
field.addValidator(new MyValidator());
field.setImmediate(true);
layout.addComponent(field);]]></programlisting>

            </section>

            <section xml:id="components.fields.validation.fieldgroup">
                <title>Validation in Field Groups</title>

                <para>
                    If the field is bound to a <classname>FieldGroup</classname>,
                    described in <xref linkend="datamodel.itembinding"/>, calling
                    <methodname>commit()</methodname> for the group runs the validation
                    for all the fields in the group, and if successful, writes the input
                    values to the data source.
                </para>
            </section>
        </section>

        <indexterm startref="term.components.fields" class="endofrange"/>
    </section>

	<section xml:id="components.selection">
		<title>Selection Components</title>

		<para>
			Vaadin offers many alternative ways for selecting one or more items. The core
			library includes the following selection components, all based on the
			<classname>AbstractSelect</classname> class:
		</para>

        <variablelist>
            <varlistentry>
                <term><classname>ComboBox</classname>
                      (Section <xref linkend="components.combobox" xrefstyle="select:labelnumber"/>)</term>
                <listitem>
                    A drop-down list with a text box, where the user can type text to find
                    matching items. The component also provides an input prompt and the
                    user can enter new items.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ListSelect</classname>
                      (Section <xref linkend="components.listselect" xrefstyle="select:labelnumber"/>)</term>
                <listitem>
                    A vertical list box for selecting items in either single or multiple
                    selection mode.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>NativeSelect</classname>
                      (Section <xref linkend="components.nativeselect" xrefstyle="select:labelnumber"/>)</term>
                <listitem>
                    Provides selection using the native selection component of the
                    browser, typically a drop-down list for single selection and a
                    multi-line list in multiselect mode. This uses the
                    <literal>&lt;select&gt;</literal> element in HTML.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>OptionGroup</classname>
                      (Section <xref linkend="components.optiongroup" xrefstyle="select:labelnumber"/>)</term>
                <listitem>
                    Shows the items as a vertically arranged group of radio buttons in the
                    single selection mode and of check boxes in multiple selection mode.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>TwinColSelect</classname>
                      (Section <xref linkend="components.twincolselect" xrefstyle="select:labelnumber"/>)</term>
                <listitem>
                    Shows two list boxes side by side where the user can select items from
                    a list of available items and move them to a list of selected items
                    using control buttons.
                </listitem>
            </varlistentry>
        </variablelist>

		<para>
			In addition, the <classname>Tree</classname>, <classname>Table</classname>,
			and <classname>TreeTable</classname> components allow special forms of
			selection. They also inherit the <classname>AbstractSelect</classname>.
		</para>

        <section xml:id="components.selection.databinding">
            <title>Binding Selection Components to Data</title>

            <para>
                The selection components are strongly coupled with the Vaadin Data Model,
                described in <xref linkend="datamodel"/>. The selectable items in all
                selection components are objects that implement the
                <classname>Item</classname> interface. The items are contained in a
                <classname>Container</classname>.
            </para>

            <para>
                All selection components are containers themselves and simply forward all
                container operations to the underlying container data source. You can give
                the container in the constructor or set it set
                <methodname>setContainerDataSource()</methodname>. This is further
                described in <xref linkend="datamodel.container.intro"/>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a container data source of some kind
IndexedContainer container = new IndexedContainer();
container.addContainerProperty("name", String.class, null);
...

// Create a selection component bound to the container
OptionGroup group = new OptionGroup("My Select", container);]]></programlisting>

            <para>
                If you do not bind a selection component to a container data source, a
                default container is used. It is usually either an
                <classname>IndexedContainer</classname> or a
                <classname>HierarchicalContainer</classname>.
            </para>

            <para>
                The current selection of a selection component is bound to the
                <classname>Property</classname> interface, so you can get the current
                selection as the value of the selection component. Also selection changes
                are handled as value change events, as is described later.
            </para>
        </section>

        <section xml:id="components.selection.adding">
            <title>Adding New Items</title>
            
            <para>
                New items are added with the <methodname>addItem()</methodname> method
                defined in the <classname>Container</classname> interface, described in
                <xref linkend="datamodel.container.intro"/>.
            </para>

            <programlisting><![CDATA[// Create a selection component
ComboBox select = new ComboBox("My ComboBox");

// Add items with given item IDs
select.addItem("Mercury");
select.addItem("Venus");
select.addItem("Earth");]]></programlisting>

            <para>
                The <methodname>addItem()</methodname> method creates an empty
                <classname>Item</classname>, which is identified by its <emphasis>item
                identifier</emphasis> (IID) object, given as the parameter. This item ID
                is by default used also as the caption of the item, as described in more
                detail later.
            </para>

            <para>
                We emphasize that <methodname>addItem()</methodname> is a factory method
                that <emphasis>takes an item ID, not the actual item</emphasis> as the
                parameter - the item is returned by the method. The item is of a type that
                is specific to the container and has itself little relevance for most
                selection components, as the properties of an item may not be used in any
                way (except in <classname>Table</classname>), only the item ID.
            </para>

            <para>
                The item identifier is typically a string, in which case it can be used as
                the caption, but can be any object type. We could as well have given
                integers for the item identifiers and set the captions explicitly with
                <methodname>setItemCaption()</methodname>. You could also add an item with
                the parameterless <methodname>addItem()</methodname>, which returns an
                automatically generated item ID.
            </para>

            <programlisting><![CDATA[// Create a selection component
ComboBox select = new ComboBox("My Select");

// Add an item with a generated ID
Object itemId = select.addItem();
select.setItemCaption(itemId, "The Sun");

// Select the item
select.setValue(itemId);]]></programlisting>

            <para>
                Some container types may support passing the actual data object to the add
                method. For example, you can add items to a
                <classname>BeanItemContainer</classname> with
                <methodname>addBean()</methodname>. Such implementations can use a
                separate item ID object, or the data object itself as the item ID, as is
                done in <methodname>addBean()</methodname>. In the latter case you can not
                depend on the default way of acquiring the item caption; see the
                description of the different caption modes later.
            </para>

            <para>
                The next section describes the different options for determining the item
                captions.
            </para>
        </section>

        <section xml:id="components.selection.captions">
            <title>Item Captions</title>

            <para>
                The displayed captions of items in a selection component can be set
                explicitly with <methodname>setItemCaption()</methodname> or determined
                from the item IDs or item properties. The caption determination is defined
                with the <emphasis>caption mode</emphasis>, any of the modes in the
                <classname>AbstractSelect.ItemCaptionMode</classname> enum, which you can
                set with <methodname>setItemCaptionMode()</methodname>. The default mode
                is <parameter>EXPLICIT_DEFAULTS_ID</parameter>, which uses the item
                identifiers for the captions, unless given explicitly.
            </para>

            <para>
                In addition to a caption, an item can have an icon. The icon is set with
                <methodname>setItemIcon()</methodname>.
            </para>

            <para>
                The caption modes defined in <classname>ItemCaptionMode</classname> are
                the following:
            </para>

            <variablelist>
                <title>Caption Modes for Selection Components</title>
                <varlistentry>
                    <term><constant>EXPLICIT_DEFAULTS_ID</constant></term>
                    <listitem>
                        <para>
                            This is the default caption mode and its flexibility allows
                            using it in most cases. By default, the item identifier will
                            be used as the caption. The identifier object does not
                            necessarily have to be a string; the caption is retrieved with
                            <methodname>toString()</methodname> method. If the caption is
                            specified explicitly with
                            <methodname>setItemCaption()</methodname>, it overrides the
                            item identifier.
                        </para>

                        <programlisting><?pocket-size 65% ?><![CDATA[// Create a selection component
ComboBox select = new ComboBox("Moons of Mars");
select.setItemCaptionMode(ItemCaptionMode.EXPLICIT_DEFAULTS_ID);

// Use the item ID also as the caption of this item
select.addItem(new Integer(1));

// Set item caption for this item explicitly
select.addItem(2); // same as "new Integer(2)"
select.setItemCaption(2, "Deimos");]]></programlisting>

                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>EXPLICIT</constant></term>
                    <listitem>
                        <para>
                            Captions must be explicitly specified with
                            <methodname>setItemCaption()</methodname>. If they are not,
                            the caption will be empty. Such items with empty captions will
                            nevertheless be displayed in the selection component as empty
                            items. If they have an icon, they will be visible.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>ICON_ONLY</constant></term>
                    <listitem>
                        <para>
                            Only icons are shown, captions are hidden.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>ID</constant></term>
                    <listitem>
                        <para>
                            String representation of the item identifier object is used as
                            caption. This is useful when the identifier is a string, and
                            also when the identifier is an complex object that has a
                            string representation. For example:
                        </para>
                            
                        <programlisting><?pocket-size 70% ?><![CDATA[ComboBox select = new ComboBox("Inner Planets");
select.setItemCaptionMode(ItemCaptionMode.ID);

// A class that implements toString()
class PlanetId extends Object implements Serializable {
    String planetName;

    PlanetId (String name) {
        planetName = name;
    }
    public String toString () {
        return "The Planet " + planetName;
    }
}

// Use such objects as item identifiers
String planets[] = {"Mercury", "Venus", "Earth", "Mars"};
for (int i=0; i<planets.length; i++)
    select.addItem(new PlanetId(planets[i]));]]></programlisting>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>INDEX</constant></term>
                    <listitem>
                        <para>
                            Index number of item is used as caption. This caption mode is
                            applicable only to data sources that implement the
                            <classname>Container.Indexed</classname> interface. If the
                            interface is not available, the component will throw a
                            <classname>ClassCastException</classname>. The
                            <classname>AbstractSelect</classname> itself does not
                            implement this interface, so the mode is not usable without a
                            separate data source. An
                            <classname>IndexedContainer</classname>, for example, would
                            work.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>ITEM</constant></term>
                    <listitem>
                        <para>
                            <classname>String</classname> representation of item, acquired
                            with <methodname>toString()</methodname>, is used as the
                            caption. This is applicable mainly when using a custom
                            <classname>Item</classname> class, which also requires using a
                            custom <classname>Container</classname> that is used as a data
                            source for the selection component.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>PROPERTY</constant></term>
                    <listitem>
                        <para>
                            Item captions are read from the <classname>String</classname>
                            representation of the property with the identifier specified
                            with <methodname>setItemCaptionPropertyId()</methodname>. This
                            is useful, for example, when you have a container that you use
                            as the data source for the selection component, and you want
                            to use a specific property for caption.
                        </para>
                            
                        <para>
                            In the example below, we bind a selection component to a bean
                            container and use a property of the bean as the caption.
                        </para>
                            
                        <programlisting><?pocket-size 65% ?><![CDATA[/** A bean with a "name" property. */
public class Planet implements Serializable {
    int    id;
    String name;
    
    public Planet(int id, String name) {
        this.id   = id;
        this.name = name;
    }

    ... setters and getters ...    
}

public void captionproperty(VerticalLayout layout) {
    // Have a bean container to put the beans in
    BeanItemContainer<Planet> container =
        new BeanItemContainer<Planet>(Planet.class);

    // Put some example data in it
    container.addItem(new Planet(1, "Mercury"));
    container.addItem(new Planet(2, "Venus"));
    container.addItem(new Planet(3, "Earth"));
    container.addItem(new Planet(4, "Mars"));

    // Create a selection component bound to the container
    ComboBox select = new ComboBox("Planets", container);

    // Set the caption mode to read the caption directly
    // from the 'name' property of the bean
    select.setItemCaptionMode(ItemCaptionMode.PROPERTY);
    select.setItemCaptionPropertyId("name");

    ...]]></programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>

        <section xml:id="components.selection.getset">
            <title>Getting and Setting Selection</title>

            <para>
                A selection component provides the current selection as the property of
                the component (with the <classname>Property</classname> interface). The
                property value is an item identifier object that identifies the selected
                item. You can get the identifier with <methodname>getValue()</methodname>
                of the <classname>Property</classname> interface.
            </para>

            <para>
                You can select an item with the corresponding
                <methodname>setValue()</methodname> method. In multiselect mode, the
                property will be an unmodifiable set of item identifiers. If no item is
                selected, the property will be <parameter>null</parameter> in single
                selection mode or an empty collection in multiselect mode.
            </para>

            <para>
                The <classname>ComboBox</classname> and
                <classname>NativeSelect</classname> will show empty selection when no
                actual item is selected. This is the <emphasis>null selection item
                identifier</emphasis>. You can set an alternative ID with
                <methodname>setNullSelectionItemId()</methodname>. Setting the alternative
                null ID is merely a visual text; the <methodname>getValue()</methodname>
                will still return <parameter>null</parameter> value if no item is
                selected, or an empty set in multiselect mode.
            </para>
        </section>

        <section xml:id="components.selection.valuechange">
            <title>Handling Selection Changes</title>

            <para>
                The item identifier of the currently selected item will be set as the
                property of the selection component. You can access it with the
                <methodname>getValue()</methodname> method of the
                <classname>Property</classname> interface of the component. Also, when
                handling selection changes with a
                <classname>Property.ValueChangeListener</classname>, the
                <classname>ValueChangeEvent</classname> will have the selected item as the
                property of the event, accessible with the
                <methodname>getProperty()</methodname> method.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Create a selection component with some items
ComboBox select = new ComboBox("My Select");
select.addItems("Io", "Europa", "Ganymedes", "Callisto");
        
// Handle selection change
select.addValueChangeListener(event -> // Java 8
    layout.addComponent(new Label("Selected " +
        event.getProperty().getValue())));]]></programlisting>

            <para>
                The result of user interaction is shown in <xref
                linkend="figure.components.selection.valuechange"/>.
            </para>

            <figure xml:id="figure.components.selection.valuechange">
                <title>Selected Item</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="40%" align="center" fileref="img/components/select-selected1.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

		<!-- <para>
		While the default caption mode is flexible enough for most
		cases where the appearance of a <classname>Select</classname>
		component is fixed, the other modes may be useful for cases where the
		user can configure what type of information is shown in the
		component. Typical situation is allowing the user to choose between
		"Show text only", "Show icons only", and "Show both icons and text".
		</para>-->

        <section xml:id="components.selection.newitems">
            <title>Allowing Adding New Items</title>

			<para>
				Some selection components can allow the user to add new items. Currently,
				only <classname>ComboBox</classname> allows it, when the user types in a
				value and presses <keycap>Enter</keycap>. You need to enable the mode with
				<methodname>setNewItemsAllowed(true)</methodname>. Setting the component
				also in immediate mode may be necessary, as otherwise the item would not
				be added immediately when the user interacts with the component, but after
				some other component causes a server request.  <!-- TODO This could be a
				bug -->
			</para>

			<programlisting><![CDATA[myselect.setNewItemsAllowed(true);
myselect.setImmediate(true);]]></programlisting>

            <para>
                The user interface for adding new items depends on the selection
                component. The regular <classname>ComboBox</classname> component allows
                you to simply type the new item in the combo box and hit
                <keycap>Enter</keycap> to add it.
            </para>

			<para>
				Adding new items is not possible if the selection component is read-only
				or is bound to a <classname>Container</classname> that does not allow
				adding new items, and an attempt may result in an exception.
			</para>

            <section xml:id="components.selection.newitems.handling">
                <title>Handling New Items</title>

                <para>
                    Adding new items is handled by a
                    <interfacename>NewItemHandler</interfacename>, which gets the item
                    caption string as parameter for the
                    <methodname>addNewItem()</methodname> method. The default
                    implementation, <classname>DefaultNewItemHandler</classname>, checks
                    for read-only state, adds the item using the entered caption as the
                    item ID, and if the selection component gets the captions from a
                    property, copies the caption to that property. It also selects the
                    item. The default implementation may not be suitable for all container
                    types, in which case you need to define a custom handler. For example,
                    a <classname>BeanItemContainer</classname> expects the items to have
                    the bean object itself as the ID, not a string.
                </para>

                <book-example eid="component.select.combobox.newitemhandler" style="float: right"/>
                <programlisting condition="web"><?pocket-size 65% ?><![CDATA[// Have a bean container to put the beans in
final BeanItemContainer<Planet> container =
    new BeanItemContainer<Planet>(Planet.class);

// Put some example data in it
container.addItem(new Planet(1, "Mercury"));
container.addItem(new Planet(2, "Venus"));
container.addItem(new Planet(3, "Earth"));
container.addItem(new Planet(4, "Mars"));

final ComboBox select =
    new ComboBox("Select or Add a Planet", container);
select.setNullSelectionAllowed(false);
        
// Use the name property for item captions
select.setItemCaptionPropertyId("name");
        
// Allow adding new items
select.setNewItemsAllowed(true);
select.setImmediate(true);

// Custom handling for new items
select.setNewItemHandler(new NewItemHandler() {
    @Override
    public void addNewItem(String newItemCaption) {
        // Create a new bean - can't set all properties
        Planet newPlanet = new Planet(0, newItemCaption);
        container.addBean(newPlanet);
        
        // Remember to set the selection to the new item
        select.select(newPlanet);
        
        Notification.show("Added new planet called " +
                          newItemCaption);
    }
});]]></programlisting>
            </section>
        </section>

		<section xml:id="components.selection.multiple">
			<title>Multiple Selection</title>

			<!-- UNFINISHED: Check if outdated. -->
			
			<para>
                Some selection components, such as <classname>OptionGroup</classname> and
                <classname>ListSelect</classname> support a multiple selection mode, which
                you can enable with <methodname>setMultiSelect()</methodname>. For
                <classname>TwinColSelect</classname>, which is especially intended for
                multiple selection, it is enabled by default.
			</para>

			<programlisting><![CDATA[myselect.setMultiSelect(true);]]></programlisting>

			<para>
				As in single selection mode, the property value of the component indicates
				the selection. In multiple selection mode, however, the property value is
				a <classname>Collection</classname> of the item IDs of the currently
				selected items. You can get and set the property with the
				<methodname>getValue()</methodname> and
				<methodname>setValue()</methodname> methods as usual.
			</para>

			<para>
                A change in the selection will trigger a
                <classname>ValueChangeEvent</classname>, which you can handle with a
                <classname>Propery.ValueChangeListener</classname>. As usual, you should
                use <methodname>setImmediate(true)</methodname> to trigger the event
                immediately when the user changes the selection. The following example
                shows how to handle selection changes with a listener.
			</para>

            <!-- TODO Check this example -->
            <programlisting><?pocket-size 65% ?><![CDATA[// A selection component with some items
ListSelect select = new ListSelect("My Selection");
select.addItems("Mercury", "Venus", "Earth",
    "Mars", "Jupiter", "Saturn", "Uranus", "Neptune");

// Multiple selection mode
select.setMultiSelect(true);

// Feedback on value changes
select.addValueChangeListener(
    new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Some feedback
        layout.addComponent(new Label("Selected: " +
            event.getProperty().getValue().toString()));
    }
});
select.setImmediate(true);]]></programlisting>

        </section>

		<section xml:id="components.selection.item-icons">
            <title>Item Icons</title>

            <para>
                You can set an icon for each item with
                <methodname>setItemIcon()</methodname>, or define an item property that
                provides the icon resource with
                <methodname>setItemIconPropertyId()</methodname>, in a fashion similar to
                captions. Notice, however, that icons are not supported in
                <classname>NativeSelect</classname>, <classname>TwinColSelect</classname>,
                and some other selection components and modes. This is because HTML does
                not support images inside the native <literal>select</literal>
                elements. Icons are also not really visually applicable.
            </para>
        </section>
    </section>

	<section xml:id="components.extensions">
		<title>Component Extensions</title>

        <para>
            Components and UIs can have extensions which are attached to the component
            dynamically. Especially, many add-ons are extensions.
        </para>

        <para>
            How a component is extended depends on the extension. Typically, they have an
            <methodname>extend()</methodname> method that takes the component to be
            extended as the parameter.
        </para>

        <programlisting><![CDATA[TextField tf = new TextField("Hello");
layout.addComponent(tf);

// Add a simple extension
new CapsLockWarning().extend(tf);

// Add an extension that requires some parameters
CSValidator validator = new CSValidator();
validator.setRegExp("[0-9]*");
validator.setErrorMessage("Must be a number");
validator.extend(tf);]]></programlisting>

        <para>
            Development of custom extensions is described in <xref
            linkend="gwt.extension"/>.
        </para>
    </section>

	<section xml:id="components.label">
		<title><classname>Label</classname></title>

		<para>
			<classname>Label</classname> component displays non-editable text. This text
			can be used for short simple labels or for displaying long text, such as
			paragraphs. The text can be formatted in HTML or as preformatted text,
			depending on the <emphasis>content mode</emphasis> of the label.
		</para>

        <para>
            You can give the label text most conviniently in the constructor, as is done
            in the following. Label has 100% default width, so the containing layout must
            also have defined width.
        </para>

		<book-example eid="component.label.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[// A container that is 100% wide by default
VerticalLayout layout = new VerticalLayout();

Label label = new Label("Labeling can be dangerous");
layout.addComponent(label);]]></programlisting>

        <para>
            <classname>Label</classname> implements the
            <interfacename>Property</interfacename> interface to allow accessing the text
            value, so you can get and set the text with
            <methodname>getValue()</methodname> and <methodname>setValue()</methodname>.
        </para>

		<book-example eid="component.label.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[// Get the label's text to initialize a field
TextField editor = new TextField(null, // No caption
                                 label.getValue());
        
// Change the label's text
editor.addValueChangeListener(event -> // Java 8
    label.setValue(editor.getValue()));
editor.setImmediate(true); // Send on Enter]]></programlisting>

        <para>
            Label also supports data binding to a property data source, as described later
            in <xref linkend="components.label.databinding"/>. However, in that case the
            value can not be set through the label, as <classname>Label</classname> is not
            a <interfacename>Property.Editor</interfacename> and is not allowed to write
            to a bound property.
        </para>

        <para>
            Even though <classname>Label</classname> is text and is often used as a
            caption, it is a normal component and therefore also has a caption that you
            can set with <methodname>setCaption()</methodname>. As with most other
            components, the caption is managed by the containing layout.
        </para>

        <section xml:id="components.label.wrap">
            <title>Text Width and Wrapping</title>

            <para>
                <classname>Label</classname> has 100% default width, so the containing
                layout must also have a defined width. If the width of the label's text
                exceeds the width of the label, the text will wrap around and continue on
                the next line. Some layout components have undefined width by default,
                such as <classname>HorizontalLayout</classname>, so you need to pay
                special care with them.
            </para>

            <book-example eid="component.label.wrap" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// A container with a defined width.
Panel panel = new Panel("Panel Containing a Label");
panel.setWidth("300px");

panel.setContent(
    new Label("This is a Label inside a Panel. There is " +
              "enough text in the label to make the text " +
              "wrap when it exceeds the width of the panel."));]]></programlisting>

            <para>
                As the size of the <classname>Panel</classname> in the above example is
                fixed and the width of <classname>Label</classname> is the default 100%,
                the text in the <classname>Label</classname> will wrap to fit the panel,
                as shown in <xref linkend="figure.components.label"/>.
            </para>

            <figure xml:id="figure.components.label">
                <title>The Label Component</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/label-example1.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="80" smallscale="60%" align="center" fileref="img/components/label-example1.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Setting <classname>Label</classname> to undefined width will cause it to not
                wrap at the end of the line, as the width of the content defines the width. If
                placed inside a layout with defined width, the <classname>Label</classname>
                will overflow the layout horizontally and, normally, be truncated.
            </para>
        </section>

        <section xml:id="components.label.content-mode">
            <title>Content Mode</title>

            <para>
                The content of a label is formatted depending on a <emphasis>content
                mode</emphasis>. By default, the text is assumed to be plain text and any
                contained XML-specific characters will be quoted appropriately to allow
                rendering the contents of a label in HTML in a web browser. The content
                mode can be set in the constructor or with
                <methodname>setContentMode()</methodname>, and can have the values defined
                in the <classname>ContentMode</classname> enumeration type in
                <package>com.vaadin.shared.ui.label</package> package:
            </para>

            <variablelist>
                <varlistentry>
                    <term><constant>TEXT</constant></term>
                    <listitem>
                        <para>
                            The default content mode where the label contains only plain
                            text. All characters are allowed, including the special
                            <literal>&lt;</literal>, <literal>&gt;</literal>, and
                            <literal>&amp;</literal> characters in XML or HTML, which are
                            quoted properly in HTML while rendering the component. This
                            is the default mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
				<term><constant>PREFORMATTED</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains preformatted text. It will
                            be, by default, rendered with a fixed-width typewriter
                            font. Preformatted text can contain line breaks, written in Java
                            with the <literal>\n</literal> escape sequence for a newline
                            character (ASCII 0x0a), or tabulator characters written with
                            <literal>\t</literal> (ASCII 0x09).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>HTML</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains HTML.
                        </para>

                        <para>
                            Please note the following security and validity warnings
                            regarding the HTML content mode.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <warning>
                <title>Cross-Site Scripting Warning</title>

                <para>
                    Having <classname>Label</classname> in <constant>HTML</constant>
                    content mode allows pure HTML content. If the content comes from user
                    input, you should always carefully sanitize it to prevent cross-site
                    scripting (XSS) attacks. Please see <xref
                    linkend="advanced.security.sanitizing"/>.
                </para>

                <para>
                    Also, the validity of the HTML content is not checked when rendering
                    the component and any errors can result in an error in the browser. If
                    the content comes from an uncertain source, you should always validate
                    it before displaying it in the component.
                </para>
            </warning>

            <para>
                The following example demonstrates the use of
                <classname>Label</classname> in different modes.
            </para>

            <book-example eid="component.label.content-modes.contentmodes" style="float: right"></book-example>
			<programlisting><?pocket-size 70% ?><![CDATA[Label textLabel = new Label(
    "Text where formatting characters, such as \\n, " +
    "and HTML, such as <b>here</b>, are quoted.",
    ContentMode.TEXT);

Label preLabel = new Label(
    "Preformatted text is shown in an HTML <pre> tag.\n" +
    "Formatting such as\n" +
    "  * newlines\n" + 
    "  * whitespace\n" +
    "and such are preserved. HTML tags, \n"+
    "such as <b>bold</b>, are quoted.",
    ContentMode.PREFORMATTED);

Label htmlLabel = new Label(
    "In HTML mode, all HTML formatting tags, such as \n" +
    "<ul>"+
    "  <li><b>bold</b></li>"+
    "  <li>itemized lists</li>"+
    "  <li>etc.</li>"+
    "</ul> "+
    "are preserved.",
    ContentMode.HTML);]]></programlisting>

            <para>
                The rendering will look as shown in <xref linkend="figure.components.label.content-mode"/>.
            </para>

            <figure xml:id="figure.components.label.content-mode">
                <title>Label Content Modes</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/label-modes.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="60" smallscale="100%" align="center" fileref="img/components/label-modes.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <!-- TODO Fix and re-enable 
        <section xml:id="components.label.html-mode">
            <title>Making Use of the HTML Mode</title>

            <para>
                Using the HTML modes allows inclusion of, for example, images within the
                text flow, which is not possible with any regular layout components. The
                following example includes an image loaded from a theme within the text
                flow.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[ClassResource labelimage = new ClassResource ("labelimage.jpg");
main.addComponent(new Label("Here we have an image <img src=\"" +
                            this.getRelativeLocation(labelimage) +
                            "\"/> within text.",
                            ContentMode.HTML));]]></programlisting>

            <para>
                When you use a class loader resource, the image has to be included in
                the JAR of the web application. In this case, the
                <filename>labelimage.jpg</filename> needs to be in the default
                package. When rendered in a web browser, the output will look as
                follows:
            </para>

            <figure>
                <title>Referencing An Image Resource in Label</title>
                <mediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="img/components/label-withimage.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            
            <para>
                Another solution would be to use the
                <classname>CustomLayout</classname> component, where you can write
                the component content as an HTML fragment in a theme, but such a
                solution may be too heavy for most cases.
            </para>
        </section> -->

        <section xml:id="components.label.spacing" condition="web">
            <title>Spacing with a <classname>Label</classname></title>
                
            <para>
                You can use a <classname>Label</classname> to create vertical or
                horizontal space in a layout. If you need a empty "line" in a vertical
                layout, having just a label with empty text is not enough, as it will
                collapse to zero height. The same goes for a label with only whitespace as
                the label text. You need to use a non-breaking space character, either
                <literal>&amp;nbsp;</literal> or <literal>&amp;#160;</literal>:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[layout.addComponent(new Label("&nbsp;", ContentMode.HTML));]]></programlisting>

            <para>
                Using the <parameter>ContentMode.PREFORMATTED</parameter> mode has the
                same effect; preformatted spaces do not collapse in a vertical layout. In
                a <classname>HorizontalLayout</classname>, the width of a space character
                may be unpredictable if the label font is proportional, so you can use the
                preformatted mode to add em-width wide spaces.
            </para>

            <para>
                If you want a gap that has adjustable width or height, you can use an
                empty label if you specify a height or width for it. For example, to
                create vertical space in a <classname>VerticalLayout</classname>:
            </para>

            <programlisting><![CDATA[Label gap = new Label();
gap.setHeight("1em");
verticalLayout.addComponent(gap);]]></programlisting>

            <para>
                You can make a flexible expanding spacer by having a relatively sized
                empty label with <literal>100%</literal> height or width and setting the
                label as expanding in the layout.
            </para>

            <programlisting><![CDATA[// A wide component bar
HorizontalLayout horizontal = new HorizontalLayout();
horizontal.setWidth("100%");

// Have a component before the gap (a collapsing cell)
Button button1 = new Button("I'm on the left");
horizontal.addComponent(button1);

// An expanding gap spacer
Label expandingGap = new Label();
expandingGap.setWidth("100%");
horizontal.addComponent(expandingGap);
horizontal.setExpandRatio(expandingGap, 1.0f);

// A component after the gap (a collapsing cell)
Button button2 = new Button("I'm on the right");
horizontal.addComponent(button2);]]></programlisting>
        </section>

		<section xml:id="components.label.databinding">
			<title>Data Binding</title>

            <para>
                While <classname>Label</classname> is not a field component, it is a
                <interfacename>Property.Viewer</interfacename> and can be bound to a
                property data source, described in <xref
                linkend="datamodel.properties"/>. You can specify the data source either
                in the constructor or by the
                <methodname>setPropertyDataSource()</methodname> method.
            </para>

            <book-example eid="component.label.binding" style="float: right"></book-example>
            <programlisting><![CDATA[// Some property
ObjectProperty<String> property =
    new ObjectProperty<String>("some value");
        
// Label that is bound to the property
Label label = new Label(property);]]></programlisting>

            <para>
                Further, as <classname>Label</classname> is a
                <interfacename>Property</interfacename>, you can edit its value with a
                property editor, such as a field:
            </para>

            <book-example eid="component.label.delegation" style="float: right"></book-example>
            <programlisting><![CDATA[Label label = new Label("some value");
TextField editor = new TextField();
editor.setPropertyDataSource(label);
editor.setImmediate(true);]]></programlisting>

            <para>
                However, <classname>Label</classname> is <emphasis>not</emphasis> a
                <interfacename>Property.Editor</interfacename>, so it is read-only when
                bound to a data source. Therefore, you can not use
                <methodname>setValue()</methodname> to set the value of a connected data
                source through a <classname>Label</classname> nor bind the label to an
                editor field, in which case writes would be delegated through the label.
            </para>
        </section>

		<section xml:id="components.label.css">
			<title>CSS Style Rules</title>

			<programlisting><?dbfo-need height="3cm" ?><![CDATA[.v-label { }
  pre { } /* In PREFORMATTED content mode */]]></programlisting>

            <para>
                The <classname>Label</classname> component has a
                <literal>v-label</literal> overall style. In the
                <parameter>PREFORMATTED</parameter> content mode, the text is wrapped
                inside a <literal>&lt;pre&gt;</literal> element.
            </para>
        </section>
	</section>

	<section xml:id="components.link">
		<title><classname>Link</classname></title>

		<para>
			The <classname>Link</classname> component allows making hyperlinks. References
			to locations are represented as resource objects, explained in <xref
			linkend="application.resources"/>. The <classname>Link</classname> is a
			regular HTML hyperlink, that is, an <literal>&lt;a href&gt;</literal> anchor
			element that is handled natively by the browser. Unlike when clicking a
			<classname>Button</classname>, clicking a <classname>Link</classname> does not
			cause an event on the server-side.
		</para>

		<para>
			Links to an arbitrary URL can be made by using an
			<classname>ExternalResource</classname> as follows:
		</para>

		<book-example eid="component.link.basic" style="float: right"></book-example>
		<programlisting><![CDATA[// Textual link
Link link = new Link("Click Me!",
        new ExternalResource("http://vaadin.com/"));]]></programlisting>

        <para>
            You can use <methodname>setIcon()</methodname> to make image links as follows:
        </para>

		<programlisting><?pocket-size 65% ?><![CDATA[// Image link
Link iconic = new Link(null,
        new ExternalResource("http://vaadin.com/"));
iconic.setIcon(new ThemeResource("img/nicubunu_Chain.png"));

// Image + caption
Link combo = new Link("To appease both literal and visual",
        new ExternalResource("http://vaadin.com/"));
combo.setIcon(new ThemeResource("img/nicubunu_Chain.png"));]]></programlisting>

        <para>
            The resulting links are shown in <xref
            linkend="figure.components.link.basic"/>. You could add a "<literal>display:
            block</literal>" style for the icon element to place the caption below it.
        </para>

		<figure xml:id="figure.components.link.basic">
			<title><classname>Link</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/link.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="80%" align="center" fileref="img/components/link.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            With the simple constructor used in the above example, the resource is opened
            in the current window. Using the constructor that takes the target window as a
            parameter, or by setting the target window with
            <methodname>setTargetName()</methodname>, you can open the resource in another
            window, such as a popup browser window/tab. As the target name is an HTML
            <literal>target</literal> string managed by the browser, the target can be any
            window, including windows not managed by the application itself. You can use
            the special underscored target names, such as <literal>_blank</literal> to
            open the link to a new browser window or tab.
		</para>

		<book-example eid="component.link.target" style="float: right"></book-example>
        <programlisting><?pocket-size 65% ?><![CDATA[// Hyperlink to a given URL
Link link = new Link("Take me a away to a faraway land",
        new ExternalResource("http://vaadin.com/"));

// Open the URL in a new window/tab
link.setTargetName("_blank");
        
// Indicate visually that it opens in a new window/tab
link.setIcon(new ThemeResource("icons/external-link.png"));
link.addStyleName("icon-after-caption");]]></programlisting>

        <para>
            Normally, the link icon is before the caption. You can have it right of the
            caption by reversing the text direction in the containing element.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[/* Position icon right of the link caption. */
.icon-after-caption {
    direction: rtl;
}
/* Add some padding around the icon. */
.icon-after-caption .v-icon {
    padding: 0 3px;
}]]></programlisting>

        <para>
            The resulting link is shown in <xref linkend="figure.components.link.new-window"/>.
        </para>

		<figure xml:id="figure.components.link.new-window">
			<title>Link That Opens a New Window</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata scale="50" align="center" fileref="img/components/link-new.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/link-new.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            With the <literal>_blank</literal> target, a normal new browser window is
            opened. If you wish to open it in a popup window (or tab), you need to give a size for
            the window with <methodname>setTargetWidth()</methodname> and
            <methodname>setTargetHeight()</methodname>. You can control the window border
            style with <methodname>setTargetBorder()</methodname>, which takes any of the
            defined border styles <parameter>TARGET_BORDER_DEFAULT</parameter>,
            <parameter>TARGET_BORDER_MINIMAL</parameter>, and
            <parameter>TARGET_BORDER_NONE</parameter>. The exact result depends on the
            browser.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Open the URL in a popup
link.setTargetName("_blank");
link.setTargetBorder(Link.TARGET_BORDER_NONE);
link.setTargetHeight(300);
link.setTargetWidth(400);]]></programlisting>

        <!-- TODO: Describe _new, _black, etc. targets and give an example. -->

		<para>
            In addition to the <classname>Link</classname> component, Vaadin allows
            alternative ways to make hyperlinks. The <classname>Button</classname>
            component has a <parameter>Reindeer.BUTTON_LINK</parameter> style name that
            makes it look like a hyperlink, while handling clicks in a server-side click
            listener instead of in the browser. Also, you can make hyperlinks (or any
            other HTML) in a <classname>Label</classname> in HTML content mode.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><?dbfo-need height="3cm" ?><![CDATA[.v-link { }
  a { }
    .v-icon {}
    span {}]]></programlisting>

			<para>
                The overall style for the <classname>Link</classname> component is
                <literal>v-link</literal>. The root element contains the <literal>&lt;a
                href&gt;</literal> hyperlink anchor. Inside the anchor are the icon, with
                <literal>v-icon</literal> style, and the caption in a text span.
            </para>

            <para>
                Hyperlink anchors have a number of <emphasis>pseudo-classes</emphasis>
                that are active at different times. An unvisited link has
                <literal>a:link</literal> class and a visited link
                <literal>a:visited</literal>. When the mouse pointer hovers over the link,
                it will have <varname>a:hover</varname>, and when the mouse button is
                being pressed over the link, the <literal>a:active</literal> class. When
                combining the pseudo-classes in a selector, please notice that
                <literal>a:hover</literal> must come after an <literal>a:link</literal>
                and <literal>a:visited</literal>, and <literal>a:active</literal> after
                the <literal>a:hover</literal>.
			</para>
		</simplesect>
	</section>

	<section xml:id="components.textfield">
		<title><classname>TextField</classname></title>

        <indexterm xml:id="term.components.textfield" class="startofrange">
            <primary><classname>TextField</classname></primary>
        </indexterm>

		<para>
			<classname>TextField</classname> is one of the most commonly used user
			interface components. It is a <classname>Field</classname> component that
			allows entering textual values using keyboard.
		</para>

		<para>
			The following example creates a simple text field:
		</para>

        <book-example eid="component.textfield.basic" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create a text field
TextField tf = new TextField("A Field");
        
// Put some initial content in it
tf.setValue("Stuff in the field");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.textfield.basic"/>.
        </para>

		<figure xml:id="figure.components.textfield.basic">
			<title><classname>TextField</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textfield-example.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="60%" align="center" fileref="img/components/textfield-example.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Value changes are handled with a
            <classname>Property.ValueChangeListener</classname>, as in most other
            fields. The value can be acquired with <methodname>getValue()</methodname>
            directly from the text field, as is done in the example below, or from the
            property reference of the event.
        </para>

        <book-example eid="component.textfield.inputhandling" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[// Handle changes in the value
tf.addValueChangeListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Assuming that the value type is a String
        String value = (String) event.getProperty().getValue();

        // Do something with the value
        Notification.show("Value is: " + value);
    }
});

// Fire value changes immediately when the field loses focus
tf.setImmediate(true);]]></programlisting>

        <para>
            As with other event listeners, you can use lambda expression with one
            parameter to handle the events in Java 8.
        </para>

        <para>
            Much of the API of <classname>TextField</classname> is defined in
            <classname>AbstractTextField</classname>, which allows different kinds of text
            input fields, such as rich text editors, which do not share all the features
            of the single-line text fields.
        </para>

		<figure xml:id="figure.components.textfield.api">
			<title>Text Field Class Relationships</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textfield-diagram-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="75%" align="center" fileref="img/components/textfield-diagram-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <section xml:id="components.textfield.databinding">
            <title>Data Binding</title>

            <book-example eid="component.textfield.valuetype" style="float: right"></book-example>
            <para>
                <classname>TextField</classname> edits <classname>String</classname>
                values, but you can bind it to any property type that has a proper
                converter, as described in <xref
                linkend="datamodel.properties.converter"/>.
            </para>

            <book-example eid="component.textfield.databinding" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an initial data model. As Double is unmodificable and
// doesn't support assignment from String, the object is
// reconstructed in the wrapper when the value is changed.
Double trouble = 42.0;
        
// Wrap it in a property data source
final ObjectProperty<Double> property =
    new ObjectProperty<Double>(trouble);
        
// Create a text field bound to it
// (StringToDoubleConverter is used automatically)
TextField tf = new TextField("The Answer", property);
tf.setImmediate(true);

// Show that the value is really written back to the
// data source when edited by user.
Label feedback = new Label(property);
feedback.setCaption("The Value");]]></programlisting>

            <para>
                When you put a <classname>Table</classname> in editable mode or create
                fields with a <classname>FieldGroup</classname>, the
                <classname>DefaultFieldFactory</classname> creates a
                <classname>TextField</classname> for almost every property type by
                default. You often need to make a custom factory to customize the creation
                and to set the field tooltip, validation, formatting, and so on.
            </para>

            <para>
                See <xref linkend="datamodel"/> for more details on data binding, field
                factories for <classname>Table</classname> in <xref
                linkend="components.table.editing"/>, and <xref
                linkend="datamodel.itembinding"/> regarding forms.
            </para>

            <book-example eid="component.textfield.beanbinding">
                Bean Binding
            </book-example>
        </section>

        <section xml:id="components.textfield.length">
            <title>String Length</title>

            <para>
                The <methodname>setMaxLength()</methodname> method sets the maximum length
                of the input string so that the browser prevents the user from entering a
                longer one. As a security feature, the input value is automatically
                truncated on the server-side, as the maximum length setting could be
                bypassed on the client-side. The maximum length property is defined at
                <classname>AbstractTextField</classname> level.
            </para>

            <para>
                Notice that the maximum length setting does not affect the width of the
                field. You can set the width with <methodname>setWidth()</methodname>, as
                with other components. Using <emphasis>em</emphasis> widths is recommended
                to better approximate the proper width in relation to the size of the used
                font. There is no standard way in HTML for setting the width exactly to a
                number of letters (in a monospaced font). You can trick your way around
                this restriction by putting the text field in an undefined-width
                <classname>VerticalLayout</classname> together with an undefined-width
                <classname>Label</classname> that contains a sample text, and setting the
                width of the text field as 100%. The layout will get its width from the
                label, and the text field will use that.
            </para>

            <book-example eid="component.textfield.widthfitting">
                Fitting TextField width to fixed input length
            </book-example>
        </section>

        <section xml:id="components.textfield.nullvalues">
            <title>Handling Null Values</title>

            <indexterm xml:id="term.components.textfield.nullvalues" class="startofrange">
                <primary>Null representation</primary>
            </indexterm>

            <para>
                <indexterm><primary><methodname>setNullRepresentation()</methodname></primary></indexterm>

                As with any field, the value of a <classname>TextField</classname> can be
                set as <parameter>null</parameter>. This occurs most commonly when you
                create a new field without setting a value for it or bind the field value
                to a data source that allows null values. In such case, you might want to
                show a special value that stands for the null value. You can set the null
                representation with the <methodname>setNullRepresentation()</methodname>
                method. Most typically, you use an empty string for the null
                representation, unless you want to differentiate from a string that is
                explicitly empty. The default null representation is
                "<literal>null</literal>", which essentially warns that you may have
                forgotten to initialize your data objects properly.
            </para>

            <para>
                <indexterm><primary><methodname>setNullSettingAllowed()</methodname></primary></indexterm>

                The <methodname>setNullSettingAllowed()</methodname> controls whether the
                user can actually input a null value by using the null value
                representation. If the setting is <literal>false</literal>, which is the
                default, inputting the null value representation string sets the value as
                the literal value of the string, not null. This default assumption is a
                safeguard for data sources that may not allow null values.
            </para>

            <book-example eid="component.textfield.nullvaluerepresentation" style="float: right"></book-example>

<programlisting><?pocket-size 75% ?><![CDATA[// Have a property with null value
ObjectProperty<Double> dataModel =
    new ObjectProperty<Double>(new Double(0.0));
dataModel.setValue(null); // Have to set it null here

// Create a text field bound to the null data
TextField tf = new TextField("Field Energy (J)", dataModel);
tf.setNullRepresentation("-- null-point --");

// Allow user to input the null value by its representation
tf.setNullSettingAllowed(true);]]></programlisting>

            <para>
                The <classname>Label</classname>, which is bound to the value of the
                <classname>TextField</classname>, displays a null value as empty. The
                resulting user interface is shown in <xref
                linkend="figure.components.textfield.nullvalues"/>.
            </para>

            <figure xml:id="figure.components.textfield.nullvalues">
                <title>Null Value Representation</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-nullrepresentation.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="45%" align="center" fileref="img/components/textfield-nullrepresentation.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <indexterm startref="term.components.textfield.nullvalues" class="endofrange"/>
        </section>

        <!--section>
            <title>Formatting Text Field Values</title>

            <para>
        TODO
            </para>
        </section -->

        <section xml:id="components.textfield.textchangeevents">
            <title>Text Change Events</title>

            <indexterm xml:id="term.components.textfield.textchangeevents" class="startofrange">
                <primary><classname>Text change events</classname></primary>
            </indexterm>

            <para>
                Often you want to receive a change event immediately when the text field
                value changes. The <emphasis>immediate</emphasis> mode is not literally
                immediate, as the changes are transmitted only after the field loses
                focus. In the other extreme, using keyboard events for every keypress
                would make typing unbearably slow and also processing the keypresses is
                too complicated for most purposes. <emphasis>Text change events</emphasis>
                are transmitted asynchronously soon after typing and do not block typing
                while an event is being processed.
            </para>

            <para>
                <indexterm><classname>TextChangeListener</classname></indexterm>

                Text change events are received with a
                <classname>TextChangeListener</classname>, as is done in the following
                example that demonstrates how to create a text length counter:
            </para>

            <book-example eid="component.textfield.textchangeevents.counter" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// Text field with maximum length
final TextField tf = new TextField("My Eventful Field");
tf.setValue("Initial content");
tf.setMaxLength(20);

// Counter for input length
final Label counter = new Label();
counter.setValue(tf.getValue().length() +
                 " of " + tf.getMaxLength());

// Display the current length interactively in the counter
tf.addTextChangeListener(new TextChangeListener() {
    public void textChange(TextChangeEvent event) {
        int len = event.getText().length();
        counter.setValue(len + " of " + tf.getMaxLength());
    }
});

// The lazy mode is actually the default
tf.setTextChangeEventMode(TextChangeEventMode.LAZY);]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textfield.textchangeevents"/>.
            </para>

            <figure xml:id="figure.components.textfield.textchangeevents">
                <title>Text Change Events</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-textchangeevents.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="65%" align="center" fileref="img/components/textfield-textchangeevents.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The <emphasis>text change event mode</emphasis> defines how quickly the
                changes are transmitted to the server and cause a server-side
                event. Lazier change events allow sending larger changes in one event if
                the user is typing fast, thereby reducing server requests.
            </para>

            <para>
                <indexterm><classname>TextChangeEventMode</classname></indexterm>

                You can set the text change event mode of a
                <classname>TextField</classname> with
                <methodname>setTextChangeEventMode()</methodname>. The allowed modes are
                defined in <classname>TextChangeEventMode</classname> enum and are as
                follows:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.LAZY</parameter> (default)</term>
                    <listitem>
                        <para>
                            An event is triggered when there is a pause in editing the
                            text. The length of the pause can be modified with
                            <methodname>setInputEventTimeout()</methodname>. As with the
                            <parameter>TIMEOUT</parameter> mode, a text change event is
                            forced before a possible
                            <classname>ValueChangeEvent</classname>, even if the user did
                            not keep a pause while entering the text.
                        </para>

                        <para>
                            This is the default mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.TIMEOUT</parameter></term>
                    <listitem>
                        <para>
                            A text change in the user interface causes the event to be
                            communicated to the application after a timeout period. If
                            more changes are made during this period, the event sent to
                            the server-side includes the changes made up to the last
                            change. The length of the timeout can be set with
                            <methodname>setInputEventTimeout()</methodname>.
                        </para>

                        <para>
                            If a <classname>ValueChangeEvent</classname> would occur
                            before the timeout period, a
                            <classname>TextChangeEvent</classname> is triggered before it,
                            on the condition that the text content has changed since the
                            previous <classname>TextChangeEvent</classname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.EAGER</parameter></term>
                    <listitem>
                        <para>
                            An event is triggered immediately for every change in the text
                            content, typically caused by a key press. The requests are
                            separate and are processed sequentially one after
                            another. Change events are nevertheless communicated
                            asynchronously to the server, so further input can be typed
                            while event requests are being processed.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <indexterm startref="term.components.textfield.textchangeevents" class="endofrange"/>
        </section>

        <section xml:id="components.textfield.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textfield { }]]></programlisting>

            <para>
                The HTML structure of <classname>TextField</classname> is extremely simple,
                consisting only of an element with the <literal>v-textfield</literal> style.
            </para>

            <para>
                For example, the following custom style uses dashed border:
            </para>

            <book-example eid="component.textfield.css" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[.v-textfield-dashing {
    border:     thin dashed;
    background: white; /* Has shading image by default */
}]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textfield.css"/>.
            </para>

            <figure xml:id="figure.components.textfield.css">
                <title>Styling TextField with CSS</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-css.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/textfield-css.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The style name for <classname>TextField</classname> is also used in
                several components that contain a text input field, even if the text input
                is not an actual <classname>TextField</classname>. This ensures that the
                style of different text input boxes is similar.
            </para>
        </section>

        <indexterm startref="term.components.textfield" class="endofrange"/>
	</section>

	<section xml:id="components.textarea">
		<title><classname>TextArea</classname></title>

		<para>
			<classname>TextArea</classname> is a multi-line version of the
			<classname>TextField</classname> component described in <xref
			linkend="components.textfield"/>.
		</para>

		<para>
			The following example creates a simple text area:
		</para>

        <book-example eid="component.textarea.basic" style="float: right"></book-example>

<programlisting><?pocket-size 65% ?><![CDATA[// Create the area
TextArea area = new TextArea("Big Area");
        
// Put some content in it
area.setValue("A row\n"+
              "Another row\n"+
              "Yet another row");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.textarea"/>.
        </para>

		<figure xml:id="figure.components.textarea">
			<title><classname>TextArea</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textarea-basic.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="50%" align="center" fileref="img/components/textarea-basic.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            You can set the number of visible rows with <methodname>setRows()</methodname>
            or use the regular <methodname>setHeight()</methodname> to define the height
            in other units. If the actual number of rows exceeds the number, a vertical
            scrollbar will appear. Setting the height with
            <methodname>setRows()</methodname> leaves space for a horizontal scrollbar, so
            the actual number of visible rows may be one higher if the scrollbar is not
            visible.
        </para>

        <para>
            You can set the width with the regular <methodname>setWidth()</methodname>
            method. Setting the size with the <emphasis>em</emphasis> unit, which is
            relative to the used font size, is recommended.
        </para>

        <simplesect xml:id="components.textarea.wordwrap">
            <title>Word Wrap</title>

            <para>
                The <methodname>setWordwrap()</methodname> sets whether long lines are
                wrapped (<literal>true</literal> - default) when the line length reaches
                the width of the writing area. If the word wrap is disabled
                (<literal>false</literal>), a vertical scrollbar will appear instead. The
                word wrap is only a visual feature and wrapping a long line does not
                insert line break characters in the field value; shortening a wrapped line
                will undo the wrapping.
            </para>
            
            <book-example eid="component.textarea.wordwrap" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[TextArea area1 = new TextArea("Wrapping");
area1.setWordwrap(true); // The default
area1.setValue("A quick brown fox jumps over the lazy dog");

TextArea area2 = new TextArea("Nonwrapping");
area2.setWordwrap(false);
area2.setValue("Victor jagt zw&ouml;lf Boxk&auml;mpfer quer "+
               "&uuml;ber den Sylter Deich");]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textarea.wordwrap"/>.
            </para>

            <figure xml:id="figure.components.textarea.wordwrap">
                <title>Word Wrap in <classname>TextArea</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textarea-wordwrap.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/textarea-wordwrap.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

        <simplesect xml:id="components.textarea.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textarea { }]]></programlisting>

            <para>
                The HTML structure of <classname>TextArea</classname> is extremely simple,
                consisting only of an element with <literal>v-textarea</literal> style.
            </para>

            <book-example eid="component.textarea.css">CSS Styling</book-example>
        </simplesect>
	</section>

	<section xml:id="components.passwordfield">
		<title><classname>PasswordField</classname></title>

        <para>
            The <classname>PasswordField</classname> is a variant of
            <classname>TextField</classname> that hides the typed input from visual
            inspection.
        </para>

        <book-example eid="component.passwordfield.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 65% ?><![CDATA[PasswordField tf = new PasswordField("Keep it secret");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.passwordfield.basic"/>.
        </para>

        <figure xml:id="figure.components.passwordfield.basic">
            <title><classname>PasswordField</classname></title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/passwordfield-basic.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata smallscale="50%" align="center" fileref="img/components/passwordfield-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            You should note that the <classname>PasswordField</classname> hides the input
            only from "over the shoulder" visual observation. Unless the server connection
            is encrypted with a secure connection, such as HTTPS, the input is transmitted
            in clear text and may be intercepted by anyone with low-level access to the
            network. Also phishing attacks that intercept the input in the browser may be
            possible by exploiting JavaScript execution security holes in the browser.
        </para>

        <simplesect xml:id="components.passwordfield.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textfield { }]]></programlisting>

            <para>
                The <classname>PasswordField</classname> does not have its own CSS style
                name but uses the same <literal>v-textfield</literal> style as the regular
                <classname>TextField</classname>. See <xref
                linkend="components.textfield.css"/> for information on styling it.
            </para>

            <book-example eid="component.passwordfield.css">CSS Styling</book-example>
        </simplesect>
    </section>

	<section xml:id="components.richtextarea">
		<title><classname>RichTextArea</classname></title>

		<para>
			The <classname>RichTextArea</classname> field allows entering or editing
			formatted text. The toolbar provides all basic editing functionalities. The
			text content of <classname>RichTextArea</classname> is represented in HTML
			format. <classname>RichTextArea</classname> inherits
			<classname>TextField</classname> and does not add any API functionality over
			it. You can add new functionality by extending the client-side components
			<classname>VRichTextArea</classname> and
			<classname>VRichTextToolbar</classname>.
		</para>

		<para>
			As with <classname>TextField</classname>, the textual content of the rich text
			area is the <classname>Property</classname> of the field and can be set with
			<methodname>setValue()</methodname> and read with
			<methodname>getValue()</methodname>.
		</para>

		<programlisting><![CDATA[// Create a rich text area
final RichTextArea rtarea = new RichTextArea();
rtarea.setCaption("My Rich Text Area");

// Set initial content as HTML
rtarea.setValue("<h1>Hello</h1>\n" +
    "<p>This rich text area contains some text.</p>");]]></programlisting>
			
		<figure>
			<title>Rich Text Area Component</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/richtextarea-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/richtextarea-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Above, we used context-specific tags such as <literal>&lt;h1&gt;</literal> in
			the initial HTML content. The rich text area component does not allow creating
			such tags, only formatting tags, but it does preserve them unless the user
			edits them away. Any non-visible whitespace such as the new line character
			(<literal>\n</literal>) are removed from the content. For example, the value
			set above will be as follows when read from the field with
			<methodname>getValue()</methodname>:
		</para>
		
		<programlisting><![CDATA[<h1>Hello</h1> <p>This rich text area contains some text.</p>]]></programlisting>

		<warning>
			<title>Cross-Site Scripting Warning</title>

			<para>
				The user input from a <classname>RichTextArea</classname> is transmitted
				as HTML from the browser to server-side and is not sanitized. As the
				entire purpose of the <classname>RichTextArea</classname> component is to
				allow input of formatted text, you can not sanitize it just by removing
				all HTML tags. Also many attributes, such as <parameter>style</parameter>,
				should pass through the sanitization.
			</para>

			<para>
				See <xref linkend="advanced.security.sanitizing"/> for more details on
				Cross-Site scripting vulnerabilities and sanitization of user input.
			</para>
        </warning>

        <simplesect xml:id="components.richtextarea.localization" condition="web">
            <title>Localizing RichTextArea Toolbars</title>

            <para>
                The rich text area is one of the few components in Vaadin that contain
                textual labels. The selection boxes in the toolbar are in English and
                currently can not be localized in any other way than by inheriting or
                reimplementing the client-side <classname>VRichTextToolbar</classname>
                widget. The buttons can be localized simply with CSS by downloading a copy
                of the toolbar background image, editing it, and replacing the default
                toolbar. The toolbar is a single image file from which the individual
                button icons are picked, so the order of the icons is different from the
                rendered. The image file depends on the client-side implementation of the
                toolbar.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[
.v-richtextarea-richtextexample .gwt-ToggleButton
.gwt-Image {
  background-image: url(img/richtextarea-toolbar-fi.png)
                    !important;
}]]></programlisting>

            <figure>
                <title>Regular English and a Localized Rich Text Area Toolbar</title>
                <mediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="img/components/richtextarea-toolbar-whitebg.png"/>
                    </imageobject>
                </mediaobject>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/components/richtextarea-toolbar-mod-whitebg.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-richtextarea { }
.v-richtextarea .gwt-RichTextToolbar { }
.v-richtextarea .gwt-RichTextArea { }]]></programlisting>

			<para>
				The rich text area consists of two main parts: the toolbar with overall
				style <literal>.gwt-RichTextToolbar</literal> and the editor area with
				style <literal>.gwt-RichTextArea</literal>. The editor area obviously
				contains all the elements and their styles that the HTML content
				contains. The toolbar contains buttons and drop-down list boxes with the
				following respective style names:
			</para>

			<programlisting><![CDATA[.gwt-ToggleButton { }
.gwt-ListBox { }]]></programlisting>

		</simplesect>
	</section>

	<section xml:id="components.datefield">
		<title>Date and Time Input with <classname>DateField</classname></title>
		<para>
			The <classname>DateField</classname> component provides the means to display
			and input date and time. The field comes in two variations:
			<classname>PopupDateField</classname>, with a numeric input box and a popup
			calendar view, and <classname>InlineDateField</classname>, with the calendar
			view always visible. The <classname>DateField</classname> base class defaults
			to the popup variation.
		</para>

        <para>
            The example below illustrates the use of the <classname>DateField</classname>
            baseclass, which is equivalent to the
            <classname>PopupDateField</classname>. We set the initial time of the date
            field to current time by using the default constructor of the
            <classname>java.util.Date</classname> class.
        </para>

        <programlisting><![CDATA[// Create a DateField with the default style
DateField date = new DateField();
	
// Set the date and time to present
date.setValue(new Date());]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.datefield.basic"/>.
        </para>

		<figure xml:id="figure.components.datefield.basic">
			<title><classname>DateField</classname> (<classname>PopupDateField</classname>) for Selecting Date and Time</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/datefield-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="75%" align="center" fileref="img/components/datefield-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <section xml:id="components.datefield.popupdatefield">
            <title><classname>PopupDateField</classname></title>

            <para>
                The <classname>PopupDateField</classname> provides date input using a text
                box for the date and time. As the <classname>DateField</classname>
                defaults to this component, the use is exactly the same as described
                earlier. Clicking the handle right of the date opens a popup view for
                selecting the year, month, and day, as well as time. Also the
                <keycap>Down</keycap> key opens the popup. Once opened, the user can
                navigate the calendar using the cursor keys.
            </para>

            <para>
                The date and time selected from the popup are displayed in the text box
                according to the default date and time format of the current locale, or as
                specified with <methodname>setDateFormat()</methodname>. The same format
                definitions are used for parsing user input.
            </para>

            <simplesect xml:id="components.datefield.popupdatefield.format">
                <title>Date and Time Format</title>

                <para>
                    The date and time are normally displayed according to the default
                    format for the current locale (see <xref
                    linkend="components.features.locale"/>). You can specify a custom
                    format with <methodname>setDateFormat()</methodname>. It takes a
                    format string that follows the format of the
                    <classname>SimpleDateFormat</classname> in Java.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[// Display only year, month, and day in ISO format
date.setDateFormat("yyyy-MM-dd");]]></programlisting>

                <para>
                    The result is shown in <xref
                    linkend="figure.components.datefield.popupdatefield.format"/>.
                </para>

                <figure xml:id="figure.components.datefield.popupdatefield.format">
                    <title>Custom Date Format for <classname>PopupDateField</classname></title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/datefield-formatting.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata smallscale="50%" align="center" fileref="img/components/datefield-formatting.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    The same format specification is also used for parsing user-input date
                    and time, as described later. 
                </para>
            </simplesect>

            <simplesect xml:id="components.datefield.popupdatefield.malformed" condition="web">
                <title>Handling Malformed User Input</title>

                <para>
                    A user can easily input a malformed or otherwise invalid date or
                    time. <classname>DateField</classname> has two validation layers:
                    first on the client-side and then on the server-side.
                </para>

                <para>
                    The validity of the entered date is first validated on the
                    client-side, immediately when the input box loses focus. If the date
                    format is invalid, the <literal>v-datefield-parseerror</literal> style
                    is set. Whether this causes a visible indication of a problem depends
                    on the theme. The built-in <literal>reindeer</literal> theme does not
                    shown any indication by default, making server-side handling of the
                    problem more convenient.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.mydate.v-datefield-parseerror .v-textfield {
    background: pink;
}]]></programlisting>

                <para>
                    The <methodname>setLenient(true)</methodname> setting enables relaxed
                    interpretation of dates, so that invalid dates, such as February 30th
                    or March 0th, are wrapped to the next or previous month, for example.
                </para>

                <para>
                    The server-side validation phase occurs when the date value is sent to
                    the server. If the date field is set in immediate state, it occurs
                    immediately after the field loses focus. Once this is done and if the
                    status is still invalid, an error indicator is displayed beside the
                    component. Hovering the mouse pointer over the indicator shows the
                    error message.
                </para>

                <para>
                    You can handle the errors by overriding the
                    <methodname>handleUnparsableDateString()</methodname> method. The
                    method gets the user input as a string parameter and can provide a
                    custom parsing mechanism, as shown in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a date field with a custom parsing and a
// custom error message for invalid format
PopupDateField date = new PopupDateField("My Date") {
    @Override
    protected Date handleUnparsableDateString(String dateString)
    throws Property.ConversionException {
        // Try custom parsing
        String fields[] = dateString.split("/");
        if (fields.length >= 3) {
            try {
                int year  = Integer.parseInt(fields[0]);
                int month = Integer.parseInt(fields[1])-1;
                int day   = Integer.parseInt(fields[2]);
                GregorianCalendar c =
                    new GregorianCalendar(year, month, day);
                return c.getTime();
            } catch (NumberFormatException e) {
                throw new Property.
                    ConversionException("Not a number");
            }
        }
        
        // Bad date
        throw new Property.
            ConversionException("Your date needs two slashes");
    }
};
        
// Display only year, month, and day in slash-delimited format
date.setDateFormat("yyyy/MM/dd");

// Don't be too tight about the validity of dates
// on the client-side
date.setLenient(true);]]></programlisting>

                <para>
                    The handler method must either return a parsed
                    <classname>Date</classname> object or throw a
                    <classname>ConversionException</classname>. Returning
                    <parameter>null</parameter> will set the field value to
                    <parameter>null</parameter> and clear the input box.
                </para>
            </simplesect>

            <simplesect xml:id="components.datefield.popupdatefield.error-customization" condition="web">
                <title>Customizing the Error Message</title>

                <para>
                    In addition to customized parsing, overriding the handler method for
                    unparseable input is useful for internationalization and other
                    customization of the error message. You can also use it for another
                    way for reporting the errors, as is done in the example below:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a date field with a custom error message for invalid format
PopupDateField date = new PopupDateField("My Date") {
    @Override
    protected Date handleUnparsableDateString(String dateString)
    throws Property.ConversionException {
        // Have a notification for the error
        Notification.show(
                "Your date needs two slashes",
                Notification.TYPE_WARNING_MESSAGE);
        
        // A failure must always also throw an exception
        throw new Property.ConversionException("Bad date");
    }
};]]></programlisting>

                <para>
                    If the input is invalid, you should always throw the exception;
                    returning a <parameter>null</parameter> value would make the input
                    field empty, which is probably undesired.
                </para>
            </simplesect>

            <simplesect xml:id="components.datefield.popupdatefield.prompt">
                <title>Input Prompt</title>

                <para>
                    Like other fields that have a text box,
                    <classname>PopupDateField</classname> allows an input prompt that is
                    visible until the user has input a value. You can set the prompt with
                    <methodname>setInputPrompt</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[PopupDateField date = new PopupDateField();

// Set the prompt
date.setInputPrompt("Select a date");
        
// Set width explicitly to accommodate the prompt
date.setWidth("10em");]]></programlisting>

                <para>
                    The date field doesn't automatically scale to accommodate the prompt,
                    so you need to set it explicitly with
                    <methodname>setWidth()</methodname>.
                </para>

                <para>
                    The input prompt is not available in the
                    <classname>DateField</classname> superclass.
                </para>
            </simplesect>

            <simplesect xml:id="components.datefield.popupdatefield.css">
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-datefield, v-datefield-popupcalendar {}
  .v-textfield, v-datefield-textfield {}
  .v-datefield-button {}]]></programlisting>

                <para>
                    The top-level element of <classname>DateField</classname> and all its
                    variants have <literal>v-datefield</literal> style. The base class and
                    the <classname>PopupDateField</classname> also have the
                    <literal>v-datefield-popupcalendar</literal> style.
                </para>
                
                <para>
                    In addition, the top-level element has a style that indicates the
                    resolution, with <literal>v-datefield-</literal> basename and an
                    extension, which is one of <literal>full</literal>,
                    <literal>day</literal>, <literal>month</literal>, or
                    <literal>year</literal>. The <literal>-full</literal> style is enabled
                    when the resolution is smaller than a day. These styles are used
                    mainly for controlling the appearance of the popup calendar.
                </para>

                <para>
                    The text box has <literal>v-textfield</literal> and
                    <literal>v-datefield-textfield</literal> styles, and the calendar
                    button <literal>v-datefield-button</literal>.
                </para>

                <para>
                    Once opened, the calendar popup has the following styles at the top
                    level:
                </para>

                <programlisting><![CDATA[.v-datefield-popup {}
  .v-popupcontent {}
    .v-datefield-calendarpanel {}]]></programlisting>

                <para>
                    The top-level element of the floating popup calendar has
                    <literal>.v-datefield-popup</literal> style. Observe that the popup
                    frame is outside the HTML structure of the component, hence it is not
                    enclosed in the <literal>v-datefield</literal> element and does not
                    include any custom styles.

                    <!-- NOTE: May be changed in #5752. -->

                    The content in the <literal>v-datefield-calendarpanel</literal> is the
                    same as in <classname>InlineDateField</classname>, as described in
                    <xref linkend="components.datefield.calendar"/>.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.datefield.calendar">
			<title><classname>InlineDateField</classname></title>

			<para>
				The <classname>InlineDateField</classname> provides a date picker
				component with a month view. The user can navigate months and years by
				clicking the appropriate arrows. Unlike with the popup variant, the month
				view is always visible in the inline field.
			</para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Create a DateField with the default style
InlineDateField date = new InlineDateField();
    
// Set the date and time to present
date.setValue(new java.util.Date());]]></programlisting>

            <para>
                The result is shown in <xref
                linkend="figure.components.datefield.inlinedatefield"/>.
            </para>

            <figure xml:id="figure.components.datefield.inlinedatefield">
                <title>Example of the <classname>InlineDateField</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/datefield-inlinedatefield.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="65%" align="center" fileref="img/components/datefield-inlinedatefield.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The user can also navigate the calendar using the cursor keys.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-datefield {}
  .v-datefield-calendarpanel {}
    .v-datefield-calendarpanel-header {}
      .v-datefield-calendarpanel-prevyear {}
      .v-datefield-calendarpanel-prevmonth {}
      .v-datefield-calendarpanel-month {}
      .v-datefield-calendarpanel-nextmonth {}
      .v-datefield-calendarpanel-nextyear {}
    .v-datefield-calendarpanel-body {}
      .v-datefield-calendarpanel-weekdays,
      .v-datefield-calendarpanel-weeknumbers {}
        .v-first {}
        .v-last {}
      .v-datefield-calendarpanel-weeknumber {}
      .v-datefield-calendarpanel-day {}
    .v-datefield-calendarpanel-time {}
      .v-datefield-time {}
        .v-select {}
        .v-label {}]]></programlisting>

                <para>
                    The top-level element has the <literal>v-datefield</literal> style. In
                    addition, the top-level element has a style name that indicates the
                    resolution of the calendar, with <literal>v-datefield-</literal>
                    basename and an extension, which is one of <literal>full</literal>,
                    <literal>day</literal>, <literal>month</literal>, or
                    <literal>year</literal>. The <literal>-full</literal> style is enabled
                    when the resolution is smaller than a day.
                </para>

                <para>
                    The <literal>v-datefield-calendarpanel-weeknumbers</literal> and
                    <literal>v-datefield-calendarpanel-weeknumber</literal> styles are
                    enabled when the week numbers are enabled. The former controls the
                    appearance of the weekday header and the latter the actual week
                    numbers.
                </para>

                <para>
                    The other style names should be self-explanatory. For weekdays, the
                    <literal>v-first</literal> and <literal>v-last</literal> styles allow
                    making rounded endings for the weekday bar.
                </para>
            </simplesect>
		</section>

		<section xml:id="components.datefield.resolution">
            <title>Date and Time Resolution</title>

            <para>
                In addition to display a calendar with dates,
                <classname>DateField</classname> can also display the time in hours and
                minutes, or just the month or year. The visibility of the input components
                is controlled by <emphasis>time resolution</emphasis>, which you can set
                with <methodname>setResolution()</methodname>. The method takes as its
                parameters the lowest visible component,
                <parameter>DateField.Resolution.DAY</parameter> for just dates and
                <parameter>DateField.Resolution.MIN</parameter> for dates with time in
                hours and minutes. Please see the API Reference for the complete list of
                resolution parameters.
            </para>
        </section>

		<section xml:id="components.datefield.locale">
			<title>DateField Locale</title>

			<para>
				The date and time are displayed according to the locale of the user, as
				reported by the browser. You can set a custom locale with the
				<methodname>setLocale()</methodname> method of
				<classname>AbstractComponent</classname>, as described in <xref
				linkend="components.features.locale"/>. Only Gregorian calendar is
				supported.
			</para>
		</section>
	</section>

	<section xml:id="components.button">
		<title><classname>Button</classname></title>

		<para>
			The <classname>Button</classname> component is normally used for initiating
			some action, such as finalizing input in forms. When the user clicks a button,
			a <classname>Button.ClickEvent</classname> is fired, which can be handled with
			a <interfacename>Button.ClickListener</interfacename> in the
			<methodname>buttonClick()</methodname> method.
		</para>

        <para>
            You can handle button clicks with an anonymous class as follows:
        </para>

        <book-example eid="component.button.basic" style="float: right"></book-example>
		<programlisting><?pocket-size 65% ?><![CDATA[Button button = new Button("Do not press this button");

button.addClickListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        Notification.show("Do not press this button again");
    }
});]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.component.button.basic"/>. The
            listener can also be given in the constructor, which is often perhaps simpler.
        </para>

		<figure xml:id="figure.component.button.basic">
			<title>An Example of a Button</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="60%" align="center" fileref="img/components/button-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            If you handle several buttons in the same listener, you can differentiate
            between them either by comparing the <classname>Button</classname> object
            reference returned by the <methodname>getButton()</methodname> method of
            <classname>Button.ClickEvent</classname> to a kept reference. For a detailed
            description of these patterns together with some examples, please see <xref
            linkend="architecture.events"/>.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-button { }
  .v-button-wrap { }
    .v-button-caption { }]]></programlisting>

			<para>
                A button has an overall <literal>v-button</literal> style. The caption has
                <literal>v-button-caption</literal> style. There is also an intermediate
                wrap element, which may help in styling in some cases.
			</para>

            <para>
                Some built-in themes contain a small style, which you can enable by adding
                <parameter>Reindeer.BUTTON_SMALL</parameter>, etc. The
                <classname>BaseTheme</classname> also has a
                <parameter>BUTTON_LINK</parameter> style, which makes the button look like
                a hyperlink.
            </para>
		</simplesect>
	</section>

	<section xml:id="components.checkbox">
		<title><classname>CheckBox</classname></title>

		<para>
			<classname>CheckBox</classname> is a two-state selection component that can be
			either checked or unchecked. The caption of the check box will be placed right
			of the actual check box. Vaadin provides two ways to create check boxes:
			individual check boxes with the <classname>CheckBox</classname> component
			described in this section and check box groups with the
			<classname>OptionGroup</classname> component in multiple selection mode, as
			described in <xref linkend="components.optiongroup"/>.
		</para>

		<para>
			Clicking on a check box will change its state. The state is a
			<classname>Boolean</classname> property that you can set with the
			<methodname>setValue()</methodname> method and obtain with the
			<methodname>getValue()</methodname> method of the
			<classname>Property</classname> interface.  Changing the value of a check box
			will cause a <classname>ValueChangeEvent</classname>, which can be handled by
			a <classname>ValueChangeListener</classname>.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[CheckBox checkbox1 = new CheckBox("Box with no Check");
CheckBox checkbox2 = new CheckBox("Box with a Check");

checkbox2.setValue(true);

checkbox1.addValueChangeListener(event -> // Java 8
    checkbox2.setValue(! checkbox1.getValue()));

checkbox2.addValueChangeListener(event -> // Java 8
    checkbox1.setValue(! checkbox2.getValue()));]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.checkbox.basic"/>.
        </para>

		<figure xml:id="figure.components.checkbox.basic">
			<title>An Example of a Check Box</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="50%" align="center" fileref="img/components/checkbox-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			For an example on the use of check boxes in a table, see <xref
			linkend="components.table"/>.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-checkbox { }
  .v-checkbox > input { }
  .v-checkbox > label { }]]></programlisting>

            <para>
                The top-level element of a <classname>CheckBox</classname> has the
                <literal>v-checkbox</literal> style. It contains two sub-elements: the
                actual check box <literal>input</literal> element and the
                <literal>label</literal> element. If you want to have the label on the
                left, you can change the positions with "<literal>direction:
                rtl</literal>" for the top element.
            </para>
		</simplesect>
	</section>

    <section xml:id="components.combobox">
        <title><classname>ComboBox</classname></title>

        <para>
            <classname>ComboBox</classname> is a selection component allows selecting an
            item from a drop-down list. The component also has a text field area, which
            allows entering search text by which the items shown in the drop-down list are
            filtered. Common selection component features are described in <xref
            linkend="components.selection"/>.
        </para>

        <figure>
            <title>The <classname>ComboBox</classname> Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="50%" align="center" fileref="img/components/combobox-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            <classname>ComboBox</classname> supports adding new items when the user
            presses <keycap>Enter</keycap><phrase condition="web">, as described in <xref
            linkend="components.selection.newitems"/>.</phrase>
        </para>

        <section xml:id="components.combobox.filtering">
            <title>Filtered Selection</title>
				
            <para>
                <classname>ComboBox</classname> allows filtering the items available for
                selection in the drop-down list by the text entered in the input
                box.
            </para>

            <figure xml:id="figure.components.combobox.filter" float="center" floatstyle="before">
                <title>Filtered Selection in <classname>ComboBox</classname></title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="50%" align="center" fileref="img/components/combobox-filtering.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Pressing <keycap>Enter</keycap> will complete the item in the input
                box. Pressing <keycap>Up</keycap>- and <keycap>Down</keycap>-arrows can be
                used for selecting an item from the drop-down list. The drop-down list is
                paged and clicking on the scroll buttons will change to the next or
                previous page. The list selection can also be done with the arrow keys on
                the keyboard. The shown items are loaded from the server as needed, so the
                number of items held in the component can be quite large. The number of
                matching items is displayed by the drop-down list.
            </para>
			
            <para>
                Filtering is enabled by setting a <emphasis>filtering mode</emphasis> with
                <methodname>setFilteringMode()</methodname>.
            </para>

            <book-example eid="component.select.combobox.filtering"></book-example>
            <programlisting><?pocket-size 85% ?><![CDATA[cb.setFilteringMode(FilteringMode.CONTAINS);]]></programlisting>

            <para>
                The modes defined in the <classname>FilteringMode</classname> enum are as
                follows:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>CONTAINS</parameter></term>
                    <listitem>
                        <para>
                            Matches any item that contains the string given in the
                            text field part of the component.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>STARTSWITH</parameter></term>
                    <listitem>
                        <para>
                            Matches only items that begin with the given string.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>OFF</parameter> (default)</term>
                    <listitem>
                        <para>
                            Filtering is by default off and all items are shown all the
                            time.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                The above example uses the containment filter that matches to all items
                containing the input string. As shown in <xref
                linkend="figure.components.combobox.filter"/> below, when we
                type some text in the input area, the drop-down list will show all the
                matching items.
            </para>
        </section>
					
        <simplesect xml:id="components.combobox.css">
            <title>CSS Style Rules</title>
                
            <programlisting><![CDATA[.v-filterselect { }
  .v-filterselect-input { }
  .v-filterselect-button { }

// Under v-overlay-container
.v-filterselect-suggestpopup { }
  .popupContent { }
    .v-filterselect-prevpage,
      .v-filterselect-prevpage-off { }
    .v-filterselect-suggestmenu { }
      .gwt-MenuItem { }
    .v-filterselect-nextpage,
      .v-filterselect-nextpage-off { }
    .v-filterselect-status { }]]></programlisting>
					
            <para>
                In its default state, only the input field of the
                <classname>ComboBox</classname> component is visible. The entire
                component is enclosed in <literal>v-filterselect</literal> style (a
                legacy remnant), the input field has
                <literal>v-filterselect-input</literal> style and the button in the
                right end that opens and closes the drop-down result list has
                <literal>v-filterselect-button</literal> style.
            </para>

            <para>
                The drop-down result list has an overall
                <literal>v-filterselect-suggestpopup</literal> style. It contains the list
                of suggestions with <literal>v-filterselect-suggestmenu</literal>
                style. When there are more items that fit in the menu, navigation buttons
                with <literal>v-filterselect-prevpage</literal> and
                <literal>v-filterselect-nextpage</literal> styles are shown. When they are
                not shown, the elements have <literal>-off</literal> suffix. The status
                bar in the bottom that shows the paging status has
                <literal>v-filterselect-status</literal> style.
            </para>
        </simplesect>
    </section>

    <section xml:id="components.listselect">
        <title><classname>ListSelect</classname></title>

        <para>
            The <classname>ListSelect</classname> component is list box that shows the
            selectable items in a vertical list. If the number of items exceeds the height
            of the component, a scrollbar is shown. The component allows both single and
            multiple selection modes, which you can set with
            <methodname>setMultiSelect()</methodname>. It is visually identical in both
            modes.
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[// Create the selection component
ListSelect select = new ListSelect("The List");
        
// Add some items (here by the item ID as the caption)
select.addItems("Mercury", "Venus", "Earth", ...);

select.setNullSelectionAllowed(false);

// Show 5 items and a scrollbar if there are more
select.setRows(5);]]></programlisting>

        <para>
            The number of visible items is set with
            <methodname>setRows()</methodname>.
        </para>

        <figure xml:id="figure.components.listselect.basic">
            <title>The <classname>ListSelect</classname> Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="60%" align="center" fileref="img/components/listselect-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Common selection component features are described in <xref
            linkend="components.selection"/>.
        </para>
        
        <simplesect>
            <title>CSS Style Rules</title>
            
            <programlisting><![CDATA[.v-select {}
  .v-select-select {}
    option {}]]></programlisting>

            <para>
                The component has an overall <literal>v-select</literal> style. The native
                <literal>&lt;select&gt;</literal> element has
                <literal>v-select-select</literal> style. The items are represented as
                <literal>&lt;option&gt;</literal> elements.
            </para>
        </simplesect>
    </section>

    <section xml:id="components.nativeselect">
        <title><classname>NativeSelect</classname></title>
			
        <para>
            <classname>NativeSelect</classname> is a drop-down selection component
            implemented with the native selection input of web browsers, using the HTML
            <literal>&lt;select&gt;</literal> element.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create the selection component
NativeSelect select = new NativeSelect("Native Selection");
        
// Add some items
select.addItems("Mercury", "Venus", ...);]]></programlisting>

        <para>
            The <methodname>setColumns()</methodname> allows setting the width of the list
            as "columns", which is a measure that depends on the browser.
        </para>

        <figure xml:id="figure.components.nativeselect.basic">
            <title>The <classname>NativeSelect</classname> Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="35%" align="center" fileref="img/components/nativeselect-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Common selection component features are described in <xref
            linkend="components.selection"/>.
        </para>
        
        <simplesect>
            <title>CSS Style Rules</title>
				
            <programlisting><![CDATA[.v-select {}
  .v-select-select {}]]></programlisting>

            <para>
                The component has a <literal>v-select</literal> overall style. The
                native <literal>select</literal> element has
                <literal>v-select-select</literal> style.
            </para>
        </simplesect>
    </section>

    <section xml:id="components.optiongroup">
        <title><classname>OptionGroup</classname></title>

        <para>
            <classname>OptionGroup</classname> is a selection component that allows
            selection from a group of radio buttons in single selection mode. In multiple
            selection mode, the items show up as check boxes. The common selection
            component features are described in <xref linkend="components.selection"/>.
        </para>

        <figure xml:id="figure.components.optiongroup">
            <title>Option Button Group in Single and Multiple Selection Mode</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="75%" align="center" fileref="img/components/optiongroup-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Option group is by default in single selection mode. Multiple selection is
            enabled with <methodname>setMultiSelect()</methodname>.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[// A single-select radio button group
OptionGroup single = new OptionGroup("Single Selection");
single.addItems("Single", "Sola", "Yksi");

// A multi-select check box group
OptionGroup multi = new OptionGroup("Multiple Selection");
multi.setMultiSelect(true);
multi.addItems("Many", "Muchos", "Monta");]]></programlisting>

        <para>
            <xref linkend="figure.components.optiongroup"/> shows the
            <classname>OptionGroup</classname> in both single and multiple selection mode.
        </para>

        <para>
            You can also create check boxes individually using the
            <classname>CheckBox</classname> class, as described in <xref
            linkend="components.checkbox"/>. The advantages of the
            <classname>OptionGroup</classname> component are that as it maintains the
            individual check box objects, you can get an array of the currently selected
            items easily, and that you can easily change the appearance of a single
            component.
        </para>

        <section xml:id="components.optiongroup.disabling">
            <title>Disabling Items</title>

            <para>
                You can disable individual items in an <classname>OptionGroup</classname>
                with <methodname>setItemEnabled()</methodname>. The user can not select or
                deselect disabled items in multi-select mode, but in single-select mode
                the use can change the selection from a disabled to an enabled item. The
                selections can be changed programmatically regardless of whether an item
                is enabled or disabled. You can find out whether an item is enabled with
                <methodname>isItemEnabled()</methodname>.
            </para>

            <para>
                The <methodname>setItemEnabled()</methodname> identifies the item to
                be disabled by its item ID.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Have an option group with some items
OptionGroup group = new OptionGroup("My Disabled Group");
group.addItems("One", "Two", "Three");

// Disable one item by its item ID
group.setItemEnabled("Two", false);]]></programlisting>

            <para>
                The item IDs are also used for the captions in this example. The
                result is shown in <xref
                    linkend="figure.components.optiongroup.disabling"/>.
            </para>

            <figure xml:id="figure.components.optiongroup.disabling">
                <title><classname>OptionGroup</classname> with a Disabled Item</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="40%" align="center" fileref="img/components/optiongroup-disabling.png"/>
                        </imageobject>
                </mediaobject>
            </figure>

            <para>
                Setting an item as disabled turns on the <literal>v-disabled</literal>
                style for it.
            </para>
        </section>

        <simplesect xml:id="components.optiongroup.css">
            <title>CSS Style Rules</title>
				
            <programlisting><![CDATA[.v-select-optiongroup {}
  .v-select-option.v-checkbox {}
  .v-select-option.v-radiobutton {}]]></programlisting>

            <para>
                The <literal>v-select-optiongroup</literal> is the overall style for
                the component. Each check box will have the
                <literal>v-checkbox</literal> style, borrowed from the
                <classname>CheckBox</classname> component, and each radio button the
                <literal>v-radiobutton</literal> style. Both the radio buttons and
                check boxes will also have the <literal>v-select-option</literal>
                style that allows styling regardless of the option type. Disabled
                items have additionally the <literal>v-disabled</literal> style.
            </para>

            <simplesect xml:id="components.optiongroup.css.horizontal">
                <para>
                    The options are normally laid out vertically. You can use horizontal
                    layout by setting <literal>display: inline-block</literal> for the
                    options. The <literal>nowrap</literal> setting for the overall element
                    prevents wrapping if there is not enough horizontal space in the
                    layout, or if the horizontal width is undefined.
                </para>

                <programlisting><![CDATA[/* Lay the options horizontally */
.v-select-optiongroup-horizontal .v-select-option {
    display: inline-block;
}

/* Avoid wrapping if the layout is too tight */
.v-select-optiongroup-horizontal {
    white-space: nowrap;
}

/* Some extra spacing is needed */
.v-select-optiongroup-horizontal
  .v-select-option.v-radiobutton {
    padding-right: 10px;
}]]></programlisting>

                <para>
                    Use of the above rules requires setting a custom
                    <literal>horizontal</literal> style name for the component. The result
                    is shown in <xref
                    linkend="figure.components.optiongroup.horizontal"/>.
                </para>

                <figure xml:id="figure.components.optiongroup.horizontal">
                    <title>Horizontal <classname>OptionGroup</classname></title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="70%" align="center" fileref="img/components/optiongroup-horizontal.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </simplesect>
        </simplesect>
    </section>

    <section xml:id="components.twincolselect">
        <title><classname>TwinColSelect</classname></title>

        <para>
            The <classname>TwinColSelect</classname> field provides a multiple selection
            component that shows two lists side by side, with the left column containing
            unselected items and the right column the selected items. The user can select
            items from the list on the left and click on the "&gt;&gt;" button to move
            them to the list on the right. Items can be deselected by selecting them in
            the right list and clicking on the "&lt;&lt;" button.
        </para>

        <figure xml:id="figure.components.twincolselect.basic" float="center" floatstyle="before">
            <title>Twin Column Selection</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="100%" align="center" fileref="img/components/twincolselect-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            <classname>TwinColSelect</classname> is always in multi-select mode, so its
            property value is always a collection of the item IDs of the selected items,
            that is, the items in the right column.
        </para>

        <para>
            The selection columns can have their own captions, separate from the overall
            component caption, which is managed by the containing layout. You can set the
            column captions with <methodname>setLeftColumnCaption()</methodname> and
            <methodname>setRightColumnCaption()</methodname>.
        </para>

        <book-example eid="component.select.twincolselect.captions" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[TwinColSelect select = new TwinColSelect("Select Targets");

// Put some items in the select
select.addItems("Mercury", "Venus", "Earth", "Mars",
        "Jupiter", "Saturn", "Uranus", "Neptune");

// Few items, so we can set rows to match item count
select.setRows(select.size());

// Preselect a few items by creating a set
select.setValue(new HashSet<String>(
    Arrays.asList("Venus", "Earth", "Mars")));

// Handle value changes
select.addValueChangeListener(event -> // Java 8
    layout.addComponent(new Label("Selected: " +
            event.getProperty().getValue())));]]></programlisting>

        <para>
            The resulting component is shown in <xref
            linkend="figure.components.twincolselect.basic"/>.
        </para>

        <para>
            The <methodname>setRows()</methodname> method sets the height of the component
            by the number of visible items in the selection boxes. Setting the height with
            <methodname>setHeight()</methodname> to a defined value overrides the rows
            setting.
        </para>

        <para>
            Common selection component features are described in <xref
            linkend="components.selection"/>.
        </para>
        
        <simplesect>
            <title>CSS Style Rules</title>
				
            <programlisting><![CDATA[.v-select-twincol {}
  .v-select-twincol-options-caption {}
  .v-select-twincol-selections-caption {}
  .v-select-twincol-options {}
  .v-select-twincol-buttons {}
    .v-button {}
      .v-button-wrap {}
        .v-button-caption {}
    .v-select-twincol-deco {}
  .v-select-twincol-selections {}]]></programlisting>

            <para>
                The <classname>TwinColSelect</classname> component has an overall
                <literal>v-select-twincol</literal> style. If set, the left and right
                column captions have <literal>v-select-twincol-options-caption</literal>
                and <literal>v-select-twincol-options-caption</literal> style names,
                respectively. The left box, which displays the unselected items, has
                <literal>v-select-twincol-options-caption</literal> style and the right
                box, which displays the selected items, has
                <literal>v-select-twincol-options-selections</literal> style. Between them
                is the button area, which has overall
                <literal>v-select-twincol-buttons</literal> style; the actual buttons
                reuse the styles for the <classname>Button</classname> component. Between
                the buttons is a divider element with
                <literal>v-select-twincol-deco</literal> style.
            </para>

        </simplesect>
    </section>

    <!-- ================================================================== -->
    <!-- Table                                                              -->
    <!-- ================================================================== -->

	<section xml:id="components.table">
		<title><classname>Table</classname></title>

        <indexterm xml:id="term.components.table" class="startofrange">
            <primary><classname>Table</classname></primary>
        </indexterm>

		<para>
			The <classname>Table</classname> component is intended for presenting tabular
			data organized in rows and columns. The <classname>Table</classname> is one of
			the most versatile components in Vaadin. Table cells can include text
			or arbitrary UI components. You can easily implement editing of the table data,
			for example clicking on a cell could change it to a text field for editing.
		</para>

		<para>
			The data contained in a <classname>Table</classname> is managed using the Data
			Model of Vaadin (see <xref linkend="datamodel"/>), through
			the <classname>Container</classname> interface of the
			<classname>Table</classname>. This makes it possible to bind a table directly
			to a data source, such as a database query. Only the visible part of the table
			is loaded into the browser and moving the visible window with the scrollbar loads
			content from the server. While the data is being loaded, a tooltip will be
			displayed that shows the current range and total number of items in the
			table. The rows of the table are <emphasis>items</emphasis> in the container
			and the columns are <emphasis>properties</emphasis>. Each table row (item) is
			identified with an <emphasis>item identifier</emphasis> (IID), and each column
			(property) with a <emphasis>property identifier</emphasis> (PID).
		</para>

		<para>
			When creating a table, you first need to define columns with
			<methodname>addContainerProperty()</methodname>. This method comes in two
			flavors. The simpler one takes the property ID of the column and uses it also
			as the caption of the column. The more complex one allows differing PID and
			header for the column. This may make, for example, internationalization of
			table headers easier, because if a PID is internationalized, the
			internationalization has to be used everywhere where the PID is used. The
			complex form of the method also allows defining an icon for the column from a
			resource. The "default value" parameter is used when new properties (columns)
			are added to the table, to fill in the missing values. (This default has no
			meaning in the usual case, such as below, where we add items after defining
			the properties.)
		</para>

        <programlisting><?pocket-size 75% ?><![CDATA[Table table = new Table("The Brightest Stars");

// Define two columns for the built-in container
table.addContainerProperty("Name", String.class, null);
table.addContainerProperty("Mag",  Float.class, null);

// Add a row the hard way
Object newItemId = table.addItem();
Item row1 = table.getItem(newItemId);
row1.getItemProperty("Name").setValue("Sirius");
row1.getItemProperty("Mag").setValue(-1.46f);

// Add a few other rows using shorthand addItem()
table.addItem(new Object[]{"Canopus",        -0.72f}, 2);
table.addItem(new Object[]{"Arcturus",       -0.04f}, 3);
table.addItem(new Object[]{"Alpha Centauri", -0.01f}, 4);

// Show exactly the currently contained rows (items)
table.setPageLength(table.size());]]></programlisting>

		<para>
			In this example, we used an increasing <classname>Integer</classname> object
			as the Item Identifier, given as the second parameter to
			<methodname>addItem()</methodname>. The actual rows are given simply as object
			arrays, in the same order in which the properties were added. The objects must
			be of the correct class, as defined in the
			<methodname>addContainerProperty()</methodname> calls.
		</para>

		<figure>
			<title>Basic Table Example</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="50%" align="center" fileref="img/components/table-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Scalability of the <classname>Table</classname> is largely dictated by
			the container. The default <classname>IndexedContainer</classname> is
			relatively heavy and can cause scalability problems, for example, when
			updating the values. Use of an optimized application-specific
			container is recommended. Table does not have a limit for the number
			of items and is just as fast with hundreds of thousands of items as
			with just a few. With the current implementation of scrolling, there
			is a limit of around 500 000 rows, depending on the browser and the pixel
			height of rows.
		</para>

        <para>
            Common selection component features are described in <xref
            linkend="components.selection"/>.
        </para>
        
		<section xml:id="components.table.selecting">
			<title>Selecting Items in a Table</title>

			<para>
				The <classname>Table</classname> allows selecting one or more items by
				clicking them with the mouse. When the user selects an item, the IID of the
				item will be set as the property of the table and a
				<classname>ValueChangeEvent</classname> is triggered. To enable selection,
				you need to set the table <emphasis>selectable</emphasis>. You will also
				need to set it as <emphasis>immediate</emphasis> in most cases, as we do
				below, because without it, the change in the property will not be
				communicated immediately to the server.
			</para>

			<para>
				The following example shows how to enable the selection of items in a
				<classname>Table</classname> and how to handle
				<classname>ValueChangeEvent</classname> events that are caused by changes
				in selection. You need to handle the event with the
				<methodname>valueChange()</methodname> method of the
				<classname>Property.ValueChangeListener</classname> interface.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Allow selecting items from the table.
table.setSelectable(true);

// Send changes in selection immediately to server.
table.setImmediate(true);

// Shows feedback from selection.
final Label current = new Label("Selected: -");

// Handle selection change.
table.addValueChangeListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        current.setValue("Selected: " + table.getValue());
    }
});]]></programlisting>

			<figure>
				<title>Table Selection Example</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/components/table-example2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				If the user clicks on an already selected item, the selection will
				deselected and the table property will have <parameter>null</parameter>
				value. You can disable this behaviour by setting
				<methodname>setNullSelectionAllowed(false)</methodname> for the table.
			</para>

            <para>
                The selection is the value of the table's property, so you can get it with
                <methodname>getValue()</methodname>. You can get it also from a reference
                to the table itself. In single selection mode, the value is the item
                identifier of the selected item or <parameter>null</parameter> if no item
                is selected. In multiple selection mode (see below), the value is a
                <classname>Set</classname> of item identifiers. Notice that the set is
                unmodifiable, so you can not simply change it to change the selection.
			</para>

            <simplesect>
                <title>Multiple Selection Mode</title>

                <para>
                    A table can also be in <emphasis>multiselect</emphasis> mode, where a
                    user can select multiple items by clicking them with left mouse button
                    while holding the <keycap>Ctrl</keycap> key (or <keycap>Meta</keycap>
                    key) pressed. If <keycap>Ctrl</keycap> is not held, clicking an item
                    will select it and other selected items are deselected. The user can
                    select a range by selecting an item, holding the
                    <keycap>Shift</keycap> key pressed, and clicking another item, in
                    which case all the items between the two are also selected. Multiple
                    ranges can be selected by first selecting a range, then selecting an
                    item while holding <keycap>Ctrl</keycap>, and then selecting another
                    item with both <keycap>Ctrl</keycap> and <keycap>Shift</keycap>
                    pressed.
                </para>

                <para>
                    The multiselect mode is enabled with the
                    <methodname>setMultiSelect()</methodname> method of the
                    <classname>AbstractSelect</classname> superclass of
                    <classname>Table</classname>. Setting table in multiselect mode does
                    not implicitly set it as <emphasis>selectable</emphasis>, so it must
                    be set separately.
                </para>

                <para>
                    The <methodname>setMultiSelectMode()</methodname> property affects the
                    control of multiple selection:
                    <parameter>MultiSelectMode.DEFAULT</parameter> is the default
                    behaviour, which requires holding the <keycap>Ctrl</keycap> (or
                    <keycap>Meta</keycap>) key pressed while selecting items, while in
                    <parameter>MultiSelectMode.SIMPLE</parameter> holding the
                    <keycap>Ctrl</keycap> key is not needed. In the simple mode, items can
                    only be deselected by clicking them.
                </para>
            </simplesect>
		</section>

		<section xml:id="components.table.features">
			<title>Table Features</title>
			
			<section>
				<title>Page Length and Scrollbar</title>

				<para>
					The default style for <classname>Table</classname> provides a table
					with a scrollbar. The scrollbar is located at the right side of the
					table and becomes visible when the number of items in the table
					exceeds the page length, that is, the number of visible items. You can
					set the page length with <methodname>setPageLength()</methodname>.
				</para>

				<para>
					Setting the page length to zero makes all the rows in a table visible,
					no matter how many rows there are. Notice that this also effectively
					disables buffering, as all the entire table is loaded to the browser
					at once. Using such tables to generate reports does not scale up very
					well, as there is some inevitable overhead in rendering a table with
					Ajax. For very large reports, generating HTML directly is a more
					scalable solution.
				</para>
			</section>

			<section xml:id="components.table.features.resizing">
				<title>Resizing Columns</title>

                <para>
                    You can set the width of a column programmatically from the
                    server-side with <methodname>setColumnWidth()</methodname>. The column
                    is identified by the property ID and the width is given in pixels.
                </para>

				<para>
					The user can resize table columns by dragging the resize handle
					between two columns. Resizing a table column causes a
					<classname>ColumnResizeEvent</classname>, which you can handle with a
					<classname>Table.ColumnResizeListener</classname>. The table must be
					set in immediate mode if you want to receive the resize events
					immediately, which is typical.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[table.addColumnResizeListener(new Table.ColumnResizeListener(){
    public void columnResize(ColumnResizeEvent event) {
        // Get the new width of the resized column
        int width = event.getCurrentWidth();
        
        // Get the property ID of the resized column
        String column = (String) event.getPropertyId();

        // Do something with the information
        table.setColumnFooter(column, String.valueOf(width) + "px");
    }
});
        
// Must be immediate to send the resize events immediately
table.setImmediate(true);]]></programlisting>

                <para>
                    See <xref linkend="figure.component.table.columnresize"/> for a result
                    after the columns of a table has been resized.
                </para>

                <figure xml:id="figure.component.table.columnresize">
                    <title>Resizing Columns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" align="center" fileref="img/components/table-column-resize.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
			</section>

			<section xml:id="components.table.features.reordering">
				<title>Reordering Columns</title>
			
				<para>
                    If <methodname>setColumnReorderingAllowed(true)</methodname> is set,
                    the user can reorder table columns by dragging them with the mouse
                    from the column header,
				</para>
			</section>

			<section xml:id="components.table.features.collapsing">
                <title>Collapsing Columns</title>

                <para>
                    When <methodname>setColumnCollapsingAllowed(true)</methodname> is set,
                    the right side of the table header shows a drop-down list that allows
                    selecting which columns are shown. Collapsing columns is different
                    than hiding columns with <methodname>setVisibleColumns()</methodname>,
                    which hides the columns completely so that they can not be made
                    visible (uncollapsed) from the user interface.
                </para>

                <para>
                    You can collapse columns programmatically with
                    <methodname>setColumnCollapsed()</methodname>. Collapsing must be
                    enabled before collapsing columns with the method or it will throw an
                    <classname>IllegalAccessException</classname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Allow the user to collapse and uncollapse columns
table.setColumnCollapsingAllowed(true);

// Collapse this column programmatically
try {
    table.setColumnCollapsed("born", true);
} catch (IllegalAccessException e) {
    // Can't occur - collapsing was allowed above
    System.err.println("Something horrible occurred");
}
        
// Give enough width for the table to accommodate the
// initially collapsed column later
table.setWidth("250px");]]></programlisting>

                <para>
                    See <xref linkend="figure.component.table.columncollapsing"/>.
                </para>

                <figure xml:id="figure.component.table.columncollapsing">
                    <title>Collapsing Columns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" align="center" fileref="img/components/table-column-collapsing.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    If the table has undefined width, it minimizes its width to fit the
                    width of the visible columns. If some columns are initially collapsed,
                    the width of the table may not be enough to accomodate them later,
                    which will result in an ugly horizontal scrollbar. You should consider
                    giving the table enough width to accomodate columns uncollapsed by the
                    user.
                </para>
            </section>

			<section xml:id="components.table.features.components">
				<title>Components Inside a Table</title>

				<para>
					The cells of a <classname>Table</classname> can contain any user
					interface components, not just strings. If the rows are higher than
					the row height defined in the default theme, you have to define the
					proper row height in a custom theme.
				</para>

				<para>
					When handling events for components inside a
					<classname>Table</classname>, such as for the
					<classname>Button</classname> in the example below, you usually need
					to know the item the component belongs to. Components do not
					themselves know about the table or the specific item in which a
					component is contained.  Therefore, the handling method must use some
					other means for finding out the Item ID of the item. There are a few
					possibilities. Usually the easiest way is to use the
					<methodname>setData()</methodname> method to attach an arbitrary
					object to a component. You can subclass the component and include the
					identity information there. You can also simply search the entire
					table for the item with the component, although that solution may not
					be so scalable.
				</para>

				<para>
					The example below includes table rows with a
					<classname>Label</classname> in HTML content mode, a multiline
					<classname>TextField</classname>, a <classname>CheckBox</classname>,
					and a <classname>Button</classname> that shows as a link.
				</para>

                <book-example eid="component.table.components.components2"></book-example>
				<programlisting><?pocket-size 65% ?><![CDATA[// Create a table and add a style to allow setting the row height in theme.
final Table table = new Table();
table.addStyleName("components-inside");

/* Define the names and data types of columns.
 * The "default value" parameter is meaningless here. */
table.addContainerProperty("Sum",            Label.class,     null);
table.addContainerProperty("Is Transferred", CheckBox.class,  null);
table.addContainerProperty("Comments",       TextField.class, null);
table.addContainerProperty("Details",        Button.class,    null);

/* Add a few items in the table. */
for (int i=0; i<100; i++) {
    // Create the fields for the current table row
    Label sumField = new Label(String.format(
                   "Sum is <b>$%04.2f</b><br/><i>(VAT incl.)</i>",
                   new Object[] {new Double(Math.random()*1000)}),
                               ContentMode.HTML);
    CheckBox transferredField = new CheckBox("is transferred");
    
    // Multiline text field. This required modifying the 
    // height of the table row.
    TextField commentsField = new TextField();
    commentsField.setRows(3);
    
    // The Table item identifier for the row.
    Integer itemId = new Integer(i);
    
    // Create a button and handle its click. A Button does not
    // know the item it is contained in, so we have to store the
    // item ID as user-defined data.
    Button detailsField = new Button("show details");
    detailsField.setData(itemId);
    detailsField.addClickListener(new Button.ClickListener() {
        public void buttonClick(ClickEvent event) {
            // Get the item identifier from the user-defined data.
            Integer iid = (Integer)event.getButton().getData();
            Notification.show("Link " +
                              iid.intValue() + " clicked.");
        } 
    });
    detailsField.addStyleName("link");
    
    // Create the table row.
    table.addItem(new Object[] {sumField, transferredField,
                                commentsField, detailsField},
                  itemId);
}

// Show just three rows because they are so high.
table.setPageLength(3);]]></programlisting>

				<para>
					The row height has to be set higher than the default with a style rule
					such as the following:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[/* Table rows contain three-row TextField components. */
.v-table-components-inside .v-table-cell-content {
	height: 54px;
}]]></programlisting>

				<para>
					The table will look as shown in <xref
					linkend="figure.components.table.components-inside"/>.
				</para>

				<figure xml:id="figure.components.table.components-inside">
					<title>Components in a Table</title>
					<mediaobject>
						<imageobject>
							<imagedata smallscale="100%" align="center" fileref="img/components/table-components.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section xml:id="components.table.features.iterating">
				<title>Iterating Over a Table</title>

				<para>
					As the items in a <classname>Table</classname> are not indexed, iterating
					over the items has to be done using an iterator. The
					<methodname>getItemIds()</methodname> method of the
					<classname>Container</classname> interface of <classname>Table</classname>
					returns a <classname>Collection</classname> of item identifiers over which
					you can iterate using an <classname>Iterator</classname>. For an example
					about iterating over a <classname>Table</classname>, please see <xref
						linkend="datamodel.container"/>. Notice that you may not modify the
					<classname>Table</classname> during iteration, that is, add or remove
					items. Changing the data is allowed.
				</para>
			</section>

			<section xml:id="components.table.features.filtering">
                <title>Filtering Table Contents</title>

                <para>
                    A table can be filtered if its container data source implements the
                    <classname>Filterable</classname> interface, as the default
                    <classname>IndexedContainer</classname> does. See <xref
                    linkend="datamodel.container.filtered"/>.
                    
                    <indexterm><primary>Container</primary><secondary>Filterable</secondary></indexterm>
                </para>
            </section>
		</section>

        <section xml:id="components.table.editing">
            <title>Editing the Values in a Table</title>
            
            <para>
                Normally, a <classname>Table</classname> simply displays the items and
                their fields as text. If you want to allow the user to edit the values,
                you can either put them inside components as we did earlier or simply call
                <methodname>setEditable(true)</methodname>, in which case the cells are
                automatically turned into editable fields.
            </para>

            <para>
                Let us begin with a regular table with a some columns with usual Java
                types, namely a <classname>Date</classname>,
                <classname>Boolean</classname>, and a <classname>String</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a table. It is by default not editable.
final Table table = new Table();

// Define the names and data types of columns.
table.addContainerProperty("Date",     Date.class,  null);
table.addContainerProperty("Work",     Boolean.class, null);
table.addContainerProperty("Comments", String.class,  null);

// Add a few items in the table.
for (int i=0; i<100; i++) {
    Calendar calendar = new GregorianCalendar(2008,0,1);
    calendar.add(Calendar.DAY_OF_YEAR, i);
    
    // Create the table row.
    table.addItem(new Object[] {calendar.getTime(),
                                new Boolean(false),
                                ""},
                  new Integer(i)); // Item identifier
}

table.setPageLength(8);
layout.addComponent(table);]]></programlisting>

            <para>
                You could put the table in editable mode right away if you need to. We'll
                continue the example by adding a mechanism to switch the
                <classname>Table</classname> from and to the editable mode.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final CheckBox switchEditable = new CheckBox("Editable");
switchEditable.addValueChangeListener(
        new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        table.setEditable(((Boolean)event.getProperty()
                             .getValue()).booleanValue());
    }
});
switchEditable.setImmediate(true);
layout.addComponent(switchEditable);]]></programlisting>

            <para>
                Now, when you check to checkbox, the components in the table turn into
                editable fields, as shown in <xref
                linkend="figure.component.table.editable"/>.
            </para>

            <figure xml:id="figure.component.table.editable">
                <title>A Table in Normal and Editable Mode</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/table-editable3.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="45" smallscale="100%" align="center" fileref="img/components/table-editable3.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section>
                <title>Field Factories</title>

                <para>
                    The field components that allow editing the values of particular types
                    in a table are defined in a field factory that implements the
                    <classname>TableFieldFactory</classname> interface. The default
                    implementation is <classname>DefaultFieldFactory</classname>, which
                    offers the following crude mappings:
                </para>
                
                <table>
                    <title>Type to Field Mappings in <classname>DefaultFieldFactory</classname></title>
                    <tgroup cols="2" align="left">
                        <thead>
                            <row valign="top">
                                <entry>Property Type</entry>
                                <entry>Mapped to Field Class</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="top">
                                <entry><classname>Date</classname></entry>
                                <entry>A <classname>DateField</classname>. </entry>
                            </row>
                            <row valign="top">
                                <entry><classname>Boolean</classname></entry>
                                <entry>A <classname>CheckBox</classname>.</entry>
                            </row>
                            <row valign="top">
                                <entry><classname>Item</classname></entry>
                                
                                <entry>A <classname>Form</classname> (deprecated in Vaadin
                                7). The fields of the form are automatically created from
                                the item's properties using a
                                <classname>FormFieldFactory</classname>. The normal use
                                for this property type is inside a
                                <classname>Form</classname> and is less useful inside a
                                <classname>Table</classname>.</entry>
                            </row>
                            <row valign="top">
                                <entry><emphasis>other</emphasis></entry>
                                
                                <entry>A <classname>TextField</classname>. The text field
                                    manages conversions from the basic types, if
                                    possible.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                
                <para>
                    Field factories are covered with more detail in <xref
                        linkend="datamodel.itembinding"/>. You could just implement the
                    <classname>TableFieldFactory</classname> interface, but we recommend that
                    you extend the <classname>DefaultFieldFactory</classname> according to
                    your needs. In the default implementation, the mappings are defined in the
                    <methodname>createFieldByPropertyType()</methodname> method (you might
                    want to look at the source code) both for tables and forms.
                </para>
            </section>

            <section>
                <title>Navigation in Editable Mode</title>

                <para>
                    In the editable mode, the editor fields can have focus. Pressing
                    <keycap>Tab</keycap> moves the focus to next column or, at the last
                    column, to the first column of the next item. Respectively, pressing
                    <keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves
                    the focus backward. If the focus is in the last column of the last
                    visible item, the pressing <keycap>Tab</keycap> moves the focus
                    outside the table. Moving backward from the first column of the first
                    item moves the focus to the table itself. Some updates to the table,
                    such as changing the headers or footers or regenerating a column, can
                    move the focus from an editor component to the table itself.
                </para>

                <para>
                    The default behaviour may be undesirable in many cases. For example,
                    the focus also goes through any read-only editor fields and can move
                    out of the table inappropriately. You can provide better navigation is
                    to use event handler for shortcut keys such as <keycap>Tab</keycap>,
                    <keycap>Arrow Up</keycap>, <keycap>Arrow Down</keycap>, and
                    <keycap>Enter</keycap>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Keyboard navigation
class KbdHandler implements Handler {
    Action tab_next = new ShortcutAction("Tab",
            ShortcutAction.KeyCode.TAB, null);
    Action tab_prev = new ShortcutAction("Shift+Tab",
            ShortcutAction.KeyCode.TAB,
            new int[] {ShortcutAction.ModifierKey.SHIFT});
    Action cur_down = new ShortcutAction("Down",
            ShortcutAction.KeyCode.ARROW_DOWN, null);
    Action cur_up   = new ShortcutAction("Up",
            ShortcutAction.KeyCode.ARROW_UP,   null);
    Action enter   = new ShortcutAction("Enter",
            ShortcutAction.KeyCode.ENTER,      null);
    public Action[] getActions(Object target, Object sender) {
        return new Action[] {tab_next, tab_prev, cur_down,
                             cur_up, enter};
    }

    public void handleAction(Action action, Object sender,
                             Object target) {
        if (target instanceof TextField) {
            // Move according to keypress
            int itemid = (Integer) ((TextField) target).getData();
            if (action == tab_next || action == cur_down)
                itemid++;
            else if (action == tab_prev || action == cur_up)
                itemid--;
            // On enter, just stay where you were. If we did
            // not catch the enter action, the focus would be
            // moved to wrong place.
            
            if (itemid >= 0 && itemid < table.size()) {
                TextField newTF = valueFields.get(itemid);
                if (newTF != null)
                    newTF.focus();
            }
        }
    }
}

// Panel that handles keyboard navigation
Panel navigator = new Panel();
navigator.addStyleName(Reindeer.PANEL_LIGHT);
navigator.addComponent(table);
navigator.addActionHandler(new KbdHandler());]]></programlisting>

                <para>
                    The main issue in implementing keyboard navigation in an editable
                    table is that the editor fields do not know the table they are in. To
                    find the parent table, you can either look up in the component
                    container hierarchy or simply store a reference to the table with
                    <methodname>setData()</methodname> in the field component. The other
                    issue is that you can not acquire a reference to an editor field from
                    the <classname>Table</classname> component. One solution is to use
                    some external collection, such as a <classname>HashMap</classname>, to
                    map item IDs to the editor fields.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Can't access the editable components from the table so
// must store the information
final HashMap<Integer,TextField> valueFields =
    new HashMap<Integer,TextField>();]]></programlisting>

                <para>
                    The map has to be filled in a
                    <classname>TableFieldFactory</classname>, such as in the
                    following. You also need to set the reference to the table there and
                    you can also set the initial focus there.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[table.setTableFieldFactory(new TableFieldFactory () {
    public Field createField(Container container, Object itemId,
            Object propertyId, Component uiContext) {
        TextField field = new TextField((String) propertyId);
        
        // User can only edit the numeric column
        if ("Source of Fear".equals(propertyId))
            field.setReadOnly(true);
        else { // The numeric column
            // The field needs to know the item it is in
            field.setData(itemId);
            
            // Remember the field
            valueFields.put((Integer) itemId, field);
            
            // Focus the first editable value
            if (((Integer)itemId) == 0)
                field.focus();
        }
        return field;
    }
});]]></programlisting>

                <para>
                    The issues are complicated by the fact that the editor fields are not
                    generated for the entire table, but only for a cache window that
                    includes the visible items and some items above and below it. For
                    example, if the beginning of a big scrollable table is visible, the
                    editor component for the last item does not exist. This issue is
                    relevant mostly if you want to have wrap-around navigation that jumps
                    from the last to first item and vice versa.
                </para>
            </section>

        </section>

        <section xml:id="components.table.headersfooters">
            <title>Column Headers and Footers</title>
            
            <para>
                <classname>Table</classname> supports both column headers and footers; the
                headers are enabled by default.
            </para>

            <section xml:id="components.table.headersfooters.headers">
                <title>Headers</title>

                <para>
                    The table header displays the column headers at the top of the
                    table. You can use the column headers to reorder or resize the
                    columns, as described earlier. By default, the header of a column is
                    the property ID of the column, unless given explicitly with
                    <methodname>setColumnHeader()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Define the properties
table.addContainerProperty("lastname", String.class, null);
table.addContainerProperty("born", Integer.class, null);
table.addContainerProperty("died", Integer.class, null);

// Set nicer header names
table.setColumnHeader("lastname", "Name");
table.setColumnHeader("born", "Born");
table.setColumnHeader("died", "Died");]]></programlisting>

                <para>
                    The text of the column headers and the visibility of the header
                    depends on the <emphasis>column header mode</emphasis>. The header is
                    visible by default, but you can disable it with
                    <methodname>setColumnHeaderMode(Table.COLUMN_HEADER_MODE_HIDDEN)</methodname>.
                </para>
            </section>

            <section xml:id="components.table.headersfooters.footers">
                <title>Footers</title>

                <para>
                    The table footer can be useful for displaying sums or averages of
                    values in a column, and so on. The footer is not visible by default;
                    you can enable it with
                    <methodname>setFooterVisible(true)</methodname>. Unlike in the header,
                    the column headers are empty by default. You can set their value with
                    <methodname>setColumnFooter()</methodname>. The columns are identified
                    by their property ID.
                </para>

                <para>
                    The following example shows how to calculate average of the values in
                    a column:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have a table with a numeric column
Table table = new Table("Custom Table Footer");
table.addContainerProperty("Name", String.class, null);
table.addContainerProperty("Died At Age", Integer.class, null);
        
// Insert some data
Object people[][] = {{"Galileo",  77},
                     {"Monnier",  83},
                     {"Vaisala",  79},
                     {"Oterma",   86}};
for (int i=0; i<people.length; i++)
    table.addItem(people[i], new Integer(i));
        
// Calculate the average of the numeric column
double avgAge = 0;
for (int i=0; i<people.length; i++)
    avgAge += (Integer) people[i][1];
avgAge /= people.length;

// Set the footers
table.setFooterVisible(true);
table.setColumnFooter("Name", "Average");
table.setColumnFooter("Died At Age", String.valueOf(avgAge));

// Adjust the table height a bit
table.setPageLength(table.size());]]></programlisting>

                <para>
                    The resulting table is shown in <xref
                    linkend="figure.components.table.headersfooters.footer"/>.
                </para>

				<figure xml:id="figure.components.table.headersfooters.footer">
					<title>A Table with a Footer</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/components/table-footer.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="120" smallscale="80%" align="center" fileref="img/components/table-footer.png"/>
						</imageobject>
					</mediaobject>
				</figure>
            </section>

            <section>
                <title>Handling Mouse Clicks on Headers and Footers</title>

                <para>
                    Normally, when the user clicks a column header, the table will be
                    sorted by the column, assuming that the data source is
                    <classname>Sortable</classname> and sorting is not disabled. In some
                    cases, you might want some other functionality when the user clicks
                    the column header, such as selecting the column in some way.
                </para>

                <para>
                    Clicks in the header cause a <classname>HeaderClickEvent</classname>,
                    which you can handle with a
                    <classname>Table.HeaderClickListener</classname>. Click events on the
                    table header (and footer) are, like button clicks, sent immediately to
                    server, so there is no need to set
                    <methodname>setImmediate()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Handle the header clicks
table.addHeaderClickListener(new Table.HeaderClickListener() {
    public void headerClick(HeaderClickEvent event) {
        String column = (String) event.getPropertyId();
        Notification.show("Clicked " + column +
                "with " + event.getButtonName());
    }
});
        
// Disable the default sorting behavior
table.setSortDisabled(true);]]></programlisting>

                <para>
                    Setting a click handler does not automatically disable the sorting
                    behavior of the header; you need to disable it explicitly with
                    <methodname>setSortDisabled(true)</methodname>. Header click events
                    are not sent when the user clicks the column resize handlers to drag
                    them.
                </para>


                <para>
                    The <classname>HeaderClickEvent</classname> object provides the
                    identity of the clicked column with
                    <methodname>getPropertyId()</methodname>. The
                    <methodname>getButton()</methodname> reports the mouse button with
                    which the click was made: <parameter>BUTTON_LEFT</parameter>,
                    <parameter>BUTTON_RIGHT</parameter>, or
                    <parameter>BUTTON_MIDDLE</parameter>. The
                    <methodname>getButtonName()</methodname> a human-readable button name
                    in English: "<parameter>left</parameter>",
                    "<parameter>right</parameter>", or
                    "<parameter>middle</parameter>". The
                    <methodname>isShiftKey()</methodname>,
                    <methodname>isCtrlKey()</methodname>, etc., methods indicate if the
                    <keycap>Shift</keycap>, <keycap>Ctrl</keycap>, <keycap>Alt</keycap> or
                    other modifier keys were pressed during the click.
                </para>

                <para>
                    Clicks in the footer cause a <classname>FooterClickEvent</classname>,
                    which you can handle with a
                    <classname>Table.FooterClickListener</classname>. Footers do not have
                    any default click behavior, like the sorting in the header. Otherwise,
                    handling clicks in the footer is equivalent to handling clicks in the
                    header.
                </para>
            </section>
        </section>

		<section xml:id="components.table.columngenerator">
			<title>Generated Table Columns</title>

			<para>
				You might want to have a column that has values calculated from other
				columns. Or you might want to format table columns in some way, for
				example if you have columns that display currencies. The
				<classname>ColumnGenerator</classname> interface allows defining custom
				generators for such columns.
			</para>

			<para>
				You add new generated columns to a <classname>Table</classname> with
				<methodname>addGeneratedColumn()</methodname>. It takes the column
				identifier as its parameters. Usually you want to have a more
				user-friendly and possibly internationalized column header. You can set
				the header and a possible icon by calling
				<methodname>addContainerProperty()</methodname>
				<emphasis>before</emphasis> adding the generated column.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Define table columns. 
table.addContainerProperty(
    "date",     Date.class,   null, "Date",         null, null);
table.addContainerProperty(
    "quantity", Double.class, null, "Quantity (l)", null, null);
table.addContainerProperty(
    "price",    Double.class, null, "Price (e/l)",  null, null);
table.addContainerProperty(
    "total",    Double.class, null, "Total (e)",    null, null);

// Define the generated columns and their generators.
table.addGeneratedColumn("date",
                         new DateColumnGenerator());
table.addGeneratedColumn("quantity",
                         new ValueColumnGenerator("%.2f l"));
table.addGeneratedColumn("price",
                         new PriceColumnGenerator());
table.addGeneratedColumn("total",
                         new ValueColumnGenerator("%.2f e"));]]></programlisting>

			<para>
				Notice that the <methodname>addGeneratedColumn()</methodname> always
				places the generated columns as the last column, even if you defined some
				other order previously. You will have to set the proper order with
				<methodname>setVisibleColumns()</methodname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[table.setVisibleColumns(new Object[] {"date", "quantity", "price", "total"});]]></programlisting>

			<para>
				The generators are objects that implement the
				<classname>Table.ColumnGenerator</classname> interface and its
				<methodname>generateCell()</methodname> method. The method gets the
				identity of the item and column as its parameters, in addition to the
				table object. It has to return a component object.
			</para>
				
			<para>
				The following example defines a generator for formatting
				<classname>Double</classname> valued fields according to a format string
				(as in <classname>java.util.Formatter</classname>).
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/** Formats the value in a column containing Double objects. */
class ValueColumnGenerator implements Table.ColumnGenerator {
    String format; /* Format string for the Double values. */

    /**
     * Creates double value column formatter with the given
     * format string.
     */
    public ValueColumnGenerator(String format) {
        this.format = format;
    }

    /**
     * Generates the cell containing the Double value.
     * The column is irrelevant in this use case.
     */
    public Component generateCell(Table source, Object itemId,
                                  Object columnId) {
        // Get the object stored in the cell as a property
        Property prop =
            source.getItem(itemId).getItemProperty(columnId);
        if (prop.getType().equals(Double.class)) {
            Label label = new Label(String.format(format,
                    new Object[] { (Double) prop.getValue() }));
            
            // Set styles for the column: one indicating that it's
            // a value and a more specific one with the column
            // name in it. This assumes that the column name
            // is proper for CSS.
            label.addStyleName("column-type-value");
            label.addStyleName("column-" + (String) columnId);
            return label;
        }
        return null;
    }
}]]></programlisting>

            <!-- TODO: The following was removed because it's probably false (#3189). -->
			<!-- para>
				If you wish to have a custom style for the cells, you have to set it in
				the generator. A <classname>CellStyleGenerator</classname> defined for a
				table will not be called for the cells of generated columns.
			</para -->

			<para>
				The generator is called for all the visible (or more accurately cached)
				items in a table. If the user scrolls the table to another position in the
				table, the columns of the new visible rows are generated dynamically. The
				columns in the visible (cached) rows are also generated always when an
				item has a value change. It is therefore usually safe to calculate the
				value of generated cells from the values of different rows (items).
			</para>

			<para>
				When you set a table as <parameter>editable</parameter>, regular fields
				will change to editing fields. When the user changes the values in the
				fields, the generated columns will be updated automatically. Putting a
				table with generated columns in editable mode has a few quirks. The
				editable mode of <classname>Table</classname> does not affect generated
				columns. You have two alternatives: either you generate the editing fields
				in the generator or, in case of formatter generators, remove the generator
				in the editable mode. The example below uses the latter approach.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Have a check box that allows the user
// to make the quantity and total columns editable.
final CheckBox editable = new CheckBox(
    "Edit the input values - calculated columns are regenerated");

editable.setImmediate(true);
editable.addClickListener(new ClickListener() {
    public void buttonClick(ClickEvent event) {
        table.setEditable(editable.booleanValue());
        
        // The columns may not be generated when we want to
        // have them editable.
        if (editable.booleanValue()) {
            table.removeGeneratedColumn("quantity");
            table.removeGeneratedColumn("total");
        } else { // Not editable
            // Show the formatted values.
            table.addGeneratedColumn("quantity",
                new ValueColumnGenerator("%.2f l"));
            table.addGeneratedColumn("total",
                new ValueColumnGenerator("%.2f e"));
        }
        // The visible columns are affected by removal
        // and addition of generated columns so we have
        // to redefine them.
        table.setVisibleColumns(new Object[] {"date", "quantity",
                 "price", "total", "consumption", "dailycost"});
    }
});]]></programlisting>

            <para>
                You will also have to set the editing fields in
                <parameter>immediate</parameter> mode to have the update occur immediately
                when an edit field loses the focus. You can set the fields in
                <parameter>immediate</parameter> mode with the a custom
                <classname>TableFieldFactory</classname>, such as the one given below,
                that just extends the default implementation to set the mode:
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class ImmediateFieldFactory extends DefaultFieldFactory {
    public Field createField(Container container,
                             Object itemId,
                             Object propertyId,
                             Component uiContext) {
        // Let the DefaultFieldFactory create the fields...
        Field field = super.createField(container, itemId,
                                        propertyId, uiContext);
        
        // ...and just set them as immediate.
        ((AbstractField)field).setImmediate(true);
        
        return field;
    }
}
...
table.setTableFieldFactory(new ImmediateFieldFactory());]]></programlisting>

			<para>
				If you generate the editing fields with the column generator, you avoid
				having to use such a field factory, but of course have to generate the
				fields for both normal and editable modes.
			</para>

			<para>
				<xref linkend="figure.ui.table.generated"/> shows a table with
				columns calculated (blue) and simply formatted (black) with column
				generators.
			</para>

			<figure xml:id="figure.ui.table.generated">
				<title>Table with Generated Columns in Normal and Editable Mode</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/table-generatedcolumns1.png"/>
					</imageobject>
				</mediaobject>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/table-generatedcolumns2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

        <section xml:id="components.table.columnformatting">
            <title>Formatting Table Columns</title>

            <para>
                The displayed values of properties shown in a table are normally formatted
                using the <methodname>toString()</methodname> method of each
                property. Customizing the format of a column can be done in several ways:
            </para>

            <itemizedlist>
                <listitem>Using <classname>ColumnGenerator</classname> to generate a
                second column that is formatted. The original column needs to be set
                invisible. See <xref
                linkend="components.table.columngenerator"/>.</listitem>

                <listitem>Using a <classname>PropertyFormatter</classname> as a proxy
                between the table and the data property. This also normally requires using
                an mediate container in the table.</listitem>

                <listitem>Overriding the default
                <methodname>formatPropertyValue()</methodname> in
                <classname>Table</classname>.</listitem>
            </itemizedlist>

            <para>
                As using a <classname>PropertyFormatter</classname> is generally much more
                awkward than overriding the
                <methodname>formatPropertyValue()</methodname>, its use is not described
                here.
            </para>

            <para>
                You can override <methodname>formatPropertyValue()</methodname> as is done
                in the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a table that overrides the default
// property (column) format
final Table table = new Table("Formatted Table") {
    @Override
    protected String formatPropertyValue(Object rowId,
            Object colId, Property property) {
        // Format by property type
        if (property.getType() == Date.class) {
            SimpleDateFormat df =
                new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
            return df.format((Date)property.getValue());
        }

        return super.formatPropertyValue(rowId, colId, property);
    }
};
        
// The table has some columns
table.addContainerProperty("Time", Date.class, null);
        
... Fill the table with data ...]]></programlisting>

            <para>
                You can also distinguish between columns by the
                <parameter>colId</parameter> parameter, which is the property ID of the
                column. <classname>DecimalFormat</classname> is useful for formatting
                decimal values.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[... in formatPropertyValue() ...
} else if ("Value".equals(pid)) {
    // Format a decimal value for a specific locale
    DecimalFormat df = new DecimalFormat("#.00",
            new DecimalFormatSymbols(locale));
    return df.format((Double) property.getValue());
}
...
table.addContainerProperty("Value", Double.class, null);]]></programlisting>

            <para>
                A table with the formatted date and decimal value columns is shown in
                <xref linkend="figure.components.table.columnformatting"/>.
            </para>

            <figure xml:id="figure.components.table.columnformatting">
                <title>Formatted Table Columns</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/table-columnformatting.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/table-columnformatting.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can use CSS for further styling of table rows, columns, and individual
                cells by using a <classname>CellStyleGenerator</classname>. It is
                described in <xref linkend="components.table.css"/>.
            </para>
        </section>

		<section xml:id="components.table.css">
			<title>CSS Style Rules</title>

            <para>
                Styling the overall style of a <classname>Table</classname> can be done
                with the following CSS rules.
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[.v-table {}
  .v-table-header-wrap {}
    .v-table-header {}
      .v-table-header-cell {}
        .v-table-resizer {} /* Column resizer handle. */
        .v-table-caption-container {}
  .v-table-body {}
    .v-table-row-spacer {}
    .v-table-table {}
      .v-table-row {}
        .v-table-cell-content {}]]></programlisting>

			<para>
				Notice that some of the widths and heights in a table are calculated
				dynamically and can not be set in CSS.
			</para>

			<section>
				<title>Setting Individual Cell Styles</title>

				<para>
					The <classname>Table.CellStyleGenerator</classname> interface allows
					you to set the CSS style for each individual cell in a table. You need
					to implement the <methodname>getStyle()</methodname>, which gets the
					row (item) and column (property) identifiers as parameters and can
					return a style name for the cell. The returned style name will be
					concatenated to prefix "<literal>v-table-cell-content-</literal>".
				</para>

                <para>
                    The <methodname>getStyle()</methodname> is called also for each row,
                    so that the <parameter>propertyId</parameter> parameter is
                    <literal>null</literal>. This allows setting a row style.
                </para>

				<para>
					Alternatively, you
					can use a <classname>Table.ColumnGenerator</classname> (see <xref
					linkend="components.table.columngenerator"/>) to generate the actual UI
					components of the cells and add style names to them.
				</para>
			
				<programlisting><?pocket-size 65% ?><![CDATA[Table table = new Table("Table with Cell Styles");
table.addStyleName("checkerboard");

// Add some columns in the table. In this example, the property
// IDs of the container are integers so we can determine the
// column number easily.
table.addContainerProperty("0", String.class, null, "", null, null);
for (int i=0; i<8; i++)
    table.addContainerProperty(""+(i+1), String.class, null,
                         String.valueOf((char) (65+i)), null, null);

// Add some items in the table.
table.addItem(new Object[]{
    "1", "R", "N", "B", "Q", "K", "B", "N", "R"}, new Integer(0));
table.addItem(new Object[]{
    "2", "P", "P", "P", "P", "P", "P", "P", "P"}, new Integer(1));
for (int i=2; i<6; i++)
    table.addItem(new Object[]{String.valueOf(i+1), 
                 "", "", "", "", "", "", "", ""}, new Integer(i));
table.addItem(new Object[]{
    "7", "P", "P", "P", "P", "P", "P", "P", "P"}, new Integer(6));
table.addItem(new Object[]{
    "8", "R", "N", "B", "Q", "K", "B", "N", "R"}, new Integer(7));
table.setPageLength(8);

// Set cell style generator
table.setCellStyleGenerator(new Table.CellStyleGenerator() {
    public String getStyle(Object itemId, Object propertyId) {
        // Row style setting, not relevant in this example.
        if (propertyId == null)
            return "green"; // Will not actually be visible

        int row = ((Integer)itemId).intValue();
        int col = Integer.parseInt((String)propertyId);
        
        // The first column.
        if (col == 0)
            return "rowheader";
        
        // Other cells.
        if ((row+col)%2 == 0)
            return "black";
        else
            return "white";
    }
});]]></programlisting>
				
				<para>
					You can then style the cells, for example, as follows:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[/* Center the text in header. */
.v-table-header-cell {
    text-align: center;
}

/* Basic style for all cells. */
.v-table-checkerboard .v-table-cell-content {
    text-align: center;
    vertical-align: middle;
    padding-top: 12px;
    width: 20px;
    height: 28px;
}

/* Style specifically for the row header cells. */
.v-table-cell-content-rowheader {
	background: #E7EDF3
     url(../default/table/img/header-bg.png) repeat-x scroll 0 0;
}

/* Style specifically for the "white" cells. */
.v-table-cell-content-white {
    background: white;
    color: black;
}

/* Style specifically for the "black" cells. */
.v-table-cell-content-black {
    background: black;
    color: white;
}]]></programlisting>

				<para>
					The table will look as shown in <xref
					linkend="figure.components.table.cell-style"/>.
				</para>

				<figure xml:id="figure.components.table.cell-style">
					<title>Cell Style Generator for a Table</title>
					<mediaobject>
						<imageobject role="fo">
							<imagedata align="center" scale="75" fileref="img/components/table-cellstylegenerator1.png"/>
						</imageobject>
						<imageobject role="html">
							<imagedata smallscale="125" align="center" fileref="img/components/table-cellstylegenerator1.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>

		<!-- programlisting><![CDATA[]]></programlisting -->
        <indexterm startref="term.components.table" class="endofrange"/>
	</section>

	<section xml:id="components.tree">
		<title><classname>Tree</classname></title>

		<para>
			The <classname>Tree</classname> component allows a natural way to represent
			data that has hierarchical relationships, such as filesystems or message
			threads. The <classname>Tree</classname> component in Vaadin works
			much like the tree components of most modern desktop user interface toolkits,
			for example in directory browsing.
		</para>

		<para>
			The typical use of the <classname>Tree</classname> component is for displaying
			a hierachical menu, like a menu on the left side of the screen, as in <xref
			linkend="figure.components.tree"/>, or for displaying filesystems or
			other hierarchical datasets. The <parameter>menu</parameter> style makes the
			appearance of the tree more suitable for this purpose.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[final Object[][] planets = new Object[][]{
        new Object[]{"Mercury"}, 
        new Object[]{"Venus"},
        new Object[]{"Earth", "The Moon"},    
        new Object[]{"Mars", "Phobos", "Deimos"},
        new Object[]{"Jupiter", "Io", "Europa", "Ganymedes",
                                "Callisto"},
        new Object[]{"Saturn",  "Titan", "Tethys", "Dione",
                                "Rhea", "Iapetus"},
        new Object[]{"Uranus",  "Miranda", "Ariel", "Umbriel",
                                "Titania", "Oberon"},
        new Object[]{"Neptune", "Triton", "Proteus", "Nereid",
                                "Larissa"}};
        
Tree tree = new Tree("The Planets and Major Moons");

/* Add planets as root items in the tree. */
for (int i=0; i<planets.length; i++) {
    String planet = (String) (planets[i][0]);
    tree.addItem(planet);
    
    if (planets[i].length == 1) {
        // The planet has no moons so make it a leaf.
        tree.setChildrenAllowed(planet, false);
    } else {
        // Add children (moons) under the planets.
        for (int j=1; j<planets[i].length; j++) {
            String moon = (String) planets[i][j];
            
            // Add the item as a regular item.
            tree.addItem(moon);
            
            // Set it to be a child.
            tree.setParent(moon, planet);
            
            // Make the moons look like leaves.
            tree.setChildrenAllowed(moon, false);
        }

        // Expand the subtree.
        tree.expandItemsRecursively(planet);
    }
}

main.addComponent(tree);]]></programlisting>

		<para>
			<xref linkend="figure.components.tree"/> below shows the tree from the code
			example in a practical situation.
		</para>

		<figure xml:id="figure.components.tree" float="center" floatstyle="before">
			<title>A <classname>Tree</classname> Component as a Menu</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/tree-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/components/tree-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can read or set the currently selected item by the value property of the
			<classname>Tree</classname> component, that is, with
			<methodname>getValue()</methodname> and
			<methodname>setValue()</methodname>. When the user clicks an item on a tree,
			the tree will receive an <classname>ValueChangeEvent</classname>, which you
			can catch with a <classname>ValueChangeListener</classname>. To receive the
			event immediately after the click, you need to set the tree as
			<classname>setImmediate(true)</classname>.
		</para>

		<para>
			The <classname>Tree</classname> component uses
			<classname>Container</classname> data sources much like the
			<classname>Table</classname> component, with the addition that it also
			utilizes hierarchy information maintained by a
			<classname>HierarchicalContainer</classname>. The contained items can be of
			any item type supported by the container. The default container and its
			<methodname>addItem()</methodname> assume that the items are strings and the
			string value is used as the item ID.
		</para>
	</section>

	<section xml:id="components.menubar">
		<title><classname>MenuBar</classname></title>

		<para>
			The <classname>MenuBar</classname> component allows creating horizontal
			dropdown menus, much like the main menu in desktop applications.
		</para>

		<figure xml:id="figure.components.menubar">
			<title>Menu Bar</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/menubar-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="85" smallscale="60%" align="center" fileref="img/components/menubar-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <simplesect xml:id="components.menubar.creation">
            <title>Creating a Menu</title>

            <para>
                The actual menu bar component is first created as follows:
            </para>

            <programlisting><![CDATA[MenuBar menubar = new MenuBar();
main.addComponent(menubar);]]></programlisting>

            <para>
                You insert the top-level menu items to the <classname>MenuBar</classname>
                object with the <methodname>addItem()</methodname> method. It takes a
                string label, an icon resource, and a command as its parameters. The icon
                and command are not required and can be <parameter>null</parameter>. The
                <methodname>addItem()</methodname> method returns a
                <classname>MenuBar.MenuItem</classname> object, which you can use to add
                sub-menu items. The <classname>MenuItem</classname> has an identical
                <methodname>addItem()</methodname> method.
            </para>

            <para>
                For example (the command is explained later):
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// A top-level menu item that opens a submenu
MenuItem drinks = barmenu.addItem("Beverages", null, null);

// Submenu item with a sub-submenu
MenuItem hots = drinks.addItem("Hot", null, null);
hots.addItem("Tea",
    new ThemeResource("icons/tea-16px.png"),    mycommand);
hots.addItem("Coffee",
    new ThemeResource("icons/coffee-16px.png"), mycommand);

// Another submenu item with a sub-submenu
MenuItem colds = drinks.addItem("Cold", null, null);
colds.addItem("Milk",      null, mycommand);
colds.addItem("Weissbier", null, mycommand);

// Another top-level item
MenuItem snacks = barmenu.addItem("Snacks", null, null);
snacks.addItem("Weisswurst", null, mycommand);
snacks.addItem("Bratwurst",  null, mycommand);
snacks.addItem("Currywurst", null, mycommand);
        
// Yet another top-level item
MenuItem servs = barmenu.addItem("Services", null, null);
servs.addItem("Car Service", null, mycommand);]]></programlisting>
        </simplesect>

        <simplesect xml:id="components.menubar.commands">
            <title>Handling Menu Selection</title>

            <para>
                Menu selection is handled by executing a <emphasis>command</emphasis> when
                the user selects an item from the menu. A command is a call-back class
                that implements the <classname>MenuBar.Command</classname> interface.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// A feedback component
final Label selection = new Label("-");
main.addComponent(selection);

// Define a common menu command for all the menu items.
MenuBar.Command mycommand = new MenuBar.Command() {
    public void menuSelected(MenuItem selectedItem) {
        selection.setValue("Ordered a " +
                           selectedItem.getText() +
                           " from menu.");
    }  
};]]></programlisting>
        </simplesect>

        <simplesect xml:id="components.menubar.menuitem" condition="web">
            <title>Menu Items</title>

            <para>
                Menu items have properties such as a caption, icon, enabled, visible, and
                description (tooltip). The meaning of these is the same as for components.
            </para>

            <para>
                Submenus are created by adding sub-items to an item with
                <methodname>addItem()</methodname> or
                <methodname>addItemBefore()</methodname>.
            </para>

            <para>
                The <emphasis>command</emphasis> property is a
                <classname>MenuBar.Command</classname> that is called when the particular
                menu item is selected. The <methodname>menuSelected()</methodname>
                callback gets the clicked menu item as its parameter.
            </para>

            <para>
                Menus can have <emphasis>separators</emphasis>, which are defined before
                or after an item with <methodname>addSeparatorBefore()</methodname> or
                <methodname>addSeparator()</methodname> on the item, respectively.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[MenuItem drinks = barmenu.addItem("Beverages", null, null);
...

// A sub-menu item after a separator
drinks.addSeparator();
drinks.addItem("Quit Drinking", null, null);]]></programlisting>


            <para>
                Enabling <emphasis>checkable</emphasis> on an menu item with
                <methodname>setCheckable()</methodname> allows the user to switch between
                checked and unchecked state by clicking on the item. You can set the
                checked state with <methodname>setChecked()</methodname>. Note that if
                such an item has a command, the checked state is not flipped
                automatically, but you need to do it explicitly.
            </para>

            <para>
                Menu items have various other properties as well, see the API
                documentation for more details.
            </para>
        </simplesect>

        <simplesect xml:id="components.menubar.css">
            <title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-menubar { }
  .v-menubar-submenu { }
    .v-menubar-menuitem { }
      .v-menubar-menuitem-caption { }
    .v-menubar-menuitem-selected { }
    .v-menubar-submenu-indicator { }]]></programlisting>
			
			<para>
				The menu bar has the overall style name
				<literal>.v-menubar</literal>. Each menu item has
				<literal>.v-menubar-menuitem</literal> style normally and additionally
				<literal>.v-menubar-selected</literal> when the item is selected, that is,
				when the mouse pointer hovers over it. The item caption is inside a
				<literal>v-menubar-menuitem-caption</literal>. In the top-level menu bar,
				the items are directly under the component element.
			</para>

            <para>
                Submenus are floating <literal>v-menubar-submenu</literal> elements outside
                the menu bar element. Therefore, you should not try to match on the component
                element for the submenu popups. In submenus, any further submenu levels are
                indicated with a <literal>v-menubar-submenu-indicator</literal>.
            </para>

            <simplesect xml:id="components.menubar.css.menuitems" condition="web">
                <title>Styling Menu Items</title>

                <para>
                    You can set the CSS style name for the menu items with
                    <methodname>setStyleName()</methodname>, just like for components. The
                    style name will be prepended with
                    <literal>v-menubar-menuitem-</literal>. As
                    <classname>MenuBar</classname> does not indicate the previous
                    selection in any way, you can do that by highlighting the previously
                    selected item. However, beware that the <literal>selected</literal>
                    style for menu items, that is,
                    <literal>v-menubar-menuitem-selected</literal>, is reserved for
                    mouse-hover indication.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[MenuBar barmenu = new MenuBar();
barmenu.addStyleName("mybarmenu");
layout.addComponent(barmenu);
        
// A feedback component
final Label selection = new Label("-");
layout.addComponent(selection);

// Define a common menu command for all the menu items
MenuBar.Command mycommand = new MenuBar.Command() {
    MenuItem previous = null;

    public void menuSelected(MenuItem selectedItem) {
        selection.setValue("Ordered a " +
                selectedItem.getText() +
                " from menu.");

        if (previous != null)
            previous.setStyleName(null);
        selectedItem.setStyleName("highlight");
        previous = selectedItem;
    }  
};
        
// Put some items in the menu
barmenu.addItem("Beverages", null, mycommand);
barmenu.addItem("Snacks", null, mycommand);
barmenu.addItem("Services", null, mycommand);]]></programlisting>

                <para>
                    You could then style the highlighting in CSS as follows:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[.mybarmenu .v-menubar-menuitem-highlight {
    background: #000040; /* Dark blue */
}]]></programlisting>
            </simplesect>
		</simplesect>
	</section>

	<section xml:id="components.upload">
		<title><classname>Upload</classname></title>
		
		<para>
			The <classname>Upload</classname> component allows a user to upload
			files to the server. It displays a file name entry box, a file
			selection button, and an upload submit button. The user can either
			write the filename in the text area or click the <guibutton>Browse</guibutton> button to
			select a file. After the file is selected, the user sends the file by
			clicking the upload submit button.
		</para>

		<para>
            Uploading requires a receiver that implements
            <interfacename>Upload.Receiver</interfacename> to provide an output stream to
            which the upload is written by the server.
        </para>

		<programlisting><?pocket-size 75% ?><![CDATA[Upload upload = new Upload("Upload it here", receiver);]]></programlisting>

		<figure xml:id="figure.ui.upload">
			<title>Upload Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="80%" align="center" fileref="img/components/upload.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can set the text of the upload button with
			<methodname>setButtonCaption()</methodname>. Note that it is difficult to
			change the caption or look of the <guibutton>Browse</guibutton> button. This
			is a security feature of web browsers. The language of the
			<guibutton>Browse</guibutton> button is determined by the browser, so if you
			wish to have the language of the <classname>Upload</classname> component
			consistent, you will have to use the same language in your application.
		</para>

		<programlisting><![CDATA[upload.setButtonCaption("Upload Now");]]></programlisting>

		<para>
            You can also hide the upload button with

            <literal>.v-upload .v-button {display: none}</literal> in theme,

            have custom logic for starting the upload, and call
            <methodname>startUpload()</methodname> to start it. If the upload component
            has <methodname>setImmediate(true)</methodname> enabled, uploading starts
            immediately after choosing the file.
        </para>

        <simplesect xml:id="components.upload.receiving">
            <title>Receiving Upload Data</title>

            <para>
                The uploaded files are typically stored as files in a file system, in
                a database, or as temporary objects in memory. The upload component
                writes the received data to an
                <classname>java.io.OutputStream</classname> so you have plenty of
                freedom in how you can process the upload content.
            </para>
		
            <para>
                To use the <classname>Upload</classname> component, you need to implement the
                <classname>Upload.Receiver</classname> interface. The
                <methodname>receiveUpload()</methodname> method of the receiver is called when
                the user clicks the submit button. The method must return an
                <classname>OutputStream</classname>. To do this, it typically creates a file
                or a memory buffer to which the stream is written. The method gets the file
                name and MIME type of the file, as reported by the browser.
            </para>

            <para>
                While uploading, the upload progress can be monitored with an
                <interfacename>Upload.ProgressListener</interfacename>. The
                <methodname>updateProgress()</methodname> method gets the number of read
                bytes and the content length as parameters. The content length is reported
                by the browser, is not reliable, and may be -1 if unknown. It is therefore
                recommended to follow the upload progress and check the allowed size in a
                progress listener. Upload can be terminated by calling
                <methodname>interruptUpload()</methodname> on the upload component. You
                may want to use a <classname>ProgressBar</classname> to visualize the
                progress, and in indeterminate mode if the content length is not known.
            </para>

            <para>
                When an upload is finished, successfully or unsuccessfully, the
                <classname>Upload</classname> component will emit the
                <classname>Upload.FinishedEvent</classname> event, which you can handle with
                an <classname>Upload.FinishedListener</classname> added to the upload
                component. The event object will include the file name, MIME type, and final
                length of the file. More specific <classname>Upload.FailedEvent</classname>
                and <classname>Upload.SucceededEvent</classname> events will be called in the
                cases where the upload failed or succeeded, respectively.
            </para>

            <para>
                The following example uploads images to <filename>/tmp/uploads</filename>
                directory in (UNIX) filesystem (the directory must exist or the upload
                fails). The component displays the uploaded image in an
                <classname>Image</classname> component.
            </para>

            <book-example eid="component.upload.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[// Show uploaded file in this placeholder
final Embedded image = new Embedded("Uploaded Image");
image.setVisible(false);

// Implement both receiver that saves upload in a file and
// listener for successful upload
class ImageUploader implements Receiver, SucceededListener {
    public File file;
    
    public OutputStream receiveUpload(String filename,
                                      String mimeType) {
        // Create upload stream
        FileOutputStream fos = null; // Stream to write to
        try {
            // Open the file for writing.
            file = new File("/tmp/uploads/" + filename);
            fos = new FileOutputStream(file);
        } catch (final java.io.FileNotFoundException e) {
            new Notification("Could not open file<br/>",
                             e.getMessage(),
                             Notification.Type.ERROR_MESSAGE)
                .show(Page.getCurrent());
            return null;
        }
        return fos; // Return the output stream to write to
    }

    public void uploadSucceeded(SucceededEvent event) {
        // Show the uploaded file in the image viewer
        image.setVisible(true);
        image.setSource(new FileResource(file));
    }
};
ImageUploader receiver = new ImageUploader(); 

// Create the upload with a caption and set receiver later
Upload upload = new Upload("Upload Image Here", receiver);
upload.setButtonCaption("Start Upload");
upload.addSucceededListener(receiver);
        
// Put the components in a panel
Panel panel = new Panel("Cool Image Storage");
Layout panelContent = new VerticalLayout();
panelContent.addComponents(upload, image);
panel.setContent(panelContent);]]></programlisting>

            <para>
                Note that the example does not check the type of the uploaded files in any
                way, which will cause an error if the content is anything else but an
                image. The program also assumes that the MIME type of the file is resolved
                correctly based on the file name extension. After uploading an image, the
                component will look as shown in <xref linkend="figure.ui.upload.example"/>.
            </para>

            <figure xml:id="figure.ui.upload.example">
                <title>Image Upload Example</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/components/upload-example.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

		<simplesect xml:id="components.upload.css">
			<title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-upload { }
  .gwt-FileUpload { }
  .v-button { }
    .v-button-wrap { }
      .v-button-caption { }]]></programlisting>

			<para>
                The <classname>Upload</classname> component has an overall
                <literal>v-upload</literal> style. The upload button has the same
                structure and style as a regular <classname>Button</classname> component.
            </para>
        </simplesect>
	</section>

	<section xml:id="components.progressbar">
		<title><classname>ProgressBar</classname></title>

		<para>
			The <classname>ProgressBar</classname> component allows displaying the
			progress of a task graphically. The progress is specified as a floating-point
			value between 0.0 and 1.0.
		</para>

		<figure xml:id="figure.components.progressbar.basic">
			<title>The Progress Bar Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="50%" align="center" fileref="img/components/progressbar-basic.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            To display upload progress with the <classname>Upload</classname> component,
            you can update the progress bar in a
            <interfacename>ProgressListener</interfacename>.
		</para>

		<para>
			When the position of a progress bar is done in a background thread, the change
			is not shown in the browser immediately. You need to use either polling or
			server push to update the browser. You can enable polling with
			<methodname>setPollInterval()</methodname> in the current UI instance. See
			<xref linkend="advanced.push"/> for instructions about using server
			push. Whichever method you use to update the UI, it is important to lock the
			user session by modifying the progress bar value inside
			<methodname>access()</methodname> call, as illustrated in the following
			example and described in <xref linkend="advanced.push.running"/>.
        </para>

		<programlisting><![CDATA[final ProgressBar bar = new ProgressBar(0.0f);
layout.addComponent(bar);
        
layout.addComponent(new Button("Increase",
    new ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        float current = bar.getValue();
        if (current < 1.0f)
            bar.setValue(current + 0.10f);
    }
}));]]></programlisting>

		<simplesect xml:id="components.progressbar.indeterminate">
			<title>Indeterminate Mode</title>

            <para>
                In the indeterminate mode, a non-progressive indicator is displayed
                continuously. The indeterminate indicator is a circular wheel in the
                built-in themes. The progress value has no meaning in the indeterminate
                mode.
            </para>

            <programlisting><![CDATA[ProgressBar bar = new ProgressBar();
bar.setIndeterminate(true);]]></programlisting>

            <figure xml:id="figure.components.progressbar.indeterminate">
                <title>Indeterminate Progress Bar</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100" align="center" fileref="img/components/progressbar-indeterminate.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

		<simplesect xml:id="components.progressbar.thread" condition="web">
			<title>Doing Heavy Computation</title>

			<para>
				The progress indicator is often used to display the progress of a heavy
				server-side computation task, often running in a background thread. The
				UI, including the progress bar, can be updated either with polling or by
				using server push. When doing so, you must ensure thread-safety, most
				easily by updating the UI inside a <methodname>UI.access()</methodname>
				call in a <interfacename>Runnable</interfacename>, as described in <xref
				linkend="advanced.push.running"/>.
            </para>

            <para>
                In the following example, we create a thread in the server to do some
                "heavy work" and use polling to update the UI. All the thread needs to do
                is to set the value of the progress bar with
                <methodname>setValue()</methodname> and the current progress is displayed
                automatically when the browser polls the server.
			</para>

            <programlisting><?pocket-size 65% ?><![CDATA[HorizontalLayout barbar = new HorizontalLayout();
layout.addComponent(barbar);
        
// Create the indicator, disabled until progress is started
final ProgressBar progress = new ProgressBar(new Float(0.0));
progress.setEnabled(false);
barbar.addComponent(progress);
        
final Label status = new Label("not running");
barbar.addComponent(status);

// A button to start progress
final Button button = new Button("Click to start");
layout.addComponent(button);

// A thread to do some work
class WorkThread extends Thread {
    // Volatile because read in another thread in access()
    volatile double current = 0.0;

    @Override
    public void run() {
        // Count up until 1.0 is reached
        while (current < 1.0) {
            current += 0.01;

            // Do some "heavy work"
            try {
                sleep(50); // Sleep for 50 milliseconds
            } catch (InterruptedException e) {}

            // Update the UI thread-safely
            UI.getCurrent().access(new Runnable() {
                @Override
                public void run() {
                    progress.setValue(new Float(current));
                    if (current < 1.0)
                        status.setValue("" +
                            ((int)(current*100)) + "% done");
                    else
                        status.setValue("all done");
                }
            });
        }
        
        // Show the "all done" for a while
        try {
            sleep(2000); // Sleep for 2 seconds
        } catch (InterruptedException e) {}

        // Update the UI thread-safely
        UI.getCurrent().access(new Runnable() {
            @Override
            public void run() {
                // Restore the state to initial
                progress.setValue(new Float(0.0));
                progress.setEnabled(false);
                        
                // Stop polling
                UI.getCurrent().setPollInterval(-1);
                
                button.setEnabled(true);
                status.setValue("not running");
            }
        });
    }
}

// Clicking the button creates and runs a work thread
button.addClickListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        final WorkThread thread = new WorkThread();
        thread.start();

        // Enable polling and set frequency to 0.5 seconds
        UI.getCurrent().setPollInterval(500);

        // Disable the button until the work is done
        progress.setEnabled(true);
        button.setEnabled(false);

        status.setValue("running...");
    }
});]]></programlisting>

            <para>
                The example is illustrated in <xref
                linkend="figure.components.progressbar.thread"/>.
            </para>

			<figure xml:id="figure.components.progressbar.thread">
				<title>Doing Heavy Work</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="50%" align="center" fileref="img/components/progressbar-thread.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </simplesect>

		<simplesect xml:id="components.progressbar.css">
			<title>CSS Style Rules</title>
				
			<programlisting><![CDATA[.v-progressbar, v-progressbar-indeterminate {}
  .v-progressbar-wrapper {}
    .v-progressbar-indicator {}]]></programlisting>

			<para>
                The progress bar has a <literal>v-progressbar</literal> base style. The
                animation is the background of the element with
                <literal>v-progressbar-wrapper</literal> style, by default an animated GIF
                image. The progress is an element with
                <literal>v-progressbar-indicator</literal> style inside the wrapper, and
                therefore displayed on top of it. When the progress element grows, it
                covers more and more of the animated background.
			</para>

            <para>
                In the indeterminate mode, the top element also has the
                <literal>v-progressbar-indeterminate</literal> style. The built-in themes
                simply display the animated GIF in the top element and have the inner
                elements disabled.
            </para>
		</simplesect>
	</section>

	<section xml:id="components.slider">
		<title><classname>Slider</classname></title>

        <para>
            The <classname>Slider</classname> is a vertical or horizontal bar that allows
            setting a numeric value within a defined range by dragging a bar handle with
            the mouse. The value is shown when dragging the handle.
        </para>

        <para>
            <classname>Slider</classname> has a number of different constructors that take
            a combination of the caption, <emphasis>minimum</emphasis> and
            <emphasis>maximum</emphasis> value, <emphasis>resolution</emphasis>, and the
            <emphasis>orientation</emphasis> of the slider.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create a vertical slider
final Slider vertslider = new Slider(1, 100);
vertslider.setOrientation(SliderOrientation.VERTICAL);]]></programlisting>

        <variablelist>
            <title>Slider Properties</title>
            <varlistentry>
                <term><emphasis>min</emphasis></term>
                <listitem>
                    <para>
                        Minimum value of the slider range. The default is 0.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>max</emphasis></term>
                <listitem>
                    <para>
                        Maximum value of the slider range. The default is 100.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>resolution</emphasis></term>
                <listitem>
                    <para>
                        The number of digits after the decimal point. The default is 0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>orientation</emphasis></term>
                <listitem>
                    <para>
                        The orientation can be either horizontal
                        (<parameter>SliderOrientation.HORIZONTAL</parameter>) or vertical
                        (<parameter>SliderOrientation.VERTICAL</parameter>). The default
                        is horizontal.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para>
            As the <classname>Slider</classname> is a field component, you can handle
            value changes with a <classname>ValueChangeListener</classname>. The value of
            the <classname>Slider</classname> field is a <classname>Double</classname>
            object.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Shows the value of the vertical slider
final Label vertvalue = new Label();
vertvalue.setSizeUndefined();

// Handle changes in slider value.
vertslider.addValueChangeListener(
    new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        double value = (Double) vertslider.getValue();

        // Use the value
        box.setHeight((float) value, Sizeable.UNITS_PERCENTAGE);
        vertvalue.setValue(String.valueOf(value));
    }
});

// The slider has to be immediate to send the changes
// immediately after the user drags the handle.
vertslider.setImmediate(true);]]></programlisting>

        <para>
            You can set the value with the <methodname>setValue()</methodname> method
            defined in <classname>Slider</classname> that takes the value as a native
            double value. The setter can throw a
            <classname>ValueOutOfBoundsException</classname>, which you must handle.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Set the initial value. This has to be set after the
// listener is added if we want the listener to handle
// also this value change.
try {
	vertslider.setValue(50.0);
} catch (ValueOutOfBoundsException e) {
}]]></programlisting>

        <para>
            Alternatively, you can use the regular
            <methodname>setValue(Object)</methodname>, which does not do bounds checking.
        </para>

        <para>
            <xref linkend="figure.components.slider.example1"/> shows both vertical (from
            the code examples) and horizontal sliders that control the size of a box. The
            slider values are displayed also in separate labels.
        </para>

        <figure xml:id="figure.components.slider.example1">
            <title>The <classname>Slider</classname> Component</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/slider-example1-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="70%" align="center" fileref="img/components/slider-example1-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <simplesect>
            <title>CSS Style Rules</title>

            <programlisting><![CDATA[.v-slider {}
.v-slider-base {}
.v-slider-handle {}]]></programlisting>

            <para>
                The enclosing style for the <classname>Slider</classname> is
                <literal>v-slider</literal>. The slider bar has style
                <literal>v-slider-base</literal>. Even though the handle is higher (for
                horizontal slider) or wider (for vertical slider) than the bar, the handle
                element is nevertheless contained within the slider bar element. The
                appearance of the handle comes from a background image defined in the
                <emphasis>background</emphasis> CSS property.
            </para>
        </simplesect>  
    </section>

    <section xml:id="components.calendar">
        <title><classname>Calendar</classname></title>

        <para>
            The <classname>Calendar</classname> component allows organizing and displaying
            calendar events. The main features of the calendar include:
        </para>

        <itemizedlist>
            <listitem>
                Monthly, weekly, and daily views
            </listitem>
            <listitem>
                Two types of events: all-day events and events with a time range
            </listitem>
            <listitem>
                Add events directly, from a <classname>Container</classname>, or with an event provider
            </listitem>
            <listitem>
                Control the range of the visible dates
            </listitem>
            <listitem>
                Selecting and editing date or time range by dragging
            </listitem>
            <listitem>
                Drag and drop events to calendar
            </listitem>
            <listitem>
                Support for localization and timezones
            </listitem>
        </itemizedlist>

        <para>
            User interaction with the calendar elements, such as date and week captions as
            well as events, is handled with event listeners. Also date/time range
            selections, event dragging, and event resizing can be listened by the
            server. The weekly view has navigation buttons to navigate forward and
            backward in time. These actions are also listened by the server. Custom
            navigation can be implemented using event handlers<phrase condition="web">, as
            described in <xref linkend="components.calendar.customizing"/></phrase>.
        </para>

        <para>
            The data source of a calendar can be practically anything, as its events are
            queried dynamically by the component. You can bind the calendar to a Vaadin
            container, or to any other data source by implementing an <emphasis>event
            provider</emphasis>.
        </para>

        <para>
            The <classname>Calendar</classname> has undefined size by default and you
            usually want to give it a fixed or relative size, for example as follows.
        </para>

        <programlisting><![CDATA[Calendar cal = new Calendar("My Calendar");
cal.setWidth("600px");
cal.setHeight("300px");]]></programlisting>

        <para>
            After creating the calendar, you need to set a time range for it, which also
            controls the view mode, and set up the data source for calendar events.
        </para>

        <section xml:id="components.calendar.daterange">
            <title>Date Range and View Mode</title>

            <para>
                The Vaadin Calendar has two types of views that are shown depending on the
                date range of the calendar. The <emphasis>weekly view</emphasis> displays
                a week by default. It can show anything between one to seven days a week,
                and is also used as a single-day view. The view mode is determined from
                the <emphasis>date range</emphasis> of the calendar, defined by a start
                and an end date. Calendar will be shown in a <emphasis>monthly
                view</emphasis> when the date range is over than one week (seven days)
                long. The date range is always calculated in an accuracy of one
                millisecond.
            </para>

            <figure xml:id="figure.components.calendar.daterange.monthly" float="center" floatstyle="before">
                <title>Monthly view with All-Day and Normal Events</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/addons/calendar-monthly.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/addons/calendar-monthly.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The monthly view, shown in <xref
                linkend="figure.components.calendar.daterange.monthly"/>, can easily be
                used to control all types of events, but it is best suited for events that
                last for one or more days. You can drag the events to move them. In the
                figure, you can see two longer events that are highlighted with a blue and
                green background color. Other markings are shorter day events that last
                less than a 24 hours. These events can not be moved by dragging in the
                monthly view.
            </para>

            <figure xml:id="figure.components.calendar.daterange.weekly" float="center" floatstyle="before">
                <title>Weekly View</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/addons/calendar-weekly.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/addons/calendar-weekly.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                In <xref linkend="figure.components.calendar.daterange.weekly"/>, you can
                see four normal day events and also all-day events at the top of the time
                line grid.
            </para>

            <para>
                In the following, we set the calendar to show only one day, which is
                the current day.
            </para>

            <programlisting><![CDATA[cal.setStartDate(new Date());
cal.setEndDate(new Date());]]></programlisting>

            <para>
                Notice that although the range we set above is actually zero time long,
                the calendar still renders the time from 00:00 to 23:59. This is normal,
                as the Vaadin Calendar is guaranteed to render at least the date range
                provided, but may expand it. This behaviour is important to notice when we
                implement our own event providers.
            </para>
        </section>

        <section xml:id="components.calendar.events">
            <title>Calendar Events</title>

            <para>
                All occurrences in a calendar are represented as
                <emphasis>events</emphasis>. You have three ways to manage the calendar
                events:
            </para>

            <itemizedlist>
                <listitem>
                    Add events directly to the <classname>Calendar</classname> object using
                    the <methodname>addEvent()</methodname>
                </listitem>
            
                <listitem>
                    Use a <interfacename>Container</interfacename> as a data source
                </listitem>
            
                <listitem>
                    Use the <emphasis>event provider</emphasis> mechanism
                </listitem>
            </itemizedlist>

            <para>
                You can add events with <methodname>addEvent()</methodname> and remove
                them with the <methodname>removeEvent()</methodname>. These methods will
                use the underlying event provider to write the modifications to the data
                source.
            </para>

            <section xml:id="components.calendar.events.types">
                <title>Event Interfaces and Providers</title>

                <para>
                    Events are handled though the
                    <interfacename>CalendarEvent</interfacename> interface. The concrete
                    class of the event depends on the specific
                    <classname>CalendarEventProvider</classname> used in the calendar.
                </para>

                <para>
                    By default, <classname>Calendar</classname> uses a
                    <classname>BasicEventProvider</classname> to provide events, which
                    uses <classname>BasicEvent</classname> instances.
                </para>

                <para>
                    Calendar does not depend on any particular data source
                    implementation. Events are queried by the
                    <classname>Calendar</classname> from the provider that just has to
                    implement the <interfacename>CalendarEventProvider</interfacename>
                    interface. It is up to the event provider that
                    <classname>Calendar</classname> gets the correct events.
                </para>

                <para>
                    You can bind any Vaadin <classname>Container</classname> to a
                    calendar, in which case a
                    <classname>ContainerEventProvider</classname> is used
                    transparently. The container must be ordered by start date and time of
                    the events. See <xref linkend="datamodel.container"/> for basic
                    information about containers.
                </para>
            </section>

            <section xml:id="components.calendar.events.details">
                <title>Event Types</title>

                <para>
                    A calendar event requires a start time and an end time. These are the
                    only mandatory properties. In addition, an event can also be set as an
                    all-day event by setting the <literal>all-day</literal> property of
                    the event. You can also set the <literal>description</literal> of an
                    event, which is displayed as a tooltip in the user interface.
                </para>

                <para>
                    If the <literal>all-day</literal> field of the event is
                    <literal>true</literal>, then the event is always rendered as an
                    all-day event. In the monthly view, this means that no start time is
                    displayed in the user interface and the event has an colored
                    background. In the weekly view, all-day events are displayed in the
                    upper part of the screen, and rendered similarly to the monthly
                    view. In addition, when the time range of an event is 24 hours or
                    longer, it is rendered as an all-day event in the monthly view.
                </para>

                <para>
                    When the time range of an event is equal or less than 24 hours, with
                    the accuracy of one millisecond, the event is considered as a normal
                    day event. Normal event has a start and end times that may be on
                    different days.
                </para>
            </section>

            <section xml:id="components.calendar.events.basic">
                <title>Basic Events</title>

                <para>
                    The easiest way to add and manage events in a calendar is to use the
                    <emphasis>basic event</emphasis> management API.  Calendar uses by
                    default a <classname>BasicEventProvider</classname>, which keeps the
                    events in memory in an internal reprensetation.
                </para>

                <para>
                    For example, the following adds a two-hour event starting from the
                    current time. The standard Java
                    <classname>GregorianCalendar</classname> provides various ways to
                    manipulate date and time.
                </para>

                <book-example eid="calendar.monthlyview" style="float: right"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[// Add a two-hour event
GregorianCalendar start = new GregorianCalendar();
GregorianCalendar end   = new GregorianCalendar();
end.add(java.util.Calendar.HOUR, 2);
calendar.addEvent(new BasicEvent("Calendar study",
        "Learning how to use Vaadin Calendar",
        start.getTime(), end.getTime()));]]></programlisting>


                <para>
                    This adds a new event that lasts for 3 hours. As the BasicEventProvider
                    and BasicEvent implement some optional event interfaces provided by the
                    calendar package, there is no need to refresh the calendar. Just create
                    events, set their properties and add them to the Event Provider.
                </para>
            </section>
        </section>

        <section xml:id="components.calendar.container">
            <title>Getting Events from a Container</title>

            <para>
                You can use any Vaadin <interfacename>Container</interfacename> that
                implements the <interfacename>Indexed</interfacename> interface as the
                data source for calendar events. The <classname>Calendar</classname> will
                listen to change events from the container as well as write changes to the
                container. You can attach a container to a <classname>Calendar</classname>
                with <methodname>setContainerDataSource()</methodname>.
            </para>

            <para>
                In the following example, we bind a
                <classname>BeanItemContainer</classname> that contains built-in
                <classname>BasicEvent</classname> events to a calendar.
            </para>

            <book-example eid="calendar.beanitemcontainer" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// Create the calendar
Calendar calendar = new Calendar("Bound Calendar");

// Use a container of built-in BasicEvents
final BeanItemContainer<BasicEvent> container =
    new BeanItemContainer<BasicEvent>(BasicEvent.class);        

// Create a meeting in the container
container.addBean(new BasicEvent("The Event", "Single Event",
            new GregorianCalendar(2012,1,14,12,00).getTime(),
            new GregorianCalendar(2012,1,14,14,00).getTime()));

// The container must be ordered by the start time. You
// have to sort the BIC every time after you have added
// or modified events.
container.sort(new Object[]{"start"}, new boolean[]{true});

calendar.setContainerDataSource(container, "caption",
    "description", "start", "end", "styleName");]]></programlisting>

            <para>
                The container must either use the default property IDs for event data, as
                defined in the <interfacename>CalendarEvent</interfacename> interface, or
                provide them as parameters for the
                <methodname>setContainerDataSource()</methodname> method, as we did in the
                example above.
            </para>

            <section xml:id="components.calendar.container.sorting">
                <title>Keeping the Container Ordered</title>

                <para>
                    The events in the container <emphasis>must</emphasis> be kept ordered
                    by their start date/time.  Failing to do so may and will result in the
                    events not showing in the calendar properly.
                </para>

                <para>
                    Ordering depends on the container. With some containers, such as
                    <classname>BeanItemContainer</classname>, you have to sort the
                    container explicitly every time after you have added or modified
                    events, usually with the <methodname>sort()</methodname> method, as we
                    did in the example above. Some container, such as
                    <classname>JPAContainer</classname>, keep the in container
                    automatically order if you provide a sorting rule.
                </para>

                <para>
                    For example, you could order a <classname>JPAContainer</classname> by
                    the following rule, assuming that the start date/time is held in the
                    <literal>startDate</literal> property:
                </para>

                <book-example eid="calendar.jpacontainer" style="float: right"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[// The container must be ordered by start date. For JPAContainer
// we can just set up sorting once and it will stay ordered.
container.sort(new String[]{"startDate"}, new boolean[]{true});]]></programlisting>

            </section>

            <section xml:id="components.calendar.container.customization" condition="web">
                <title>Delegation of Event Management</title>

                <para>
                    Setting a container as the calendar data source with
                    <methodname>setContainerDataSource()</methodname> automatically switches
                    to <classname>ContainerEventProvider</classname>. You can manipulate the
                    event data through the API in <classname>Calendar</classname> and the user
                    can move and resize event through the user interface. The event provider
                    delegates all such calendar operations to the container.
                </para>

                <para>
                    If you add events through the <classname>Calendar</classname> API,
                    notice that you may be unable to create events of the type held in the
                    container or adding them requires some container-specific
                    operations. In such case, you may need to customize the
                    <methodname>addEvent()</methodname> method.
                </para>

                <para>
                    For example, <classname>JPAContainer</classname> requires adding new
                    items with <methodname>addEntity()</methodname>. You could first add
                    the entity to the container or entity manager directly and then pass
                    it to the <methodname>addEvent()</methodname>. That does not, however,
                    work if the entity class does not implement
                    <interfacename>CalendarEvent</interfacename>. This is actually the
                    case always if the property names differ from the ones defined in the
                    interface. You could handle creating the underlying entity objects in
                    the <methodname>addEvent()</methodname> as follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a JPAContainer
final JPAContainer<MyCalendarEvent> container =
    JPAContainerFactory.make(MyCalendarEvent.class,
                             "book-examples");

// Customize the event provider for adding events
// as entities
ContainerEventProvider cep =
        new ContainerEventProvider(container) {
    @Override
    public void addEvent(CalendarEvent event) {
        MyCalendarEvent entity = new MyCalendarEvent(
            event.getCaption(), event.getDescription(),
            event.getStart(), event.getEnd(),
            event.getStyleName());
        container.addEntity(entity);
    }
}

// Set the container as the data source
calendar.setEventProvider(cep);
        
// Now we can add events to the database through the calendar
BasicEvent event = new BasicEvent("The Event", "Single Event",
    new GregorianCalendar(2012,1,15,12,00).getTime(),
    new GregorianCalendar(2012,1,15,14,00).getTime());
calendar.addEvent(event);]]></programlisting>
            </section>
        </section>

        <section xml:id="components.calendar.eventprovider" condition="web">
            <title>Implementing an Event Provider</title>

            <para>
                If the two simple ways of storing and managing events for a calendar are
                not enough, you may need to implement a custom event provider. It is the
                most flexible way of providing events. You need to attach the event
                provider to the <classname>Calendar</classname> using the
                <methodname>setEventProvider()</methodname> method.
            </para>

            <para>
                Event queries are done by asking the event provider for all the events
                between two given dates. The range of these dates is guaranteed to be at
                least as long as the start and end dates set for the component. The
                component can, however, ask for a longer range to ensure correct
                rendering. In particular, all start dates are expanded to the start of the
                day, and all end dates are expanded to the end of the day.
            </para>

            <section xml:id="components.calendar.eventprovider.customevents">
                <title>Custom Events</title>
            
                <para>
                    An event provider could use the built-in
                    <classname>BasicEvent</classname>, but it is usually more proper to define
                    a custom event type that is bound directly to the data source. Custom
                    events may be useful for some other purposes as well, such as when you
                    need to add extra information to an event or customize how it is acquired.
                </para>

                <para>
                    Custom events must implement the <interfacename>CalendarEvent</interfacename>
                    interface or extend an existing event class. The built-in
                    <classname>BasicEvent</classname> class should serve as a good example of
                    implementing simple events. It keeps the data in member variables.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class BasicEvent
       implements CalendarEventEditor, EventChangeNotifier {
   ...

   public String getCaption() {
        return caption;
    }

    public String getDescription() {
        return description;
    }

    public Date getEnd() {
        return end;
    }

    public Date getStart() {
        return start;
    }

    public String getStyleName() {
        return styleName;
    }

    public boolean isAllDay() {
        return isAllDay;
    }

    public void setCaption(String caption) {
        this.caption = caption;
        fireEventChange();
    }

    public void setDescription(String description) {
        this.description = description;
        fireEventChange();
    }

    public void setEnd(Date end) {
        this.end = end;
        fireEventChange();
    }

    public void setStart(Date start) {
        this.start = start;
        fireEventChange();
    }

    public void setStyleName(String styleName) {
        this.styleName = styleName;
        fireEventChange();
    }

    public void setAllDay(boolean isAllDay) {
        this.isAllDay = isAllDay;
        fireEventChange();
    }

    public void addEventChangeListener(
            EventChangeListener listener) {
        ...
    }
    
    public void removeListener(EventChangeListener listener) {
        ...
    }

    protected void fireEventChange() {...}
}]]></programlisting>

                <para>
                    You may have noticed that there was some additional code in the
                    <classname>BasicEvent</classname> that was not in the
                    <interfacename>CalendarEvent</interfacename> interface. Namely
                    <classname>BasicEvent</classname> also implements two additional
                    interfaces:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><interfacename>CalendarEditor</interfacename></term>
                        <listitem>
                            <para>
                                This interface defines setters for all the fields, and is
                                required for some of the default handlers to work.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><interfacename>EventChangeNotifier</interfacename></term>
                        <listitem>
                            <para>
                                This interface adds the possibility to listen for changes in
                                the event, and enables the <classname>Calendar</classname> to
                                render the changes immediately.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                
                <para>
                    The start time and end time are mandatory, but caption, description,
                    and style name are not. The style name is used as a part of the CSS
                    class name for the HTML DOM element of the event.
                </para>

                <para>
                    In addition to the basic event interfaces, you can enhance the
                    functionality of your event and event provider classes by using the
                    <classname>EventChange</classname> and
                    <classname>EventSetChange</classname> events. They let the
                    <classname>Calendar</classname> component to know about changes in
                    events and update itself accordingly. The
                    <classname>BasicEvent</classname> and
                    <classname>BasicEventProvider</classname> examples given earlier
                    include a simple implementation of these interfaces.
                </para>
            </section>

            <section xml:id="components.calendar.eventprovider.eventprovider">
                <title>Implementing the Event Provider</title>

                <para>
                    An event provider needs to implement the
                    <interfacename>CalendarEventProvider</interfacename> interface. It has
                    only one method to be implemented. Whenever the calendar is painted,
                    <methodname>getEvents(Date, Date)</methodname> method is called and it
                    must return a list of events between the given start and end time.
                </para>

                <para>
                    The following example implementation returns only one example
                    event. The event starts from the current time and is five hours long.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class MyEventProvider implements CalendarEventProvider{
    public List<Event> getEvents(Date startDate, Date endDate){
        List<Event> events = new ArrayList<Event>();
        GregorianCalendar cal = new GregorianCalendar();
        cal.setTime(new Date());

        Date start = cal.getTime();
        cal.add(GregorianCalendar.HOUR, 5);
        Date end = cal.getTime();
        BasicEvent event = new BasicEvent();
        event.setCaption("My Event");
        event.setDescription("My Event Description");
        event.setStart(start);
        event.setEnd(end);
        events.add(event);

        return events;
    }
}]]></programlisting>

                <para>
                    It is important to notice that the <classname>Calendar</classname> may
                    query for dates beyond the range defined by start date and end
                    date. Particularly, it may expand the date range to make sure the user
                    interface is rendered correctly.
                </para>
            </section>
        </section>

        <section xml:id="components.calendar.appearance" condition="web">
            <title>Styling a Calendar</title>

            <para>
                Configuring the appearance of the Vaadin Calendar component is one of the
                basic tasks. At the least, you need to consider its sizing in your user
                interface. You also quite probably want to use some color or colors for
                events.
            </para>

            <section xml:id="components.calendar.appearance.sizing">
                <title>Sizing</title>

                <para>
                    The Calendar supports component sizing as usual for defined (fixed or
                    relative) sizes. When using an undefined size for the calendar, all
                    the sizes come from CSS. In addition, when the height is undefined, a
                    scrollbar is displayed in the weekly view to better fit the cells to
                    the user interface.
                </para>

                <para>
                    Below is a list of style rules that define the size of a Calendar with
                    undefined size (these are the defaults):
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.v-calendar-month-sizedheight .v-calendar-month-day {
	height: 100px;
}

.v-calendar-month-sizedwidth .v-calendar-month-day {
	width: 100px;
}

.v-calendar-header-month-Hsized .v-calendar-header-day {
	width: 101px;
}

/* for IE */
.v-ie6 .v-calendar-header-month-Hsized .v-calendar-header-day {
	width: 104px;
}

/* for others */
.v-calendar-header-month-Hsized td:first-child {
	padding-left: 21px;
}

.v-calendar-header-day-Hsized {
	width: 200px;
}

.v-calendar-week-numbers-Vsized .v-calendar-week-number {
	height: 100px;
	line-height: 100px;
}

.v-calendar-week-wrapper-Vsized {
	height: 400px;
	overflow-x: hidden !important;
}

.v-calendar-times-Vsized .v-calendar-time {
	height: 38px;
}

.v-calendar-times-Hsized .v-calendar-time {
	width: 42px;
}

.v-calendar-day-times-Vsized .v-slot,.v-calendar-day-times-Vsized .v-slot-even {
	height: 18px;
}

.v-calendar-day-times-Hsized, .v-calendar-day-times-Hsized .v-slot,.v-calendar-day-times-Hsized .v-slot-even {
	width: 200px;
}]]></programlisting>
            </section>

            <section xml:id="components.calendar.appearance.event-style">
                <title>Event Style</title>

                <para>
                    Events can be styled with CSS by setting them a <emphasis>style name
                    suffix</emphasis>. The suffix is retrieved with the
                    <methodname>getStyleName()</methodname> method in
                    <interfacename>CalendarEvent</interfacename>. If you use
                    <classname>BasicEvent</classname> events, you can set the suffix with
                    <methodname>setStyleName()</methodname>.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[BasicEvent event = new BasicEvent("Wednesday Wonder", ... );
event.setStyleName("mycolor");
calendar.addEvent(event);]]></programlisting>

                <para>
                    Suffix <literal>mycolor</literal> would create
                    <literal>v-calendar-event-mycolor</literal> class for regular events
                    and <literal>v-calendar-event-mycolor-add-day</literal> for all-day
                    events. You could style the events with the following rules:
                </para>

                <programlisting><?pocket-size 65% ?>.v-calendar .v-calendar-event-mycolor {}
.v-calendar .v-calendar-event-mycolor-all-day {}
.v-calendar .v-calendar-event-mycolor .v-calendar-event-caption {}
.v-calendar .v-calendar-event-mycolor .v-calendar-event-content {}</programlisting>

            </section>
        </section>

        <section xml:id="components.calendar.visible-hours-days" condition="web">
            <title>Visible Hours and Days</title>

            <para>
                As we saw in <xref linkend="components.calendar.daterange"/>, you can set the
                range of dates that are shown by the Calendar. But what if you wanted to
                show the entire month but hide the weekends? Or show only hours from 8 to
                16 in the weekly view? The <methodname>setVisibleDays()</methodname> and
                <methodname>setVisibleHours()</methodname> methods allow you to do that.
            </para>

            <programlisting><?pocket-size 75% ?>calendar.setVisibleDays(1,5);   // Monday to Friday
calendar.setVisibleHours(0,15); // Midnight until 4 pm</programlisting>

            <para>
                After the above settings, only weekdays from Monday to Friday would be
                shown. And when the calendar is in the weekly view, only the time range
                from 00:00 to 16:00 would be shown.
            </para>

            <para>
                Note that the excluded times are never shown so you should take care when
                setting the date range. If the date range contains only dates / times that
                are excluded, nothing will be displayed. Also note that even if a date is
                not rendered because these settings, the event provider may still be
                queried for events for that date.
            </para>
        </section>

        <section xml:id="components.calendar.drag-and-drop" condition="web">
            <title>Drag and Drop</title>

            <para>
                Vaadin Calendar can act as a drop target for drag and drop, described in
                <xref linkend="advanced.dragndrop"/>. With the functionality, the user
                could drag events, for example, from a table to a calendar.
            </para>

            <para>
                To support dropping, a <classname>Calendar</classname> must have a drop
                handler. When the drop handler is set, the days in the monthly view and
                the time slots in the weekly view can receive drops. Other locations, such
                as day names in the weekly view, can not currently receive drops.
            </para>

            <para>
                Calendar uses its own implementation of
                <interfacename>TargetDetails</interfacename>:
                <classname>CalendarTargetdetails</classname>. It holds information about
                the the drop location, which in the context of
                <classname>Calendar</classname> means the date and time. The drop target
                location can be retrieved via the <methodname>getDropTime()</methodname>
                method. If the drop is done in the monthly view, the returned date does
                not have exact time information. If the drop happened in the weekly view,
                the returned date also contains the start time of the slot.
            </para>

            <para>
                Below is a short example of creating a drop handler and using the drop
                information to create a new event:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[private Calendar createDDCalendar() {
  Calendar calendar = new Calendar();
  calendar.setDropHandler(new DropHandler() {
    public void drop(DragAndDropEvent event) {
      CalendarTargetDetails details = 
              (CalendarTargetDetails) event.getTargetDetails();
      
      TableTransferable transferable = 
              (TableTransferable) event.getTransferable();

      createEvent(details, transferable);
      removeTableRow(transferable);
    }

    public AcceptCriterion getAcceptCriterion() {
      return AcceptAll.get();
    }

  });

  return calendar;
}


protected void createEvent(CalendarTargetDetails details,
  TableTransferable transferable) {
  Date dropTime = details.getDropTime();
  java.util.Calendar timeCalendar = details.getTargetCalendar()
                                    .getInternalCalendar();
  timeCalendar.setTime(dropTime);
  timeCalendar.add(java.util.Calendar.MINUTE, 120);
  Date endTime = timeCalendar.getTime();

  Item draggedItem = transferable.getSourceComponent().
                            getItem(transferable.getItemId());

  String eventType = (String)draggedItem.
                            getItemProperty("type").getValue();

  String eventDescription = "Attending: "
             + getParticipantString(
                 (String[]) draggedItem.
                   getItemProperty("participants").getValue());

  BasicEvent newEvent = new BasicEvent();
  newEvent.setAllDay(!details.hasDropTime());
  newEvent.setCaption(eventType);
  newEvent.setDescription(eventDescription);
  newEvent.setStart(dropTime);
  newEvent.setEnd(endTime);

  BasicEventProvider ep = (BasicEventProvider) details
                       .getTargetCalendar().getEventProvider();
  ep.addEvent(newEvent);
}]]></programlisting>
        </section>

        <section xml:id="components.calendar.contextmenu" condition="web">
            <title>Using the Context Menu</title>
            
            <para>
                Vaadin Calendar allows the use of context menu (mouse right-click) to
                manage events. As in other context menus in Vaadin, the menu items are
                handled in Vaadin as <emphasis>actions</emphasis> by an <emphasis>action
                handler</emphasis>. To enable a context menu, you have to implement a
                Vaadin <interfacename>Action.Handler</interfacename> and add it to the
                calendar with <methodname>addActionHandler()</methodname>.
            </para>

            <para>
                An action handler must implement two methods:
                <methodname>getActions()</methodname> and
                <methodname>handleAction()</methodname>. The
                <methodname>getActions()</methodname> is called for each day displayed in
                the calendar view. It should return a list of allowed actions for that
                day, that is, the items of the context menu. The
                <parameter>target</parameter> parameter is the context of the click - a
                <classname>CalendarDateRange</classname> that spans over the day. The
                <parameter>sender</parameter> is the <classname>Calendar</classname>
                object.
            </para>

            <para>
                The <methodname>handleActions()</methodname> receives the target context in
                the <parameter>target</parameter>. If the context menu was opened on an event,
                the target is the <interfacename>Event</interfacename> object, otherwise it is
                a <classname>CalendarDateRange</classname>.
            </para>
        </section>

        <section xml:id="components.calendar.localization" condition="web">
            <title>Localization and Formatting</title>

            <section xml:id="components.calendar.localization.locale">
                <title>Setting the Locale and Time Zone</title>

                <para>
                    Month and weekday names are shown in the language of the locale
                    setting of the <classname>Calendar</classname>. The translations are
                    acquired from the standard Java locale data. By default,
                    <classname>Calendar</classname> uses the system default locale for its
                    internal calendar, but you can change it with
                    <methodname>setLocale(Locale locale)</methodname>. Setting the locale
                    will update also other location specific date and time settings, such
                    as the first day of the week, time zone, and time format. However,
                    time zone and time format can be overridden by settings in the
                    <classname>Calendar</classname>.
                </para>

                <para>
                    For example, the following would set the language to US English:
                </para>

                <programlisting><![CDATA[cal.setLocale(Locale.US);]]></programlisting>

                <para>
                    The locale defines the default time zone. You can change it with the
                    <methodname>setTimeZone()</methodname> method, which takes a
                    <classname>java.util.TimeZone</classname> object as its parameter. Setting
                    timezone to null will reset timezone to the locale default.
                </para>

                <para>
                    For example, the following would set the Finnish time zone, which is EET
                </para>

                <programlisting><![CDATA[cal.setTimeZone(TimeZone.getTimeZone("Europe/Helsinki"));]]></programlisting>
            </section>

            <section xml:id="components.calendar.localization.datecaption">
                <title>Time and Date Caption Format</title>

                <para>
                    The time may be shown either in 24 or 12 hour format. The default
                    format is defined by the locale, but you can change it with the
                    <methodname>setTimeFormat()</methodname> method. Giving a
                    <literal>null</literal> setting will reset the time format to the
                    locale default.
                </para>

                <programlisting><![CDATA[cal.setTimeFormat(TimeFormat.Format12H);]]></programlisting>

                <para>
                    You can change the format of the date captions in the week view with
                    the <methodname>setWeeklyCaptionFormat(String
                    dateFormatPattern)</methodname> method. The date format pattern should
                    follow the format of the standard Java
                    <classname>java.text.SimpleDateFormat</classname> class.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><![CDATA[cal.setWeeklyCaptionFormat("dd-MM-yyyy");]]></programlisting>
            </section>
        </section>

        <section xml:id="components.calendar.customizing" condition="web">
            <title>Customizing the Calendar</title>

            <para>
                In this section, we give a tutorial for how to make various basic
                customizations of the Vaadin Calendar. The event provider and styling was
                described earlier, so now we concentrate on other features of the Calendar
                API.
            </para>

            <section xml:id="components.calendar.customizing.overview">
                <title>Overview of Handlers</title>

                <para>
                    Most of the handlers related to calendar events have sensible default
                    handlers. These are found in the
                    <package>com.vaadin.ui.handler</package> package. The default handlers
                    and their functionalities are described below.
                </para>

                <itemizedlist>
                    <listitem>
                        <classname>BasicBackwardHandler</classname>. Handles clicking the
                        back-button of the weekly view so that the viewed month is changed
                        to the previous one.
                    </listitem>

                    <listitem>
                        <classname>BasicForwardHandler</classname>. Handles clicking the
                        forward-button of the weekly view so that the viewed month is
                        changed to the next one.
                    </listitem>

                    <listitem>
                        <classname>BasicWeekClickHandler</classname>. Handles clicking the
                        week numbers int the monthly view so that the viewable date range
                        is changed to the clicked week.
                    </listitem>

                    <listitem>
                        <classname>BasicDateClickHandler</classname>. Handles clicking the
                        dates on both the monthly view and the weekly view. Changes the
                        viewable date range so that only the clicked day is visible.
                    </listitem>

                    <listitem>
                        <classname>BasicEventMoveHandler</classname>. Handles moving the
                        events in both monthly view and the weekly view. Events can be
                        moved and their start and end dates are changed correctly, but
                        only if the event implements
                        <classname>CalendarEventEditor</classname> (implemented by
                        <classname>BasicEvent</classname>).
                    </listitem>

                    <listitem>
                        <classname>BasicEventResizeHandler</classname>. Handles resizing
                        the events in the weekly view. Events can be resized and their
                        start and end dates are changed correctly, but only if the event
                        implements <classname>CalendarEventEditor</classname> (implemented
                        by the <classname>BasicEvent</classname>).
                    </listitem>
                </itemizedlist>

                <para>
                    All of these handlers are automatically set when creating a new
                    <classname>Calendar</classname>. If you wish to disable some of the
                    default functionality, you can simply set the corresponding handler to
                    <literal>null</literal>. This will prevent the functionality from ever
                    appearing on the user interface. For example, if you set the
                    <classname>EventMoveHandler</classname> to <literal>null</literal>, the
                    user will be unable to move events in the browser.
                </para>
            </section>

            <section xml:id="components.calendar.customizing.creating">
                <title>Creating a Calendar</title>

                <para>
                    Let us first create a new <classname>Calendar</classname>
                    instance. Here we use our own event provider, the
                    <classname>MyEventProvider</classname> described in <xref
                    linkend="components.calendar.eventprovider.eventprovider"/>.
                </para>

                <programlisting><![CDATA[Calendar cal = new Calendar(new MyEventProvider());]]></programlisting>

                <para>
                    This initializes the Calendar. To customize the viewable date range,
                    we must set a start and end date to it.
                </para>

                <para>
                    There is only one visible event in the timeline, starting from the
                    current time. That is what our event provider passes to the
                    client. <!-- TODO See the figure 3. -->
                </para>

                <!-- TODO Figure 3: Weekly view with  a single visible day and one event. -->

                <para>
                    It would be nice to also be able to control the navigation forward and
                    backward. The default navigation is provided by the default handlers,
                    but perhaps we want to restrict the users so they can only navigate
                    dates in the current year. Maybe we also want to pose some other
                    restrictions to the clicking week numbers and dates.
                </para>

                <para>
                    These restrictions and other custom logic can be defined with custom
                    handlers. You can find the handlers in the
                    <package>com.vaadin.addon.calendar.ui.handler</package> package and
                    they can be easily extended. Note that if you don not want to extend
                    the default handlers, you are free to implement your own. The
                    interfaces are described in
                    <interfacename>CalendarComponentEvents</interfacename>.
                </para>
            </section>
        </section>

        <section xml:id="components.calendar.navigation">
            <title>Backward and Forward Navigation</title>

            <para>
                Vaadin Calendar has only limited built-in navigation support. The weekly
                view has navigation buttons in the top left and top right corners. <!--
                TODO See the figure 4. -->
            </para>

            <!-- TODO Figure 4: Backward and forward navigation buttons. -->
            <para>
                You can handle backward and forward navigation with a
                <interfacename>BackwardListener</interfacename> and
                <interfacename>ForwardListener</interfacename>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicBackwardHandler() {
  protected void setDates(BackwardEvent event,
                          Date start, Date end) {

      java.util.Calendar calendar = event.getComponent()
                                    .getInternalCalendar();
      if (isThisYear(calendar, end) 
           && isThisYear(calendar, start)) {
        super.setDates(event, start, end);
      }
  }});]]></programlisting>

            <para>
                The forward navigation handler can be implemented in the same way. The
                example handler restricts the dates to the current year.
            </para>
        </section>

        <section xml:id="components.calendar.dateclick" condition="web">
            <title>Date Click Handling</title>

            <para>
                By default, clicking a date either in month or week view switches to
                single-day view. The date click event is handled by a
                <interfacename>DateClickHandler</interfacename>.
            </para>

            <para>
                The following example handles click events so that when the user clicks
                the date header in the weekly view, it will switch to single-day view, and
                in the single-day view switch back to the weekly view.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicDateClickHandler() {
  public void dateClick(DateClickEvent event) {
    Calendar cal = event.getComponent();
    long currentCalDateRange = cal.getEndDate().getTime()
                               - cal.getStartDate().getTime();
    
    if (currentCalDateRange < VCalendar.DAYINMILLIS) {
      // Change the date range to the current week
      cal.setStartDate(cal.getFirstDateForWeek(event.getDate()));
      cal.setEndDate(cal.getLastDateForWeek(event.getDate()));

    } else {
      // Default behaviour, change date range to one day
      super.dateClick(event);
    }
  }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.weekclick" condition="web">
            <title>Handling Week Clicks</title>

            <para>
                The monthly view displays week numbers for each week row on the left side
                of the date grid. The week number are clickable and you can handle the
                click events by setting a <interfacename>WeekClickHandler</interfacename>
                for the <classname>Calendar</classname> object. The default handler
                changes the date range to be the clicked week.
            </para>

            <para>
                In the following example, we add a week click handler that changes the
                date range of the calendar to one week only if the start and end dates
                of the week are in the current month.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicWeekClickHandler() {
    protected void setDates(WeekClick event,
                          Date start, Date end) {
        java.util.Calendar calendar = event.getComponent()
                                  .getInternalCalendar();
        if (isThisMonth(calendar, start) 
            && isThisMonth(calendar,  end)) {
            super.setDates(event, start, end);
        }
    }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.eventclick" condition="web">
            <title>Handling Event Clicks</title>

            <para>
                The calendar events in all views are are clickable. There is no
                default handler. Just like the date and week click handlers, event
                click handling is enabled by setting an
                <interfacename>EventClickHandler</interfacename> for the
                <classname>Calendar</classname> object.
            </para>

            <para>
                You can get hold of the clicked event by the
                <methodname>getCalendarEvent()</methodname> method in the
                <classname>EventClick</classname> object passed to the handler, as
                shown in the following example.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new EventClickHandler() {
    public void eventClick(EventClick event) {
        BasicEvent e = (BasicEvent) event.getCalendarEvent();

        // Do something with it
        new Notification("Event clicked: " + e.getCaption(),
            e.getDescription()).show(Page.getCurrent());
    }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.eventdrag" condition="web">
            <title>Event Dragging</title>

            <para>
                The user can drag an event to change its position in time. The default
                handler sets the start and end time of the event accordingly. You can do
                many things with a custom move handler, such as restrict moving events.
            </para>

            <para>
                In the following example, we add a
                <interfacename>EventMoveHandler</interfacename> to a
                <classname>Calendar</classname>. The event handler updates the new
                position to the datasource, but only if the new dates are in the current
                month. This requires making some changes to the event provider class.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicEventMoveHandler() {
  private java.util.Calendar javaCalendar;

  public void eventMove(MoveEvent event) {
    javaCalendar = event.getComponent().getInternalCalendar();
    super.eventMove(event);
  }
  
  protected void setDates(CalendarEventEditor event,
                          Date start, Date end) {
    if (isThisMonth(javaCalendar, start)
        && isThisMonth(javaCalendar, end)) {
      super.setDates(event, start, end);
    }
  }
});]]></programlisting>

            <para>
                For the above example to work, the example event provider presented
                earlier needs to be changed slightly so that it doesn't always create a
                new event when <methodname>getEvents()</methodname> is called.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public static class MyEventProvider
              implements CalendarEventProvider {
  private List<CalendarEvent> events =
        new ArrayList<CalendarEvent>();

  public MyEventProvider() {
    events = new ArrayList<CalendarEvent>();
    GregorianCalendar cal = new GregorianCalendar();
    cal.setTime(new Date());

    Date start = cal.getTime();
    cal.add(GregorianCalendar.HOUR, 5);
    Date end = cal.getTime();
    BasicEvent event = new BasicEvent();
    event.setCaption("My Event");
    event.setDescription("My Event Description");
    event.setStart(start);
    event.setEnd(end);
    events.add(event);
  }

  public void addEvent(CalendarEvent BasicEvent) {
    events.add(BasicEvent);
  }

  public List<CalendarEvent> getEvents(Date startDate, 
                                       Date endDate) {
    return events;
  }
}]]></programlisting>

            <para>
                After these changes, the user can move events around as earlier, but
                dropping an event, the start and end dates are checked by the
                server. Note that as the server-side must move the event in order for it
                to render to the place it was dropped. The server can also reject moves by
                not doing anything when the event is received.
            </para>
        </section>

        <section xml:id="components.calendar.dragselection" condition="web">
            <title>Handling Drag Selection</title>

            <para>
                Drag selection works both in the monthly and weekly views. To listen for
                drag selection, you can add a
                <interfacename>RangeSelectListener</interfacename> to the
                <classname>Calendar</classname>. There is no default handler for range
                select.
            </para>

            <para>
                In the code example below, we create an new event when any date range is
                selected. Drag selection opens a window where the user is asked for a
                caption for the new event. After confirming, the new event is be passed to
                the event provider and calendar is updated. Note that as our example event
                provider and event classes do not implement the event change interface, we
                must refresh the <classname>Calendar</classname> manually after changing
                the events.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new RangeSelectHandler() {
  public void rangeSelect(RangeSelectEvent event) {
    BasicEvent calendarEvent = new BasicEvent();
    calendarEvent.setStart(event.getStart());
    calendarEvent.setEnd(event.getEnd());

    // Create popup window and add a form in it.
    VerticalLayout layout = new VerticalLayout();
    layout.setMargin(true);
    layout.setSpacing(true);

    final Window w = new Window(null, layout);
    ...

    // Wrap the calendar event to a BeanItem 
    // and pass it to the form
    final BeanItem<CalendarEvent> item = 
                         new BeanItem<CalendarEvent>(myEvent);

    final Form form = new Form();
    form.setItemDataSource(item);
    ...

    layout.addComponent(form);

    HorizontalLayout buttons = new HorizontalLayout();
    buttons.setSpacing(true);
    buttons.addComponent(new Button("OK", new ClickListener() {

        public void buttonClick(ClickEvent event) {
            form.commit();

            // Update event provider's data source
            provider.addEvent(item.getBean());

            UI.getCurrent().removeWindow(w);
        }
    }));

    ...
  }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.eventresizing" condition="web">
            <title>Resizing Events</title>

            <para>
                The user can resize an event by dragging from both ends to change its
                start or end time. This offers a convenient way to change event times
                without the need to type anything. The default resize handler sets the
                start and end time of the event according to the resize.
            </para>

            <para>
                In the example below, we set a custom handler for resize events. The
                handler prevents any event to be resized over 12 hours in length. Note
                that this does not prevent the user from resizing an event over 12 hours
                in the client. The resize will just be corrected by the server.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicEventResizeHandler() {
  private static final long twelveHoursInMs = 12*60*60*1000;

  protected void setDates(CalendarEventEditor event, 
                          Date start, Date end) {
    long eventLength = end.getTime() - start.getTime();
    if (eventLength <= twelveHoursInMs) {
      super.setDates(event, start, end);
    }
  }
});]]></programlisting>
        </section>
    </section>

	<section xml:id="components.customcomponent">
		<title>Composition with <classname>CustomComponent</classname></title>

		<!-- UNFINISHED: Check that this is up-to-date. Probably is. -->

		<para>
			The ease of making new user interface components is one of the core features
			of Vaadin. Typically, you simply combine existing built-in components to
			produce composite components. In many applications, such composite components
			make up the majority of the user interface.
		</para>

		<para>
            As described earlier in <xref
            linkend="application.architecture.composition"/>, you have two basic ways to
            create a composite - either by using a layout component or the
            <classname>CustomComponent</classname>, which typically wraps around a layout
            component. The benefit of wrapping a layout composite in
            <classname>CustomComponent</classname> is mainly encapsulation - hiding the
            implementation details of the composition. Otherwise, a user of the composite
            might rely on the internal implementation details, such as the layout class.
        </para>

        <para>
            To create a composite, you need to inherit the
            <classname>CustomComponent</classname> and set the <emphasis>composition
            root</emphasis> component in the constructor. The composition root is
            typically a layout component that contains other components.
        </para>

        <para>
            For example:
        </para>

        <!-- TODO Invalid use of addComponent() -->
        <programlisting><?pocket-size 65% ?><![CDATA[class MyComposite extends CustomComponent {
    public MyComposite(String message) {
        // A layout structure used for composition
        Panel panel = new Panel("My Custom Component");
        panel.setContent(new VerticalLayout());
        
        // Compose from multiple components
        Label label = new Label(message);
        label.setSizeUndefined(); // Shrink
        panel.addComponent(label);
        panel.addComponent(new Button("Ok"));

        // Set the size as undefined at all levels
        panel.getContent().setSizeUndefined();
        panel.setSizeUndefined();
        setSizeUndefined();

        // The composition root MUST be set
        setCompositionRoot(panel);
    }
}]]></programlisting>

        <para>
            Take note of the sizing when trying to make a customcomponent that shrinks to
            fit the contained components. You have to set the size as undefined at all
            levels; the sizing of the composite component and the composition root are
            separate.
        </para>

        <para>
            You can use the component as follows:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[MyComposite mycomposite = new MyComposite("Hello");]]></programlisting>

        <para>
            The rendered component is shown in <xref
            linkend="figure.components.customcomponent"/>.
        </para>

		<figure xml:id="figure.components.customcomponent">
			<title>A Custom Composite Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="140" align="center" fileref="img/components/customcomponent-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            You can also inherit any other components, such as layouts, to attain similar
            composition.

            <indexterm><primary>Google Web Toolkit</primary></indexterm>

            Even further, you can create entirely new low-level components, by integrating
            pure client-side components or by extending the client-side functionality of
            built-in components. Development of new components is covered in <xref
            linkend="gwt"/>.
		</para>
	</section>

	<section xml:id="components.customfield">
		<title>Composite Fields with <classname>CustomField</classname></title>

        <para>
            The <classname>CustomField</classname> is a way to create composite components
            like with <classname>CustomComponent</classname>, except that it implements
            the <interfacename>Field</interfacename> interface and inherit
            <classname>AbstractField</classname>, described in <xref
            linkend="components.fields"/>. A field allows editing a property
            value in the Vaadin data model, and can be bound to data with field groups, as
            described in <xref linkend="datamodel.itembinding"/>. The field values are
            buffered and can be validated with validators.
        </para>

        <para>
            A composite field class must implement the <methodname>getType()</methodname>
            and <methodname>initContent()</methodname> methods. The latter should return
            the content composite of the field. It is typically a layout component, but
            can be any component.
        </para>

        <!-- TODO Add example -->

        <para>
            It is also possible to override <methodname>validate()</methodname>,
            <methodname>setInternalValue()</methodname>,
            <methodname>commit()</methodname>,
            <methodname>setPropertyDataSource</methodname>,
            <methodname>isEmpty()</methodname> and other methods to implement different
            functionalities in the field. Methods overriding
            <methodname>setInternalValue()</methodname> should call the superclass method.
        </para>
    </section>

	<section xml:id="components.embedded">
		<title>Embedded Resources</title>

		<para>
            You can embed images in Vaadin UIs with the <classname>Image</classname>
            component, Adobe Flash graphics with <classname>Flash</classname>, and other
            web content with <classname>BrowserFrame</classname>. There is also a generic
            <classname>Embedded</classname> component for embedding other object
            types. The embedded content is referenced as <emphasis>resources</emphasis>,
            as described in <xref linkend="application.resources"/>.
		</para>

		<para>
			The following example displays an image as a class resource loaded with the
			class loader:
		</para>

		<programlisting><![CDATA[Image image = new Image("Yes, logo:",
    new ClassResource("vaadin-logo.png"));
main.addComponent(image);]]></programlisting>

        <para>
            The caption can be given as null to disable it. An empty string displays an
            empty caption which takes a bit space. The caption is managed by the
            containing layout.
        </para>

        <para>
            You can set an altenative text for an embedded resource with
            <methodname>setAlternateText()</methodname>, which can be shown if images are
            disabled in the browser for some reason. The text can be used for
            accessibility purposes, such as for text-to-speech generation.
        </para>

		<section xml:id="components.embedded.image">
			<title>Embedded <classname>Image</classname></title>

            <para>
                The <classname>Image</classname> component allows embedding an image
                resource in a Vaadin UI.
            </para>

		<programlisting><![CDATA[// Serve the image from the theme
Resource res = new ThemeResource("img/myimage.png");

// Display the image without caption
Image image = new Image(null, res);
layout.addComponent(image);]]></programlisting>


            <para>
                The <classname>Image</classname> component has by default undefined size
                in both directions, so it will automatically fit the size of the embedded
                image.

                <indexterm><primary>scroll bars</primary></indexterm>

                If you want scrolling with scroll bars, you can put the image inside a
                <classname>Panel</classname> that has a defined size to enable scrolling,
                as described in <xref linkend="layout.panel.scrolling"/>. You can also put
                it inside some other component container and set the <literal>overflow:
                auto</literal> CSS property for the container element in a theme to enable
                automatic scrollbars.  <indexterm>overflow CSS property</indexterm>
            </para>

            <book-example eid="component.embedded.scrolling-css"></book-example>

            <section xml:id="components.embedded.image.generated">
                <title>Generating and Reloading Images</title>

                <para>
                    You can also generate the image content dynamically using a
                    <classname>StreamResource</classname>, as described in <xref
                    linkend="application.resources.stream"/>, or with a
                    <classname>RequestHandler</classname>.
                </para>

                <para>
                    If the image changes, the browser needs to reload it. Simply updating
                    the stream resource is not enough. Because of how caching is handled
                    in some browsers, you can cause a reload easiest by renaming the
                    filename of the resource with a unique name, such as one including a
                    timestamp. You should set cache time to zero with
                    <methodname>setCacheTime()</methodname> for the resource object when
                    you create it.

                    <!-- BUG #2470. -->
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create the stream resource with some initial filename
StreamResource imageResource =
    new StreamResource(imageSource, "initial-filename.png");

// Instruct browser not to cache the image
imageResource.setCacheTime(0);

// Display the image
Image image = new Image(null, imageResource);]]></programlisting>

                <para>
                    When refreshing, you also need to call
                    <methodname>markAsDirty()</methodname> for the
                    <classname>Image</classname> object.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// This needs to be done, but is not sufficient
image.markAsDirty();

// Generate a filename with a timestamp
SimpleDateFormat df = new SimpleDateFormat("yyyyMMddHHmmssSSS");
String filename = "myfilename-" + df.format(new Date()) + ".png";

// Replace the filename in the resource
imageResource.setFilename(makeImageFilename());]]></programlisting>
            </section>
        </section>
		
		<section xml:id="components.embedded.flash">
			<title>Adobe <classname>Flash</classname> Graphics</title>

			<para>
                The <classname>Flash</classname> component allows embedding Adobe Flash
                animations in Vaadin UIs.
			</para>

			<programlisting><![CDATA[Flash flash = new Flash(null,
    new ThemeResource("img/vaadin_spin.swf"));
layout.addComponent(flash);]]></programlisting>

			<para>
				You can set Flash parameters with <methodname>setParameter()</methodname>,
				which takes a parameter's name and value as strings. You can also set the
				<parameter>codeBase</parameter>, <parameter>archive</parameter>, and
				<parameter>standBy</parameter> attributes for the Flash object element in
				HTML.
			</para>
		</section>
		
		<section xml:id="components.embedded.browserframe">
			<title><classname>BrowserFrame</classname></title>

			<para>
				The <classname>BrowserFrame</classname> allows embedding web content
				inside an HTML <tag>&lt;iframe&gt;</tag> element. You can refer to an
				external URL with <classname>ExternalResource</classname>.
			</para>

            <para>
                As the <classname>BrowserFrame</classname> has undefined size by default,
                it is critical that you define a meaningful size for it, either fixed or
                relative.
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[BrowserFrame browser = new BrowserFrame("Browser",
    new ExternalResource("http://demo.vaadin.com/sampler/"));
browser.setWidth("600px");
browser.setHeight("400px");
layout.addComponent(browser);]]></programlisting>

            <para>
                Notice that web pages can prevent embedding them in an <tag>&lt;iframe&gt;</tag>.
            </para>
		</section>

		<section xml:id="components.embedded.embedded">
			<title>Generic <classname>Embedded</classname> Objects</title>

            <para>
                The generic <classname>Embedded</classname> component allows embedding all
                sorts of objects, such as SVG graphics, Java applets, and PDF documents,
                in addition to the images, Flash graphics, and browser frames which you
                can embed with the specialized components.
            </para>

            <para>
                For example, to display a Flash animation:
            </para>

			<programlisting><![CDATA[// A resource reference to some object
Resource res = new ThemeResource("img/vaadin_spin.swf");

// Display the object
Embedded object = new Embedded("My Object", res);
layout.addComponent(object);]]></programlisting>

            <para>
                Or an SVG image:
            </para>

			<programlisting><![CDATA[// A resource reference to some object
Resource res = new ThemeResource("img/reindeer.svg");

// Display the object
Embedded object = new Embedded("My SVG", res);
object.setMimeType("image/svg+xml"); // Unnecessary
layout.addComponent(object);]]></programlisting>

            <para>
                The MIME type of the objects is usually detected automatically from the
                filename extension with the <classname>FileTypeResolver</classname>
                utility in Vaadin. If not, you can set it explicitly with
                <methodname>setMimeType()</methodname>, as was done in the example above
                (where it was actually unnecessary).
            </para>

            <para>
                Some embeddable object types may require special support in the
                browser. You should make sure that there is a proper fallback mechanism if
                the browser does not support the embedded type.
            </para>
        </section>
	</section>
</chapter>
	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
