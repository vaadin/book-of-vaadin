<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="components">
	<title>User Interface Components</title>
	
	<para>
		This chapter provides an overview and a detailed description of all
		non-layout components in Vaadin.
	</para>
	
    <para>
        <emphasis>Because of pressing release schedules to get this edition to your hands,
        we were unable to completely update this chapter for Vaadin 7. The content is
        up-to-date to a large extent, but some topics still require revision,
        especially the data binding of the <classname>Table</classname> component. Please
        consult the web version once it is updated, or the next print edition.</emphasis>
    </para>

	<section xml:id="components.overview">
		<title>Overview</title>

		<para>
			Vaadin provides a comprehensive set of user interface components and allows
			you to define custom components. <xref linkend="figure.uicomponents"/>
			illustrates the inheritance hierarchy of the UI component classes and
			interfaces. Interfaces are displayed in gray, abstract classes in orange, and
			regular classes in blue. An annotated version of the diagram is featured in
			the <emphasis>Vaadin Cheat Sheet</emphasis>.
		</para>

		<figure xml:id="figure.uicomponents" float="center" floatstyle="before">
			<title>User Interface Component Class Hierarchy</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/component-diagram-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/component-diagram-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            <indexterm><primary><classname>Component</classname></primary></indexterm>

			At the top of the interface hierarchy, we have the
			<classname>Component</classname> interface.

            <indexterm><primary><classname>AbstractComponent</classname></primary></indexterm>

            At the top of the class hierarchy, we have the
            <classname>AbstractComponent</classname> class.

            <indexterm><primary><classname>AbstractField</classname></primary></indexterm>
            <indexterm><primary><classname>AbstractComponentContainer</classname></primary></indexterm>

            It is inherited by two other abstract classes:
            <classname>AbstractField</classname>, inherited further by field components,
            and <classname>AbstractComponentContainer</classname>, inherited by various
            container and layout components. Components that are not bound to a content
            data model, such as labels and links, inherit
            <classname>AbstractComponent</classname> directly.
		</para>

		<para>
            <indexterm><primary>layout</primary></indexterm>
            <indexterm><primary><classname>Layout</classname></primary></indexterm>

			The layout of the various components in a window is controlled,
			logically, by layout components, just like in conventional Java UI
			toolkits for desktop applications. In addition, with the <classname>CustomLayout</classname>
			component, you can write a custom layout as an XHTML template that
			includes the locations of any contained components. Looking at the
			inheritance diagram, we can see that layout components inherit the
			<classname>AbstractComponentContainer</classname> and the
			<classname>Layout</classname> interface. Layout components are
			described in detail in <xref linkend="layout"/>.
		</para>

		<para>
            <indexterm><primary><classname>Window</classname></primary></indexterm>

			Looking at it from the perspective of an object hierarchy, we would
			have a <classname>Window</classname> object, which contains a hierachy of
			layout components, which again contain other layout components, field
			components, and other visible components.
		</para>

		<para>
            <indexterm><primary>Sampler</primary></indexterm>
            <indexterm><primary>JavaDoc</primary></indexterm>

			You can browse the built-in UI components of Vaadin library in the
			<application>Sampler</application> application of the <application>Vaadin
			Demo</application>. The Sampler shows a description, JavaDoc documentation,
			and a code samples for each of the components.
		</para>

		<para>
            In addition to the built-in components, many components are available as
            add-ons, either from the Vaadin Directory or from independent sources. Both
            commercial and free components exist. The installation of add-ons is described
            in <xref linkend="addons"/>.
        </para>

        <note>
            <title>Vaadin Cheat Sheet and Refcard</title>

            <para>
                <xref linkend="figure.uicomponents"/> is included in the Vaadin Cheat
                Sheet that illustrates the basic relationship hierarchy of the user
                interface components and data binding classes and interfaces. You can
                download it at <link
                xlink:href="http://vaadin.com/book">http://vaadin.com/book</link>.
            </para>

            <para>
                The diagram is also included in the six-page DZone Refcard, which you can
                find at <link
                xlink:href="https://vaadin.com/refcard">https://vaadin.com/refcard</link>.
            </para>
        </note>
	</section>

	<section xml:id="components.interfaces">
		<title>Interfaces and Abstractions</title>

        <para>
            <indexterm><primary>interfaces</primary></indexterm>

			Vaadin user interface components are built on a skeleton of interfaces and
			abstract classes that define and implement the features common to all
			components and the basic logic how the component states are serialized between
			the server and the client.
        </para>
        
        <para>
			This section gives details on the basic component interfaces and
			abstractions. The layout and other component container abstractions are
			described in <xref linkend="layout"/>. The interfaces that define the Vaadin
			data model are described in <xref linkend="datamodel"/>.
        </para>

		<figure xml:id="figure.components.interfaces" float="center" floatstyle="before">
			<title>Component Interfaces and Abstractions</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/component-abstractions-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/component-abstractions-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            <indexterm><primary><classname>Paintable</classname></primary></indexterm>
            <indexterm><primary><classname>VariableOwner</classname></primary></indexterm>

			All components also implement the <classname>Paintable</classname> interface,
			which is used for serializing ("painting") the components to the client, and
			the reverse <classname>VariableOwner</classname> interface, which is needed
			for deserializing component state or user interaction from the client.
        </para>

        <para>
            <indexterm><primary><classname>Serializable</classname></primary></indexterm>

			In addition to the interfaces defined within the Vaadin framework, all
			components implement the <classname>java.io.Serializable</classname> interface
			to allow serialization. Serialization is needed in many clustering and cloud
			computing solutions.
		</para>

        <section xml:id="components.interfaces.component">
            <title><classname>Component</classname> Interface</title>

            <indexterm xml:id="term.components.interfaces.component" class="startofterm">
                <primary><classname>Component</classname> interface</primary>
            </indexterm>

            <para>
                The <classname>Component</classname> interface is paired with the
                <classname>AbstractComponent</classname> class, which implements all the
                methods defined in the interface.
            </para>

			<section>
				<title>Component Tree Management</title>

				<para>
					Components are laid out in the user interface hierarchically. The
					layout is managed by layout components, or more generally components
					that implement the <classname>ComponentContainer</classname>
					interface. Such a container is the parent of the contained components.
				</para>

				<para>
					The <methodname>getParent()</methodname> method allows retrieving the
					parent component of a component. While there is a
					<methodname>setParent()</methodname>, you rarely need it as you
					usually add components with the
					<methodname>addComponent()</methodname> method of the
					<classname>ComponentContainer</classname> interface, which
					automatically sets the parent.
				</para>

				<para>
					A component does not know its parent when the component is still being
					created, so you can not refer to the parent in the constructor with
					<methodname>getParent()</methodname>.
                </para>

				<para>
					Attaching a component to an UI triggers a call to its
					<methodname>attach()</methodname> method. Correspondingly, removing a
					component from a container triggers calling the
					<methodname>detach()</methodname> method. If the parent of an added
					component is already connected to the UI, the
					<methodname>attach()</methodname> is called immediately from
					<methodname>setParent()</methodname>.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[public class AttachExample extends CustomComponent {
    public AttachExample() {
    }
    
    @Override
    public void attach() {
        super.attach(); // Must call.
        
        // Now we know who ultimately owns us.
        ClassResource r = new ClassResource("smiley.jpg");
        Image image = new Image("Image:", r); 
        setCompositionRoot(image);
    }
}]]></programlisting>

				<para>
					The attachment logic is implemented in
					<classname>AbstractComponent</classname>, as described in <xref
					linkend="components.interfaces.abstractcomponent"/>.
				</para>

			</section>

            <indexterm startref="term.components.interfaces.component" class="endofterm">
                <primary><classname>Component</classname> interface</primary>
            </indexterm>
        </section>

        <section xml:id="components.interfaces.abstractcomponent">
            <title><classname>AbstractComponent</classname></title>

            <indexterm xml:id="term.components.interfaces.abstractcomponent" class="startofrange">
                <primary><classname>AbstractComponent</classname></primary>
            </indexterm>

            <para>
                <classname>AbstractComponent</classname> is the base class for all user
                interface components. It is the (only) implementation of the
                <classname>Component</classname> interface, implementing all the methods
                defined in the interface.
            </para>
			
			<para>
				<classname>AbstractComponent</classname> has a single abstract method,
				<methodname>getTag()</methodname>, which returns the serialization
				identifier of a particular component class. It needs to be implemented
				when (and only when) creating entirely new
				components. <classname>AbstractComponent</classname> manages much of the
				serialization of component states between the client and the
				server. Creation of new components and serialization is described in <xref
				linkend="gwt"/>.
			</para>

            <indexterm startref="term.components.interfaces.abstractcomponent" class="endofrange"/>
        </section>

        <section xml:id="components.interfaces.fields">
            <title>Field Components (<classname>Field</classname> and <classname>AbstractField</classname>)</title>

            <indexterm xml:id="term.components.fields" class="startofrange">
                <primary><classname>Field</classname></primary>
            </indexterm>

            <para>
				<emphasis>Fields</emphasis> are components that have a value that the user
				can change through the user interface. <xref
				linkend="figure.components.interfaces.fields"/> illustrates the inheritance
				relationships and the important interfaces and base classes.
			</para>

			<figure xml:id="figure.components.interfaces.fields">
				<title>Field Components</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/field-diagram-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="100%" align="center" fileref="img/components/field-diagram-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Field components are built upon the framework defined in the
				<classname>Field</classname> interface and the
				<classname>AbstractField</classname> base class.
			</para>

			<para>
				The description of the field interfaces and base classes is broken down in
				the following sections.
			</para>

			<section xml:id="components.interfaces.fields.field">
				<title><classname>Field</classname> Interface</title>

				<para>
					The <classname>Field</classname> interface inherits the
					<classname>Component</classname> superinterface and also the
					<classname>Property</classname> interface to have a value for the
					field. <classname>AbstractField</classname> is the only class
					implementing the <classname>Field</classname> interface directly.  The
					relationships are illustrated in <xref
					linkend="figure.components.interfaces.fields.field"/>.
				</para>

				<figure xml:id="figure.components.interfaces.fields.field">
					<title><classname>Field</classname> Interface Inheritance Diagram</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/components/field-interface-lo.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="100" smallscale="100%" align="center" fileref="img/components/field-interface-hi.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					You can set the field value with the <methodname>setValue()</methodname>
					and read with the <methodname>getValue()</methodname> method defined in
					the <classname>Property</classname> interface. The actual value type
					depends on the component.
				</para>

				<para>
					The <classname>Field</classname> interface defines a number of
					attributes, which you can retrieve or manipulate with the
					corresponding setters and getters.
				</para>

				<variablelist>
					<varlistentry>
						<term><methodname>description</methodname></term>
						<listitem>
							<para>
								All fields have a description. Notice that while this
								attribute is defined in the
								<classname>Field</classname> component, it is
								implemented in <classname>AbstractField</classname>,
								which does not directly implement
								<classname>Field</classname>, but only through the
								<classname>AbstractField</classname> class.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><methodname>required</methodname></term>
						<listitem>
							<para>
								When enabled, a required indicator (usually the asterisk *
								character) is displayed on the left, above, or right the
								field, depending on the containing layout and whether the
								field has a caption. If such fields are validated but are
								empty and the <methodname>requiredError</methodname>
								property (see below) is set, an error indicator is shown
								and the component error is set to the text defined with
								the error property. Without validation, the required
								indicator is merely a visual guide.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><methodname>requiredError</methodname></term>
						<listitem>
							<para>
								Defines the error message to show when a value is
								required, but none is entered. The error message is set as
								the component error for the field and is usually displayed
								in a tooltip when the mouse pointer hovers over the error
								indicator.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>

			<section xml:id="components.interfaces.fields.databinding">
				<title>Data Binding and Conversions</title>

                <para>
                    Fields are strongly coupled with the Vaadin data model. The field value is
                    handled as a <classname>Property</classname> of the field component, as
                    documented in <xref linkend="datamodel.properties"/>. Selection fields
                    allow management of the selectable items through the
                    <classname>Container</classname> interface.
                </para>

                <para>
                    Fields edit some particular type. For example,
                    <classname>TextField</classname> allows editing
                    <classname>String</classname> values. When bound to a data source, the
                    property type of the data model can be something different, say an
                    <classname>Integer</classname>. <emphasis>Converters</emphasis> are used
                    for converting the values between the representation and the model. They
                    are described in <xref linkend="datamodel.properties.converter"/>.
                </para>
            </section>

            <section xml:id="components.interfaces.fields.valuechanges">
				<title>Handling Field Value Changes</title>
				
				<para>
					<classname>Field</classname> inherits
					<classname>Property.ValueChangeListener</classname> to allow listening
					for field value changes and <classname>Property.Editor</classname> to
					allow editing values.
				</para>

				<para>
					When the value of a field changes, a
					<classname>Property.ValueChangeEvent</classname> is triggered for
					the field. You should not implement the
					<methodname>valueChange()</methodname> method in a class
					inheriting <classname>AbstractField</classname>, as it is already
					implemented in <classname>AbstractField</classname>. You should
					instead implement the method explicitly by adding the implementing
					object as a listener.
				</para>
			</section>

            <section xml:id="components.interfaces.fields.abstractfield">
				<title><classname>AbstractField</classname> Base Class</title>

				<para>
					<classname>AbstractField</classname> is the base class for all field
					components. In addition to the component features inherited from
					<classname>AbstractComponent</classname>, it implements a number of
					features defined in <classname>Property</classname>,
					<classname>Buffered</classname>, <classname>Validatable</classname>,
					and <classname>Component.Focusable</classname> interfaces.
				</para>

			</section>
			
        </section>

        <indexterm startref="term.components.fields" class="endofrange"/>
    </section>

	<section xml:id="components.features">
		<title>Common Component Features</title>

        <para>
            The component base classes and interfaces provide a large number of
            features. Let us look at some of the most commonly needed features. Features
            not documented here can be found from the Java API Reference.
        </para>

        <para>
            The interface defines a number of properties, which you can retrieve
            or manipulate with the corresponding setters and getters.
        </para>

        <section xml:id="components.features.caption">
            <title>Caption</title>

            <indexterm zone="components.features.caption">
                <primary>caption property</primary>
            </indexterm>

            <indexterm zone="components.features.caption">
                <primary>Component interface</primary>
                <secondary>caption</secondary>
            </indexterm>

            <para>
                A caption is an explanatory textual label accompanying a user interface
                component, usually shown above, left of, or inside the component. The
                contents of a caption are automatically quoted, so no raw XHTML can be
                rendered in a caption.
            </para>

            <para>
                The caption text can usually be given as the first parameter of a
                constructor of a component or with <methodname>setCaption()</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// New text field with caption "Name"
TextField name = new TextField("Name");
layout.addComponent(name);]]></programlisting>

            <para>
                The caption of a component is, by default, managed and displayed by the
                layout component or component container inside which the component is
                placed. For example, the <classname>VerticalLayout</classname> component
                shows the captions left-aligned above the contained components, while the
                <classname>FormLayout</classname> component shows the captions on the left
                side of the vertically laid components, with the captions and their
                associated components left-aligned in their own columns. The
                <classname>CustomComponent</classname> does not manage the caption of its
                composition root, so if the root component has a caption, it will not be
                rendered.
            </para>

			<figure xml:id="figure.components.features.caption.layoutmanaged">
				<title>Caption Management by <classname>VerticalLayout</classname> and <classname>FormLayout</classname> components.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-caption-layoutmanaged.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-caption-layoutmanaged.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Some components, such as <classname>Button</classname> and
                <classname>Panel</classname>, manage the caption themselves and display it
                inside the component.
            </para>

            <para>
                Icon (see <xref linkend="components.features.icon"/>) is closely related
                to caption and is usually displayed horizontally before or after it,
                depending on the component and the containing layout. Also the required
                indicator in field components is usually shown before or after the
                caption.
            </para>

            <para>
                An alternative way to implement a caption is to use another component as
                the caption, typically a <classname>Label</classname>, a
                <classname>TextField</classname>, or a <classname>Panel</classname>. A
                <classname>Label</classname>, for example, allows highlighting a shortcut
                key with XHTML markup or to bind the caption to a data source. The
                <classname>Panel</classname> provides an easy way to add both a caption
                and a border around a component.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-caption {}
  .v-captiontext {}
  .v-caption-clearelem {}
  .v-required-field-indicator {}]]></programlisting>

                <para>
                    A caption is be rendered inside an HTML element that has the
                    <literal>v-caption</literal> CSS style class. The containing layout
                    may enclose a caption inside other caption-related elements.
                </para>

                <para>
                    Some layouts put the caption text in a
                    <literal>v-captiontext</literal> element. A
                    <literal>v-caption-clearelem</literal> is used in some layouts to
                    clear a CSS <literal>float</literal> property in captions. An optional
                    required indicator in field components is contained in a separate
                    element with <literal>v-required-field-indicator</literal> style.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.features.description">
			<title>Description and Tooltips</title>

            <indexterm zone="components.features.description">
                <primary>description property</primary>
            </indexterm>

            <indexterm zone="components.features.description">
                <primary>Component interface</primary>
                <secondary>description</secondary>
            </indexterm>

            <indexterm zone="components.features.description">
                <primary>tooltips</primary>
            </indexterm>

			<para>
				All components (that inherit <classname>AbstractComponent</classname>)
				have a description separate from their caption. The description is usually
				shown as a tooltip that appears when the mouse pointer hovers over the
				component for a short time.
			</para>

			<para>
				You can set the description with <methodname>setDescription()</methodname>
				and retrieve with <methodname>getDescription()</methodname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Button button = new Button("A Button");
button.setDescription("This is the tooltip");]]></programlisting>

			<para>
				The tooltip is shown in <xref
				linkend="figure.components.tooltip.plain"/>.
			</para>

			<figure xml:id="figure.components.tooltip.plain">
				<title>Component Description as a Tooltip</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/tooltip-plain-withpointer-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="130" align="center" fileref="img/components/tooltip-plain-withpointer-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				A description is rendered as a tooltip in most
				components.
			</para>

			<para>
				When a component error has been set with
				<methodname>setComponentError()</methodname>, the error is usually also
				displayed in the tooltip, below the description. Components that are in
				error state will also display the error indicator. See <xref
				linkend="application.errors.error-indicator"/>.
			</para>

			<para>
				The description is actually not plain text, but you can use XHTML tags to
				format it. Such a rich text description can contain any HTML elements,
				including images.
			</para>

			<programlisting><?pocket-size 60% ?><![CDATA[button.setDescription(
    "<h2><img src=\"../VAADIN/themes/sampler/icons/comment_yellow.gif\"/>"+
    "A richtext tooltip</h2>"+
    "<ul>"+
    "  <li>Use rich formatting with XHTML</li>"+
    "  <li>Include images from themes</li>"+
    "  <li>etc.</li>"+
    "</ul>");]]></programlisting>

			<para>
				The result is shown in <xref
				linkend="figure.components.tooltip.richtext"/>.
			</para>

			<figure xml:id="figure.components.tooltip.richtext">
				<title>A Rich Text Tooltip</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/tooltip-richtext-withpointer-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100" align="center" fileref="img/components/tooltip-richtext-withpointer-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Notice that the setter and getter are defined for all fields in the
				<classname>Field</classname> interface, not for all components in the
				<classname>Component</classname> interface.
			</para>
		</section>

        <section xml:id="components.features.enabled">
            <title>Enabled</title>
            
            <indexterm zone="components.features.enabled">
                <primary>enabled property</primary>
            </indexterm>

            <indexterm zone="components.features.enabled">
                <primary>Component interface</primary>
                <secondary>enabled</secondary>
            </indexterm>

            <para>
                The <emphasis>enabled</emphasis> property controls whether the user can
                actually use the component. A disabled component is visible, but grayed to
                indicate the disabled state.
            </para>

            <para>
                Components are always enabled by default. You can disable a component with
                <methodname>setEnabled(false)</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[Button enabled = new Button("Enabled");
enabled.setEnabled(true); // The default
layout.addComponent(enabled);
        
Button disabled = new Button("Disabled");
disabled.setEnabled(false);
layout.addComponent(disabled);]]></programlisting>

            <para>
                <xref linkend="figure.components.features.enabled.simple"/> shows the
                enabled and disabled buttons.
            </para>

			<figure xml:id="figure.components.features.enabled.simple">
				<title>An Enabled and Disabled <classname>Button</classname></title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-enabled-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="75%" align="center" fileref="img/components/features-enabled-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                A disabled component is automatically put in read-only state. No client
                interaction with such a component is sent to the server and, as an
                important security feature, the server-side components do not receive
                state updates from the client in the read-only state. This feature exists
                in all built-in components in Vaadin and is automatically handled for all
                <classname>Field</classname> components for the field property value. For
                custom widgets, you need to make sure that the read-only state is checked
                on the server-side for all safety-critical variables.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    Disabled components have the <literal>v-disabled</literal> CSS style
                    in addition to the component-specific style. To match a component with
                    both the styles, you have to join the style class names with a dot as
                    done in the example below.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[.v-textfield.v-disabled {
    border: dotted;
}]]></programlisting>

                <para>
                    This would make the border of all disabled text fields dotted.
                </para>

            <programlisting><?pocket-size 75% ?><![CDATA[TextField disabled = new TextField("Disabled");
disabled.setValue("Read-only value");
disabled.setEnabled(false);
layout.addComponent(disabled);]]></programlisting>

                <para>
                    The result is illustrated in <xref
                    linkend="figure.components.features.enabled.styling"/>.
                </para>

                <figure xml:id="figure.components.features.enabled.styling">
                    <title>Styling Disabled Components</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/features-enabled-styling.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="80" smallscale="80%" align="center" fileref="img/components/features-enabled-styling.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </simplesect>
        </section>
        
        <section xml:id="components.features.icon">
            <title>Icon</title>
            
            <indexterm zone="components.features.icon">
                <primary>icon property</primary>
            </indexterm>

            <indexterm zone="components.features.icon">
                <primary>Component interface</primary>
                <secondary>icon</secondary>
            </indexterm>

            <para>
                An icon is an explanatory graphical label accompanying a user interface
                component, usually shown above, left of, or inside the component. Icon is
                closely related to caption (see <xref
                linkend="components.features.caption"/>) and is usually displayed
                horizontally before or after it, depending on the component and the
                containing layout.
            </para>

            <para>
                The icon of a component can be set with the
                <methodname>setIcon()</methodname> method. The image is provided as a
                resource, perhaps most typically a <classname>ThemeResource</classname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Component with an icon from a custom theme
TextField name = new TextField("Name");
name.setIcon(new ThemeResource("icons/user.png"));
layout.addComponent(name);
        
// Component with an icon from another theme ('runo')
Button ok = new Button("OK");
ok.setIcon(new ThemeResource("../runo/icons/16/ok.png"));
layout.addComponent(ok);]]></programlisting>

            <para>
                The icon of a component is, by default, managed and displayed by the
                layout component or component container in which the component is
                placed. For example, the <classname>VerticalLayout</classname> component
                shows the icons left-aligned above the contained components, while the
                <classname>FormLayout</classname> component shows the icons on the left
                side of the vertically laid components, with the icons and their
                associated components left-aligned in their own columns. The
                <classname>CustomComponent</classname> does not manage the icon of its
                composition root, so if the root component has an icon, it will not be
                rendered.
            </para>

			<figure xml:id="figure.components.features.icon">
				<title>Displaying an Icon from a Theme Resource.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-icon.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-icon.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Some components, such as <classname>Button</classname> and
                <classname>Panel</classname>, manage the icon themselves and display it
                inside the component.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    An icon will be rendered inside an HTML element that has the
                    <literal>v-icon</literal> CSS style class. The containing layout may
                    enclose an icon and a caption inside elements related to the caption,
                    such as <literal>v-caption</literal>.
                </para>
            </simplesect>
        </section>
        
        <section xml:id="components.features.locale">
            <title>Locale</title>
            
            <indexterm zone="components.features.locale">
                <primary>locale property</primary>
                <secondary>in <classname>Component</classname></secondary>
            </indexterm>

            <indexterm zone="components.features.locale">
                <primary>Component interface</primary>
                <secondary>locale</secondary>
            </indexterm>

            <para>
                The locale property defines the country and language used in a
                component. You can use the locale information in conjunction with an
                internationalization scheme to acquire localized resources. Some
                components, such as <classname>DateField</classname>, use the locale for
                component localization.
            </para>

            <para>
                You can set the locale of a component (or the application) with
                <methodname>setLocale()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Component for which the locale is meaningful
InlineDateField date = new InlineDateField("Datum");
        
// German language specified with ISO 639-1 language
// code and ISO 3166-1 alpha-2 country code. 
date.setLocale(new Locale("de", "DE"));
        
date.setResolution(DateField.Resolution.DAY);
layout.addComponent(date);]]></programlisting>

            <para>
                The resulting date field is shown in <xref
                linkend="figure.components.features.locale.simple"/>.
            </para>
            
			<figure xml:id="figure.components.features.locale.simple">
				<title>Set Locale for <classname>InlineDateField</classname></title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-locale-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-locale-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                <indexterm><primary><methodname>getLocale()</methodname></primary></indexterm>

                You can get the locale of a component with
                <methodname>getLocale()</methodname>. If the locale is undefined for a
                component, that is, not explicitly set, the locale of the parent component
                is used. If none of the parent components have a locale set, the locale of
                the application is used, and if that is not set, the default system locale
                is set, as given by <methodname>Locale.getDefault()</methodname>.
            </para>

            <para>
                Because of the requirement that the component must be attached to the
                application, it is awkward to use <methodname>getLocale()</methodname> for
                internationalization. You can not use it in the constructor, so you would
                have to get the locale in <methodname>attach()</methodname> as shown in
                the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Button cancel = new Button() {
    @Override
    public void attach() {
        ResourceBundle bundle = ResourceBundle.getBundle(
                MyAppCaptions.class.getName(), getLocale());
        setCaption(bundle.getString("CancelKey"));
    }
};
layout.addComponent(cancel);]]></programlisting>

            <para>
                It is normally a better practice to get the locale from an
                application-global parameter and use it to get the localized resource
                right when the component is created.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Captions are stored in MyAppCaptions resource bundle
// and the application object is known in this context.
ResourceBundle bundle =
    ResourceBundle.getBundle(MyAppCaptions.class.getName(),
                             getApplication().getLocale());
        
// Get a localized resource from the bundle
Button cancel = new Button(bundle.getString("CancelKey"));
layout.addComponent(cancel);]]></programlisting>

            <simplesect>
                <title>Selecting a Locale</title>

                <para>
                    A common task in many applications is selecting a locale. This is done
                    in the following example with a <classname>Select</classname> component.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// The locale in which we want to have the language
// selection list
Locale displayLocale = Locale.ENGLISH;
        
// All known locales
final Locale[] locales = Locale.getAvailableLocales();
        
// Allow selecting a language. We are in a constructor of a
// CustomComponent, so preselecting the current
// language of the application can not be done before
// this (and the selection) component are attached to
// the application.
final Select select = new Select("Select a language") {
    @Override
    public void attach() {
        setValue(getLocale());
    }
};
for (int i=0; i<locales.length; i++) {
    select.addItem(locales[i]);
    select.setItemCaption(locales[i],
                          locales[i].getDisplayName(displayLocale));
    
    // Automatically select the current locale
    if (locales[i].equals(getLocale()))
        select.setValue(locales[i]);
}
layout.addComponent(select);

// Locale code of the selected locale
final Label localeCode = new Label("");
layout.addComponent(localeCode);

// A date field which language the selection will change
final InlineDateField date =
    new InlineDateField("Calendar in the selected language");
date.setResolution(DateField.Resolution.DAY);
layout.addComponent(date);
        
// Handle language selection
select.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        Locale locale = (Locale) select.getValue();
        date.setLocale(locale);
        localeCode.setValue("Locale code: " +
                            locale.getLanguage() + "_" +
                            locale.getCountry());
    }
});
select.setImmediate(true);]]></programlisting>

                <para>
                    The user interface is shown in <xref
                    linkend="figure.components.features.locale.selection"/>.
                </para>

                <figure xml:id="figure.components.features.locale.selection">
                    <title>Selecting a Locale</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/features-locale-selection.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-locale-selection.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

            </simplesect>
        </section>

        <section xml:id="components.features.readonly">
            <title>Read-Only</title>

            <indexterm zone="components.features.readonly">
                <primary>read-only property</primary>
            </indexterm>

            <indexterm zone="components.features.readonly">
                <primary>Component interface</primary>
                <secondary>read-only</secondary>
            </indexterm>

            <para>
                The property defines whether the value of a component can be changed. The
                property is mainly applicable to <classname>Field</classname> components,
                as they have a value that can be edited by the user.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField readwrite = new TextField("Read-Write");
readwrite.setValue("You can change this");
readwrite.setReadOnly(false); // The default
layout.addComponent(readwrite);
        
TextField readonly = new TextField("Read-Only");
readonly.setValue("You can't touch this!");
readonly.setReadOnly(true);
layout.addComponent(readonly);]]></programlisting>

            <para>
                The resulting read-only text field is shown in <xref
                linkend="figure.components.features.readonly.simple"/>.
            </para>

			<figure xml:id="figure.components.features.readonly.simple">
				<title>A Read-Only Component.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-readonly-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="75%" align="center" fileref="img/components/features-readonly-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Setting a layout or some other component container as read-only does not
                usually make the contained components read-only recursively. This is
                different from, for example, the disabled state, which is usually applied
                recursively.
            </para>

            <para>
                Notice that the value of a selection component is the selection, not its
                items. A read-only selection component doesn't therefore allow its
                selection to be changed, but other changes are possible. For example, if
                you have a read-only <classname>Table</classname> in editable mode, its
                contained fields and the underlying data model can still be edited, and
                the user could sort it or reorder the columns.
            </para>

            <para>
                Client-side state modifications will not be communicated to the
                server-side and, more importantly, server-side field components will not
                accept changes to the value of a read-only <classname>Field</classname>
                component. The latter is an important security feature, because a
                malicious user can not fabricate state changes in a read-only field. This
                is handled at the level of <classname>AbstractField</classname> in
                <methodname>setValue()</methodname>, so you can not change the value
                programmatically either. Calling <methodname>setValue()</methodname> on a
                read-only field results in
                <classname>Property.ReadOnlyException</classname>. 
            </para>

            <para>
                Also notice that while the read-only status applies automatically to the
                property value of a field, it does not apply to other component
                variables. A read-only component can accept some other variable changes
                from the client-side and some of such changes could be acceptable, such as
                change in the scroll bar position of a
                <classname>Table</classname>. Custom widgets should check the read-only
                state for variables bound to business data.

                <!-- TODO: Note this also in the Advanced: Security section and
                   possibly also in the GWT chapter. -->
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    Setting a normally editable component to read-only state can change
                    its appearance to disallow editing the value. In addition to CSS
                    styling, also the HTML structure can change. For example,
                    <classname>TextField</classname> loses the edit box and appears much
                    like a <classname>Label</classname>.
                </para>

                <para>
                    A read-only component will have the <literal>v-readonly</literal>
                    style. The following CSS rule would make the text in all read-only
                    <classname>TextField</classname> components appear in italic.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.v-textfield.v-readonly {
    font-style: italic;
}]]></programlisting>
            </simplesect>
        </section>

        <section xml:id="components.features.stylename">
            <title>Style Name</title>

            <indexterm zone="components.features.stylename">
                <primary>style name property</primary>
            </indexterm>

            <indexterm zone="components.features.stylename">
                <primary>Component interface</primary>
                <secondary>style name</secondary>
            </indexterm>

            <para>
                The <emphasis>style name</emphasis> property defines one or more custom
                CSS style class names for the component. The
                <methodname>getStyleName()</methodname> returns the current style names as
                a space-separated list. The <methodname>setStyleName()</methodname>
                replaces all the styles with the given style name or a space-separated
                list of style names. You can also add and remove individual style names
                with <methodname>addStylename()</methodname> and
                <methodname>removeStyleName()</methodname>. A style name must be a valid
                CSS style name.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Label label = new Label("This text has a lot of style");
label.addStyleName("mystyle");
layout.addComponent(label);]]></programlisting>

            <para>
                The style name will appear in the component's HTML element in two forms:
                literally as given and prefixed with the component class specific style
                name. For example, if you add a style name <literal>mystyle</literal> to a
                <classname>Button</classname>, the component would get both
                <literal>mystyle</literal> and <literal>v-button-mystyle</literal>
                styles. Neither form may conflict with built-in style names of Vaadin. For
                example, <literal>focus</literal> style would conflict with a built-in
                style of the same name, and an <literal>option</literal> style for a
                <classname>Select</classname> component would conflict with the built-in
                <literal>v-select-option</literal> style.
            </para>

            <para>
                The following CSS rule would apply the style to any component that has the
                <literal>mystyle</literal> style.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[.mystyle {
    font-family: fantasy;
    font-style:  italic;
    font-size:   25px;
    font-weight: bolder;
    line-height: 30px;
}]]></programlisting>

            <para>
                The resulting styled component is shown in <xref
                linkend="figure.components.features.stylename"/>
            </para>

			<figure xml:id="figure.components.features.stylename">
				<title>Component with a Custom Style</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-stylename-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-stylename-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="components.features.visible">
            <title>Visible</title>
            
            <indexterm zone="components.features.visible">
                <primary>visible property</primary>
            </indexterm>

            <indexterm zone="components.features.visible">
                <primary>Component interface</primary>
                <secondary>visible</secondary>
            </indexterm>

            <para>
                Components can be hidden by setting the <emphasis>visible</emphasis>
                property to <emphasis>false</emphasis>. Also the caption, icon and any
                other component features are made hidden. Hidden components are not just
                invisible, but their content is not communicated to the browser at
                all. That is, they are not made invisible cosmetically with only CSS
                rules. This feature is important for security if you have components that
                contain security-critical information that must only be shown in specific
                application states.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField invisible = new TextField("No-see-um");
invisible.setValue("You can't see this!");
invisible.setVisible(false);
layout.addComponent(invisible);]]></programlisting>

            <para>
                The resulting invisible component is shown in <xref
                linkend="figure.components.features.visible.simple"/>.
            </para>

			<figure xml:id="figure.components.features.visible.simple">
				<title>An Invisible Component.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-visible-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-visible-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Beware that invisible beings can leave footprints. The containing layout
                cell that holds the invisible component will not go away, but will show in
                the layout as extra empty space. Also expand ratios work just like if the
                component was visible - it is the layout cell that expands, not the
                component.
            </para>

            <para>
                If you need to make a component only cosmetically invisible, you should
                use a custom theme to set it <literal>display: none</literal> style. This
                is mainly useful for certain special components such as
                <classname>ProgressIndicator</classname>, which have effects even when
                made invisible in CSS. If the hidden component has undefined size and is
                enclosed in a layout that also has undefined size, the containing layout
                will collapse when the component disappears. If you want to have the
                component keep its size, you have to make it invisible by setting all its
                font and other attributes to be transparent. In such cases, the invisible
                content of the component can be made visible easily in the browser.
            </para>

            <para>
                A component made invisible with the <emphasis>visible</emphasis> property
                has no particular CSS style class to indicate that it is hidden. The
                element does exist though, but has <literal>display: none</literal> style,
                which overrides any CSS styling.
            </para>
        </section>

		<section xml:id="components.features.sizeable">
			<title>Sizing Components</title>

            <indexterm zone="components.features.sizeable">
                <primary><classname>Sizeable</classname> interface</primary>
            </indexterm>

			<para>
				Vaadin components are sizeable; not in the sense that they were
				fairly large or that the number of the components and their features are
				sizeable, but in the sense that you can make them fairly large on the
				screen if you like, or small or whatever size.
			</para>

			<para>
				The <classname>Sizeable</classname> interface, shared by all components,
				provides a number of manipulation methods and constants for setting the
				height and width of a component in absolute or relative units, or for
				leaving the size undefined.
			</para>

			<para>
				The size of a component can be set with
				<methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname> methods. The methods take the size as
				a floating-point value. You need to give the unit of the measure as the
				second parameter for the above methods. The available units are listed in
				<xref linkend="components.features.sizeable.units.table"/> below.
			</para>

			<programlisting><![CDATA[mycomponent.setWidth(100, Sizeable.UNITS_PERCENTAGE);
mycomponent.setWidth(400, Sizeable.UNITS_PIXELS);]]></programlisting>

			<para>
				Alternatively, you can speficy the size as a string. The format of such a
				string must follow the HTML/CSS standards for specifying measures.
			</para>

			<programlisting><![CDATA[mycomponent.setWidth("100%");
mycomponent.setHeight("400px");]]></programlisting>

			<para>
				The "<literal>100%</literal>" percentage value makes the component take
				all available size in the particular direction (see the description of
				<parameter>Sizeable.UNITS_PERCENTAGE</parameter> in the table below). You
				can also use the shorthand method <methodname>setSizeFull()</methodname>
				to set the size to 100% in both directions.
			</para>

			<para>
				The size can be <emphasis>undefined</emphasis> in either or both
				dimensions, which means that the component will take the minimum necessary
				space. Most components have undefined size by default, but some layouts
				have full size in horizontal direction. You can set the height or width as
				undefined with <parameter>Sizeable.SIZE_UNDEFINED</parameter> parameter
				for <methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname>.
			</para>

			<para>
				You always need to keep in mind that <emphasis>a layout with undefined
				size may not contain components with defined relative size</emphasis>,
				such as "full size". See <xref linkend="layout.settings.size"/> for
				details.
			</para>

			<para>
				The <xref linkend="components.features.sizeable.units.table"/> lists the
				available units and their codes defined in the
				<classname>Sizeable</classname> interface.
			</para>

			<table xml:id="components.features.sizeable.units.table">
				<title>Size Units</title>
				<tgroup cols="3" align="left">
					<tbody>
						<row valign="top">
							<entry><parameter>UNITS_PIXELS</parameter></entry>
							<entry>px</entry>

							<entry>The <emphasis>pixel</emphasis> is the basic
							hardware-specific measure of one physical display
							pixel.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_POINTS</parameter></entry>
							<entry>pt</entry>

							<entry>The <emphasis>point</emphasis> is a typographical unit,
							which is usually defined as 1/72 inches or about 0.35
							mm. However, on displays the size can vary significantly
							depending on display metrics.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_PICAS</parameter></entry>
							<entry>pc</entry>

							<entry>The <emphasis>pica</emphasis> is a typographical unit,
							defined as 12 points, or 1/7 inches or about 4.233 mm. On
							displays, the size can vary depending on display
							metrics.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_EM</parameter></entry>
							<entry>em</entry>

							<entry>A unit relative to the used font, the width of the
							upper-case "M" letter.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_EX</parameter></entry>
							<entry>ex</entry>

							<entry>A unit relative to the used font, the height of the
							lower-case "x" letter.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_MM</parameter></entry>
							<entry>mm</entry>

							<entry>A physical length unit, millimeters on the surface of a
							display device. However, the actual size depends on the
							display, its metrics in the operating system, and the
							browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_CM</parameter></entry>
							<entry>cm</entry>

							<entry>A physical length unit,
							<emphasis>centimeters</emphasis> on the surface of a display
							device. However, the actual size depends on the display, its
							metrics in the operating system, and the browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_INCH</parameter></entry>
							<entry>in</entry>

							<entry>A physical length unit, <emphasis>inches</emphasis> on the surface of a
							display device. However, the actual size depends on the
							display, its metrics in the operating system, and the
							browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_PERCENTAGE</parameter></entry>
							<entry>%</entry>

							<entry>A relative percentage of the available size. For
							example, for the top-level layout <parameter>100%</parameter>
							would be the full width or height of the browser window. The
							percentage value must be between 0 and 100.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				If a component inside <classname>HorizontalLayout</classname> or
				<classname>VerticalLayout</classname> has full size in the namesake
				direction of the layout, the component will expand to take all available
				space not needed by the other components. See <xref
				linkend="layout.settings.size"/> for details.
			</para>
		</section>

		<!-- section>
			<title>Buffering Data (<classname>Buffered</classname> interface)</title>
		</section>
				
		<section>
			<title>Validating Fields (<classname>Validatable</classname> interface)</title>
		</section -->
				
		<section>
			<title>Managing Input Focus</title>

			<para>
				When the user clicks on a component, the component gets the
				<emphasis>input focus</emphasis>, which is indicated by highlighting
				according to style definitions. If the component allows inputting text,
				the focus and insertion point are indicated by a cursor. Pressing the
				<keycap>Tab</keycap> key moves the focus to the component next in the
				<emphasis>focus order</emphasis>.
			</para>

			<para>
				Focusing is supported by all <classname>Field</classname> components and
				also by <classname>Upload</classname>.
			</para>

			<para>
				The focus order or <emphasis>tab index</emphasis> of a component is
				defined as a positive integer value, which you can set with
				<methodname>setTabIndex()</methodname> and get with
				<methodname>getTabIndex()</methodname>. The tab index is managed in the
				context of the application-level <classname>Window</classname> in which
				the components are contained. The focus order can therefore jump between
				two any lower-level component containers, such as sub-windows or panels.
			</para>

			<para>
				The default focus order is determined by the natural hierarchical order of
				components in the order in which they were added under their parents. The
				default tab index is 0 (zero).
			</para>

			<para>
				Giving a negative integer as the tab index removes the component from the
				focus order entirely.
			</para>

			<simplesect>
				<title>CSS Style Rules</title>

				<para>
					The component having the focus will have an additional style class
					with the <literal>-focus</literal> suffix. For example, a
					<classname>TextField</classname>, which normally has the
					<literal>v-textfield</literal> style, would additionally have the
					<literal>v-textfield-focus</literal> style.
				</para>

				<para>
					For example, the following would make a text field blue when it has
					focus.
				</para>

				<programlisting><![CDATA[.v-textfield-focus {
    background: lightblue;
}]]></programlisting>
            </simplesect>
        </section>
	</section>

	<section xml:id="components.extensions">
		<title>Component Extensions</title>

        <para>
            Components can have extensions which are attached to a component
            dynamically. Especially many add-on features are extensions.
        </para>

        <para>
            To add an extension to a component, call the <methodname>extend()</methodname>
            method in the extension.
        </para>

        <programlisting><![CDATA[TextField tf = new TextField("Hello");
layout.addComponent(tf);

// Add a simple extension
new CapsLockWarning().extend(tf);

// Add an extension that requires some parameters
CSValidator validator = new CSValidator();
validator.setRegExp("[0-9]*");
validator.setErrorMessage("Must be a number");
validator.extend(tf);]]></programlisting>
    </section>

	<section xml:id="components.label">
		<title><classname>Label</classname></title>

		<para>
			<classname>Label</classname> is a text component that displays non-editable
			text. In addition to regular text, you can also display preformatted text and
			HTML, depending on the <emphasis>content mode</emphasis> of the label.
		</para>

		<book-example id="component.label.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[// A container that is 100% wide by default
VerticalLayout layout = new VerticalLayout();

Label label = new Label("Labeling can be dangerous");
layout.addComponent(label);]]></programlisting>

        <para>
            The text will wrap around and continue on the next line if it exceeds the
            width of the <classname>Label</classname>. The default width is 100%, so the
            containing layout must also have a defined width. Some layout components have
            undefined width by default, such as <classname>HorizontalLayout</classname>,
            so you need to pay special care with them.
        </para>

		<book-example id="component.label.wrap" style="float: right"></book-example>
        <programlisting><?pocket-size 65% ?><![CDATA[// A container with a defined width. The default content layout
// of Panel is VerticalLayout, which has 100% default width.
Panel panel = new Panel("Panel Containing a Label");
panel.setWidth("300px");

panel.addComponent(
    new Label("This is a Label inside a Panel. There is " +
              "enough text in the label to make the text " +
              "wrap when it exceeds the width of the panel."));]]></programlisting>

        <para>
            As the size of the <classname>Panel</classname> in the above example is fixed
            and the width of <classname>Label</classname> is the default 100%, the text in
            the <classname>Label</classname> will wrap to fit the panel, as shown in <xref
            linkend="figure.components.label"/>.
        </para>

		<figure xml:id="figure.components.label">
			<title>The Label Component</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/label-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="120" align="center" fileref="img/components/label-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Setting <classname>Label</classname> to undefined width will cause it to not
            wrap at the end of the line, as the width of the content defines the width. If
            placed inside a layout with defined width, the <classname>Label</classname>
            will overflow the layout horizontally and, normally, be truncated.
        </para>

        <para>
            Even though <classname>Label</classname> is text and often used as a caption,
            it also has a caption, just like any other component. As with other
            components, the caption is managed by the containing layout.
        </para>

        <section xml:id="components.label.content-mode">
            <title>Content Mode</title>

            <para>
                The contents of a label are formatted depending on the content mode. By
                default, the text is assumed to be plain text and any contained
                XML-specific characters will be quoted appropriately to allow rendering
                the contents of a label in HTML in a web browser. The content mode can be
                set in the constructor or with <methodname>setContentMode()</methodname>,
                and can have the values defined in the <classname>ContentMode</classname>
                enumeration type in <package>com.vaadin.shared.ui.label</package> package:
            </para>

            <variablelist>
                <varlistentry>
                    <term><constant>TEXT</constant></term>
                    <listitem>
                        <para>
                            The default content mode where the label contains only plain
                            text. All characters are allowed, including the special
                            <literal>&lt;</literal>, <literal>&gt;</literal>, and
                            <literal>&amp;</literal> characters in XML or HTML, which are
                            quoted properly in HTML while rendering the component. This
                            is the default mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
				<term><constant>PREFORMATTED</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains preformatted text. It will
                            be, by default, rendered with a fixed-width typewriter
                            font. Preformatted text can contain line breaks, written in Java
                            with the <literal>\n</literal> escape sequence for a newline
                            character (ASCII 0x0a), or tabulator characters written with
                            <literal>\t</literal> (ASCII 0x08).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>HTML</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains (X)HTML. The content will
                            be enclosed in a DIV element having the namespace
                            "<uri>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</uri>".
                        </para>

                        <para>
                            Please note the following security and validity warnings
                            regarding the HTML content mode.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <warning>
                <title>Cross-Site Scripting Warning</title>

                <para>
                    Having <classname>Label</classname> in <constant>HTML</constant>
                    content mode allows pure HTML content. If the content comes from user
                    input, you should always carefully sanitize it to prevent cross-site
                    scripting (XSS) attacks. Please see <xref
                    linkend="advanced.security.sanitizing"/>.
                </para>

                <para>
                    Also, the validity of the HTML content is not checked when rendering
                    the component and any errors can result in an error in the browser. If
                    the content comes from an uncertain source, you should always validate
                    it before displaying it in the component.
                </para>
            </warning>

            <para>
                The following example demonstrates the use of
                <classname>Label</classname> in different modes.
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[GridLayout labelgrid = new GridLayout (2,1);

labelgrid.addComponent (new Label ("PREFORMATTED"));
labelgrid.addComponent (
    new Label ("This is a preformatted label.\n"+
               "The newline character \\n breaks the line.",
               Label.ContentMode.PREFORMATTED));

labelgrid.addComponent (new Label ("TEXT"));
labelgrid.addComponent (
    new Label ("This is a label in (plain) text mode",
               Label.ContentMode.TEXT));

labelgrid.addComponent (new Label ("HTML"));
labelgrid.addComponent (
    new Label ("<i>This</i> is an <b>HTML</b> formatted label",
               Label.ContentMode.HTML));

layout.addComponent(labelgrid);]]></programlisting>

            <para>
                The rendering will look as follows:
            </para>

            <figure>
                <title>Label Modes Rendered on Screen</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/label-modes.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="60" smallscale="100%" align="center" fileref="img/components/label-modes.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <!-- TODO Fix and re-enable 
        <section xml:id="components.label.html-mode">
            <title>Making Use of the HTML Mode</title>

            <para>
                Using the HTML modes allows inclusion of, for example, images within the
                text flow, which is not possible with any regular layout components. The
                following example includes an image loaded from a theme within the text
                flow.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[ClassResource labelimage = new ClassResource ("labelimage.jpg");
main.addComponent(new Label("Here we have an image <img src=\"" +
                            this.getRelativeLocation(labelimage) +
                            "\"/> within text.",
                            Label.ContentMode.XHTML));]]></programlisting>

            <para>
                When you use a class loader resource, the image has to be included in
                the JAR of the web application. In this case, the
                <filename>labelimage.jpg</filename> needs to be in the default
                package. When rendered in a web browser, the output will look as
                follows:
            </para>

            <figure>
                <title>Referencing An Image Resource in Label</title>
                <mediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="img/components/label-withimage.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            
            <para>
                Another solution would be to use the
                <classname>CustomLayout</classname> component, where you can write
                the component content as an HTML fragment in a theme, but such a
                solution may be too heavy for most cases.
            </para>
        </section> -->

        <section xml:id="components.label.spacing">
            <title>Spacing with a <classname>Label</classname></title>
                
            <para>
                You can use a <classname>Label</classname> to create vertical or
                horizontal space in a layout. If you need a empty "line" in a vertical
                layout, having just a label with empty text is not enough, as it will
                collapse to zero height. The same goes for a label with only whitespace as
                the label text. You need to use a non-breaking space character, either
                <literal>&amp;nbsp;</literal> or <literal>&amp;#160;</literal>:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[layout.addComponent(new Label("&nbsp;", Label.ContentMode.XHTML));]]></programlisting>

            <para>
                Using the <parameter>Label.ContentMode.PREFORMATTED</parameter> mode has the
                same effect; preformatted spaces do not collapse in a vertical layout. In
                a <classname>HorizontalLayout</classname>, the width of a space character
                may be unpredictable if the label font is proportional, so you can use the
                preformatted mode to add em-width wide spaces.
            </para>

            <para>
                If you want a gap that has adjustable width or height, you can use an
                empty label if you specify a height or width for it. For example, to
                create vertical space in a <classname>VerticalLayout</classname>:
            </para>

            <programlisting><![CDATA[Label gap = new Label();
gap.setHeight("1em");
verticalLayout.addComponent(gap);]]></programlisting>

            <para>
                You can make a flexible expanding spacer by having a relatively sized
                empty label with <literal>100%</literal> height or width and setting the
                label as expanding in the layout.
            </para>

            <programlisting><![CDATA[// A wide component bar
HorizontalLayout horizontal = new HorizontalLayout();
horizontal.setWidth("100%");

// Have a component before the gap (a collapsing cell)
Button button1 = new Button("I'm on the left");
horizontal.addComponent(button1);

// An expanding gap spacer
Label expandingGap = new Label();
expandingGap.setWidth("100%");
horizontal.addComponent(expandingGap);
horizontal.setExpandRatio(expandingGap, 1.0f);

// A component after the gap (a collapsing cell)
Button button2 = new Button("I'm on the right");
horizontal.addComponent(button2);]]></programlisting>
        </section>


		<section xml:id="components.label.css">
			<title>CSS Style Rules</title>

            <para>
                The <classname>Label</classname> component has a
                <literal>v-label</literal> overall style.
            </para>

            <para>
                The Reindeer theme includes a number of predefined styles for typical
                formatting cases. These include "<literal>h1</literal>"
                (<methodname>Reindeer.LABEL_H1</methodname>) and "<literal>h2</literal>"
                (<methodname>Reindeer.LABEL_H2</methodname>) heading styles and
                "<literal>light</literal>" (<methodname>Reindeer.LABEL_SMALL</methodname>)
                style.
            </para>
        </section>
	</section>

	<section xml:id="components.link">
		<title><classname>Link</classname></title>

		<para>
			The <classname>Link</classname> component allows making hyperlinks. References
			to locations are represented as resource objects, explained in <xref
			linkend="application.resources"/>. The <classname>Link</classname> is a
			regular HTML hyperlink, that is, an <literal>&lt;a href&gt;</literal> anchor
			element that is handled natively by the browser. Unlike when clicking a
			<classname>Button</classname>, clicking a <classname>Link</classname> does not
			cause an event on the server-side.
		</para>

		<para>
			Links to an arbitrary URL can be made by using an
			<classname>ExternalResource</classname> as follows:
		</para>

		<book-example id="component.link.basic" style="float: right"></book-example>
		<programlisting><![CDATA[// Textual link
Link link = new Link("Click Me!",
        new ExternalResource("http://vaadin.com/"));]]></programlisting>

        <para>
            You can use <methodname>setIcon()</methodname> to make image links as follows:
        </para>

		<programlisting><?pocket-size 65% ?><![CDATA[// Image link
Link iconic = new Link(null,
        new ExternalResource("http://vaadin.com/"));
iconic.setIcon(new ThemeResource("img/nicubunu_Chain.png"));

// Image + caption
Link combo = new Link("To appease both literal and visual",
        new ExternalResource("http://vaadin.com/"));
combo.setIcon(new ThemeResource("img/nicubunu_Chain.png"));]]></programlisting>

        <para>
            The resulting links are shown in <xref
            linkend="figure.components.link.basic"/>. You could add a "<literal>display:
            block</literal>" style for the icon element to place the caption below it.
        </para>

		<figure xml:id="figure.components.link.basic">
			<title><classname>Link</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/link.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="80%" align="center" fileref="img/components/link.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            With the simple constructor used in the above example, the resource is opened
            in the current window. Using the constructor that takes the target window as a
            parameter, or by setting the target window with
            <methodname>setTargetName()</methodname>, you can open the resource in another
            window, such as a popup browser window/tab. As the target name is an HTML
            <literal>target</literal> string managed by the browser, the target can be any
            window, including windows not managed by the application itself. You can use
            the special underscored target names, such as <literal>_blank</literal> to
            open the link to a new browser window or tab.
		</para>

		<book-example id="component.link.target" style="float: right"></book-example>
        <programlisting><?pocket-size 65% ?><![CDATA[// Hyperlink to a given URL
Link link = new Link("Take me a away to a faraway land",
        new ExternalResource("http://vaadin.com/"));

// Open the URL in a new window/tab
link.setTargetName("_blank");
        
// Indicate visually that it opens in a new window/tab
link.setIcon(new ThemeResource("icons/external-link.png"));
link.addStyleName("icon-after-caption");]]></programlisting>

        <para>
            Normally, the link icon is before the caption. You can have it right of the
            caption by reversing the text direction in the containing element.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[/* Position icon right of the link caption. */
.icon-after-caption {
    direction: rtl;
}
/* Add some padding around the icon. */
.icon-after-caption .v-icon {
    padding: 0 3px;
}]]></programlisting>

        <para>
            The resulting link is shown in <xref linkend="figure.components.link.new-window"/>.
        </para>

		<figure xml:id="figure.components.link.new-window">
			<title>Link That Opens a New Window</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata scale="50" align="center" fileref="img/components/link-new.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/link-new.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            With the <literal>_blank</literal> target, a normal new browser window is
            opened. If you wish to open it in a popup window (or tab), you need to give a size for
            the window with <methodname>setTargetWidth()</methodname> and
            <methodname>setTargetHeight()</methodname>. You can control the window border
            style with <methodname>setTargetBorder()</methodname>, which takes any of the
            defined border styles <parameter>TARGET_BORDER_DEFAULT</parameter>,
            <parameter>TARGET_BORDER_MINIMAL</parameter>, and
            <parameter>TARGET_BORDER_NONE</parameter>. The exact result depends on the
            browser.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Open the URL in a popup
link.setTargetName("_blank");
link.setTargetBorder(Link.TARGET_BORDER_NONE);
link.setTargetHeight(300);
link.setTargetWidth(400);]]></programlisting>

        <!-- TODO: Describe _new, _black, etc. targets and give an example. -->

		<para>
            In addition to the <classname>Link</classname> component, Vaadin allows
            alternative ways to make hyperlinks. The <classname>Button</classname>
            component has a <parameter>Reindeer.BUTTON_LINK</parameter> style name that
            makes it look like a hyperlink, while handling clicks in a server-side click
            listener instead of in the browser. Also, you can make hyperlinks (or any
            other HTML) in a <classname>Label</classname> in XHTML content mode.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><?dbfo-need height="3cm" ?><![CDATA[.v-link { }
  a { }
    .v-icon {}
    span {}]]></programlisting>

			<para>
                The overall style for the <classname>Link</classname> component is
                <literal>v-link</literal>. The root element contains the <literal>&lt;a
                href&gt;</literal> hyperlink anchor. Inside the anchor are the icon, with
                <literal>v-icon</literal> style, and the caption in a text span.
            </para>

            <para>
                Hyperlink anchors have a number of <emphasis>pseudo-classes</emphasis>
                that are active at different times. An unvisited link has
                <literal>a:link</literal> class and a visited link
                <literal>a:visited</literal>. When the mouse pointer hovers over the link,
                it will have <varname>a:hover</varname>, and when the mouse button is
                being pressed over the link, the <literal>a:active</literal> class. When
                combining the pseudo-classes in a selector, please notice that
                <literal>a:hover</literal> must come after an <literal>a:link</literal>
                and <literal>a:visited</literal>, and <literal>a:active</literal> after
                the <literal>a:hover</literal>.
			</para>
		</simplesect>
	</section>

	<section xml:id="components.textfield">
		<title><classname>TextField</classname></title>

        <indexterm xml:id="term.components.textfield" class="startofrange">
            <primary><classname>TextField</classname></primary>
        </indexterm>

		<para>
			<classname>TextField</classname> is one of the most commonly used user
			interface components. It is a <classname>Field</classname> component that
			allows entering textual values using keyboard.
		</para>

		<para>
			The following example creates a simple text field:
		</para>

        <book-example id="component.textfield.basic" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create a text field
TextField tf = new TextField("A Field");
        
// Put some initial content in it
tf.setValue("Stuff in the field");]]></programlisting>

        <para>
            See the result in <xref linkend="figure.components.textfield.basic"/>.
        </para>

		<figure xml:id="figure.components.textfield.basic">
			<title><classname>TextField</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textfield-example.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="90%" align="center" fileref="img/components/textfield-example.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Value changes are handled with a
            <classname>Property.ValueChangeListener</classname>, as in most other
            fields. The value can be acquired with <methodname>getValue()</methodname>
            directly from the text field, as is done in the example below, or from the
            property reference of the event.
        </para>

        <book-example id="component.textfield.inputhandling" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[// Handle changes in the value
tf.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Assuming that the value type is a String
        String value = (String) tf.getValue();

        // Do something with the value
        Notification.show("Value is:", value);
    }
});
        
// Fire value changes immediately when the field loses focus
tf.setImmediate(true);]]></programlisting>

        <para>
            Much of the API of <classname>TextField</classname> is defined in
            <classname>AbstractTextField</classname>, which allows different kinds of text
            input fields, such as rich text editors, which do not share all the features
            of the single-line text fields.
        </para>

		<figure xml:id="figure.components.textfield.api">
			<title>Text Field Class Relationships</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textfield-diagram-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="75%" align="center" fileref="img/components/textfield-diagram-lo.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <section xml:id="components.textfield.databinding">
            <title>Data Binding</title>

            <book-example id="component.textfield.valuetype" style="float: right"></book-example>
            <para>
                <classname>TextField</classname> edits <classname>String</classname>
                values, but you can bind it to any property type that has a proper
                converter, as described in <xref
                linkend="datamodel.properties.converter"/>.
            </para>

            <book-example id="component.textfield.databinding" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an initial data model. As Double is unmodificable and
// doesn't support assignment from String, the object is
// reconstructed in the wrapper when the value is changed.
Double trouble = 42.0;
        
// Wrap it in a property data source
final ObjectProperty<Double> property =
    new ObjectProperty<Double>(trouble);
        
// Create a text field bound to it
// (StringToDoubleConverter is used automatically)
TextField tf = new TextField("The Answer", property);
tf.setImmediate(true);

// Show that the value is really written back to the
// data source when edited by user.
Label feedback = new Label(property);
feedback.setCaption("The Value");]]></programlisting>

            <para>
                When you put a <classname>Table</classname> in editable mode or create
                fields with a <classname>FieldGroup</classname>, the
                <classname>DefaultFieldFactory</classname> creates a
                <classname>TextField</classname> for almost every property type by
                default. You often need to make a custom factory to customize the creation
                and to set the field tooltip, validation, formatting, and so on.
            </para>

            <para>
                See <xref linkend="datamodel"/> for more details on data binding, field
                factories for <classname>Table</classname> in <xref
                linkend="components.table.editing"/>, and <xref
                linkend="datamodel.itembinding"/> regarding forms.
            </para>

            <book-example id="component.textfield.beanbinding">
                Bean Binding
            </book-example>
        </section>

        <section xml:id="components.textfield.length">
            <title>String Length</title>

            <para>
                The <methodname>setMaxLength()</methodname> method sets the maximum length
                of the input string so that the browser prevents the user from entering a
                longer one. As a security feature, the input value is automatically
                truncated on the server-side, as the maximum length setting could be
                bypassed on the client-side. The maximum length property is defined at
                <classname>AbstractTextField</classname> level.
            </para>

            <para>
                Notice that the maximum length setting does not affect the width of the
                field. You can set the width with <methodname>setWidth()</methodname>, as
                with other components. Using <emphasis>em</emphasis> widths is recommended
                to better approximate the proper width in relation to the size of the used
                font. There is no standard way in HTML for setting the width exactly to a
                number of letters (in a monospaced font). You can trick your way around
                this restriction by putting the text field in an undefined-width
                <classname>VerticalLayout</classname> together with an undefined-width
                <classname>Label</classname> that contains a sample text, and setting the
                width of the text field as 100%. The layout will get its width from the
                label, and the text field will use that.
            </para>

            <book-example id="component.textfield.widthfitting">
                Fitting TextField width to fixed input length
            </book-example>
        </section>

        <section xml:id="components.textfield.nullvalues">
            <title>Handling Null Values</title>

            <indexterm xml:id="term.components.textfield.nullvalues" class="startofrange">
                <primary>Null representation</primary>
            </indexterm>

            <para>
                <indexterm><primary><methodname>setNullRepresentation()</methodname></primary></indexterm>

                As with any field, the value of a <classname>TextField</classname> can be
                set as <parameter>null</parameter>. This occurs most commonly when you
                create a new field without setting a value for it or bind the field value
                to a data source that allows null values. In such case, you might want to
                show a special value that stands for the null value. You can set the null
                representation with the <methodname>setNullRepresentation()</methodname>
                method. Most typically, you use an empty string for the null
                representation, unless you want to differentiate from a string that is
                explicitly empty. The default null representation is
                "<literal>null</literal>", which essentially warns that you may have
                forgotten to initialize your data objects properly. 
            </para>

            <para>
                <indexterm><primary><methodname>setNullSettingAllowed()</methodname></primary></indexterm>

                The <methodname>setNullSettingAllowed()</methodname> controls whether the
                user can actually input a null value by using the null value
                representation. If the setting is <literal>false</literal>, which is the
                default, inputting the null value representation string sets the value as
                the literal value of the string, not null. This default assumption is a
                safeguard for data sources that may not allow null values.
            </para>

            <book-example id="component.textfield.nullvaluerepresentation" style="float: right"></book-example>

<programlisting><?pocket-size 75% ?><![CDATA[// Create a text field without setting its value
TextField tf = new TextField("Field Energy (J)");
tf.setNullRepresentation("-- null-point energy --");

// The null value is actually the default
tf.setValue(null);
        
// Allow user to input the null value by
// its representation
tf.setNullSettingAllowed(true);

// Feedback to see the value
Label value = new Label(tf);
value.setCaption("Current Value:");]]></programlisting>

            <para>
                The <classname>Label</classname>, which is bound to the value of the
                <classname>TextField</classname>, displays a null value as empty. The
                resulting user interface is shown in <xref
                linkend="figure.components.textfield.nullvalues"/>.
            </para>

            <figure xml:id="figure.components.textfield.nullvalues">
                <title>Null Value Representation</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-nullrepresentation.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="90%" align="center" fileref="img/components/textfield-nullrepresentation.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <indexterm startref="term.components.textfield.nullvalues" class="endofrange"/>
        </section>

        <!--section>
            <title>Formatting Text Field Values</title>

            <para>
        TODO
            </para>
        </section -->

        <section xml:id="components.textfield.textchangeevents">
            <title>Text Change Events</title>

            <indexterm xml:id="term.components.textfield.textchangeevents" class="startofrange">
                <primary><classname>Text change events</classname></primary>
            </indexterm>

            <para>
                Often you want to receive a change event immediately when the text field
                value changes. The <emphasis>immediate</emphasis> mode is not literally
                immediate, as the changes are transmitted only after the field loses
                focus. In the other extreme, using keyboard events for every keypress
                would make typing unbearably slow and also processing the keypresses is
                too complicated for most purposes. <emphasis>Text change events</emphasis>
                are transmitted asynchronously soon after typing and do not block typing
                while an event is being processed.
            </para>

            <para>
                Text change events are received with a
                <classname>TextChangeListener</classname>, as is done in the following
                example that demonstrates how to create a text length counter:
            </para>

            <book-example id="component.textfield.textchangeevents" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// Text field with maximum length
final TextField tf = new TextField("My Eventful Field");
tf.setValue("Initial content");
tf.setMaxLength(20);

// Counter for input length
final Label counter = new Label();
counter.setValue(tf.toString().length() +
                 " of " + tf.getMaxLength());
        
// Display the current length interactively in the counter
tf.addListener(new TextChangeListener() {
    public void textChange(TextChangeEvent event) {
        int len = event.getText().length();
        counter.setValue(len + " of " + tf.getMaxLength());
    }
});

// This is actually the default
tf.setTextChangeEventMode(TextChangeEventMode.LAZY);]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textfield.textchangeevents"/>.
            </para>

            <figure xml:id="figure.components.textfield.textchangeevents">
                <title>Text Change Events</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-textchangeevents.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="70%" align="center" fileref="img/components/textfield-textchangeevents.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The <emphasis>text change event mode</emphasis> defines how quickly the
                changes are transmitted to the server and cause a server-side
                event. Lazier change events allow sending larger changes in one event if
                the user is typing fast, thereby reducing server requests.
            </para>

            <para>
                You can set the text change event mode of a
                <classname>TextField</classname> with
                <methodname>setTextChangeEventMode()</methodname>. The allowed modes are
                defined in <classname>TextChangeEventMode</classname> class and are the
                following:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.LAZY</parameter> (default)</term>
                    <listitem>
                        <para>
                            An event is triggered when there is a pause in editing the
                            text. The length of the pause can be modified with
                            <methodname>setInputEventTimeout()</methodname>. As with the
                            <parameter>TIMEOUT</parameter> mode, a text change event is
                            forced before a possible
                            <classname>ValueChangeEvent</classname>, even if the user did
                            not keep a pause while entering the text.
                        </para>

                        <para>
                            This is the default mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.TIMEOUT</parameter></term>
                    <listitem>
                        <para>
                            A text change in the user interface causes the event to be
                            communicated to the application after a timeout period. If
                            more changes are made during this period, the event sent to
                            the server-side includes the changes made up to the last
                            change. The length of the timeout can be set with
                            <methodname>setInputEventTimeout()</methodname>.
                        </para>

                        <para>
                            If a <classname>ValueChangeEvent</classname> would occur
                            before the timeout period, a
                            <classname>TextChangeEvent</classname> is triggered before it,
                            on the condition that the text content has changed since the
                            previous <classname>TextChangeEvent</classname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.EAGER</parameter></term>
                    <listitem>
                        <para>
                            An event is triggered immediately for every change in the text
                            content, typically caused by a key press. The requests are
                            separate and are processed sequentially one after
                            another. Change events are nevertheless communicated
                            asynchronously to the server, so further input can be typed
                            while event requests are being processed.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <indexterm startref="term.components.textfield.textchangeevents" class="endofrange"/>
        </section>

        <section xml:id="components.textfield.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textfield { }]]></programlisting>

            <para>
                The HTML structure of <classname>TextField</classname> is extremely simple,
                consisting only of an element with <literal>v-textfield</literal> style.
            </para>

            <para>
                For example, the following custom style uses dashed border:
            </para>

            <book-example id="component.textfield.css" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[.v-textfield-dashing {
    border:     thin dashed;
    background: white; /* Has shading image by default */
}]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textfield.css"/>.
            </para>

            <figure xml:id="figure.components.textfield.css">
                <title>Styling TextField with CSS</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-css.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/textfield-css.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The style name for <classname>TextField</classname> is also used in
                several components that contain a text input field, even if the text input
                is not an actual <classname>TextField</classname>. This ensures that the
                style of different text input boxes is similar.
            </para>
        </section>

        <indexterm startref="term.components.textfield" class="endofrange"/>
	</section>

	<section xml:id="components.textarea">
		<title><classname>TextArea</classname></title>

		<para>
			<classname>TextArea</classname> is a multi-line version of the
			<classname>TextField</classname> component described in <xref
			linkend="components.textfield"/>.
		</para>

		<para>
			The following example creates a simple text area:
		</para>

        <book-example id="component.textarea.basic" style="float: right"></book-example>

<programlisting><?pocket-size 65% ?><![CDATA[// Create the area
TextArea area = new TextArea("Big Area");
        
// Put some content in it
area.setValue("A row\n"+
              "Another row\n"+
              "Yet another row");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.textarea"/>.
        </para>

		<figure xml:id="figure.components.textarea">
			<title><classname>TextArea</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textarea-basic.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/textarea-basic.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            You can set the number of visible rows with <methodname>setRows()</methodname>
            or use the regular <methodname>setHeight()</methodname> to define the height
            in other units. If the actual number of rows exceeds the number, a vertical
            scrollbar will appear. Setting the height with
            <methodname>setRows()</methodname> leaves space for a horizontal scrollbar, so
            the actual number of visible rows may be one higher if the scrollbar is not
            visible.
        </para>

        <para>
            You can set the width with the regular <methodname>setWidth()</methodname>
            method. Setting the size with the <emphasis>em</emphasis> unit, which is
            relative to the used font size, is recommended.
        </para>

        <simplesect xml:id="components.textarea.wordwrap">
            <title>Word Wrap</title>

            <para>
                The <methodname>setWordwrap()</methodname> sets whether long lines are
                wrapped (<literal>true</literal> - default) when the line length reaches
                the width of the writing area. If the word wrap is disabled
                (<literal>false</literal>), a vertical scrollbar will appear instead. The
                word wrap is only a visual feature and wrapping a long line does not
                insert line break characters in the field value; shortening a wrapped line
                will undo the wrapping.
            </para>
            
            <book-example id="component.textarea.wordwrap" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[TextArea area1 = new TextArea("Wrapping");
area1.setWordwrap(true); // The default
area1.setValue("A quick brown fox jumps over the lazy dog");

TextArea area2 = new TextArea("Nonwrapping");
area2.setWordwrap(false);
area2.setValue("Victor jagt zw&ouml;lf Boxk&auml;mpfer quer "+
               "&uuml;ber den Sylter Deich");]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textarea.wordwrap"/>.
            </para>

            <figure xml:id="figure.components.textarea.wordwrap">
                <title>Word Wrap in <classname>TextArea</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textarea-wordwrap.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/textarea-wordwrap.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

        <simplesect xml:id="components.textarea.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textarea { }]]></programlisting>

            <para>
                The HTML structure of <classname>TextArea</classname> is extremely simple,
                consisting only of an element with <literal>v-textarea</literal> style.
            </para>

            <book-example id="component.textarea.css">CSS Styling</book-example>
        </simplesect>
	</section>

	<section xml:id="components.passwordfield">
		<title><classname>PasswordField</classname></title>

        <para>
            The <classname>PasswordField</classname> is a variant of
            <classname>TextField</classname> that hides the typed input from visual
            inspection.
        </para>

        <book-example id="component.passwordfield.basic" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[PasswordField tf = new PasswordField("Keep it secret");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.passwordfield.basic"/>.
        </para>

        <figure xml:id="figure.components.passwordfield.basic">
            <title><classname>PasswordField</classname></title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/passwordfield-basic.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata smallscale="100%" align="center" fileref="img/components/passwordfield-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            You should note that the <classname>PasswordField</classname> hides the input
            only from "over the shoulder" visual observation. Unless the server connection
            is encrypted with a secure connection, such as HTTPS, the input is transmitted
            in clear text and may be intercepted by anyone with low-level access to the
            network. Also phishing attacks that intercept the input in the browser may be
            possible by exploiting JavaScript execution security holes in the browser.
        </para>

        <simplesect xml:id="components.passwordfield.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textfield { }]]></programlisting>

            <para>
                The <classname>PasswordField</classname> does not have its own CSS style
                name but uses the same <literal>v-textfield</literal> style as the regular
                <classname>TextField</classname>. See <xref
                linkend="components.textfield.css"/> for information on styling it.
            </para>

            <book-example id="component.passwordfield.css">CSS Styling</book-example>
        </simplesect>
    </section>

	<section xml:id="components.richtextarea">
		<title><classname>RichTextArea</classname></title>

		<para>
			The <classname>RichTextArea</classname> field allows entering or editing
			formatted text. The toolbar provides all basic editing functionalities. The
			text content of <classname>RichTextArea</classname> is represented in HTML
			format. <classname>RichTextArea</classname> inherits
			<classname>TextField</classname> and does not add any API functionality over
			it. You can add new functionality by extending the client-side components
			<classname>VRichTextArea</classname> and
			<classname>VRichTextToolbar</classname>.
		</para>

		<para>
			As with <classname>TextField</classname>, the textual content of the rich text
			area is the <classname>Property</classname> of the field and can be set with
			<methodname>setValue()</methodname> and read with
			<methodname>getValue()</methodname>.
		</para>

		<programlisting><![CDATA[// Create a rich text area
final RichTextArea rtarea = new RichTextArea();
rtarea.setCaption("My Rich Text Area");

// Set initial content as HTML
rtarea.setValue("<h1>Hello</h1>\n" +
    "<p>This rich text area contains some text.</p>");]]></programlisting>
			
		<figure>
			<title>Rich Text Area Component</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/richtextarea-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="130" align="center" fileref="img/components/richtextarea-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Above, we used context-specific tags such as <literal>&lt;h1&gt;</literal> in
			the initial HTML content. The rich text area component does not allow creating
			such tags, only formatting tags, but it does preserve them unless the user
			edits them away. Any non-visible whitespace such as the new line character
			(<literal>\n</literal>) are removed from the content. For example, the value
			set above will be as follows when read from the field with
			<methodname>getValue()</methodname>:
		</para>
		
		<programlisting><![CDATA[<h1>Hello</h1> <p>This rich text area contains some text.</p>]]></programlisting>

		<para>
			The rich text area is one of the few components in Vaadin that contain textual
			labels. The selection boxes in the toolbar are in English and currently can
			not be localized in any other way than by inheriting or reimplementing the
			client-side <classname>VRichTextToolbar</classname> widget. The buttons can be
			localized simply with CSS by downloading a copy of the toolbar background
			image, editing it, and replacing the default toolbar. The toolbar is a single
			image file from which the individual button icons are picked, so the order of
			the icons is different from the rendered. The image file depends on the
			client-side implementation of the toolbar.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[
.v-richtextarea-richtextexample .gwt-ToggleButton
.gwt-Image {
  background-image: url(img/richtextarea-toolbar-fi.png)
                    !important;
}]]></programlisting>

		<figure>
			<title>Regular English and a Localized Rich Text Area Toolbar</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="img/components/richtextarea-toolbar-whitebg.png"/>
				</imageobject>
			</mediaobject>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="img/components/richtextarea-toolbar-mod-whitebg.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<simplesect>
			<title>Cross-Site Scripting with <classname>RichTextArea</classname></title>

			<para>
				The user input from a <classname>RichTextArea</classname> is transmitted
				as XHTML from the browser to server-side and is not sanitized. As the
				entire purpose of the <classname>RichTextArea</classname> component is to
				allow input of formatted text, you can not sanitize it just by removing
				all HTML tags. Also many attributes, such as <parameter>style</parameter>,
				should pass through the sanitization.
			</para>

			<para>
				See <xref linkend="advanced.security.sanitizing"/> for more details on
				Cross-Site scripting vulnerabilities and sanitization of user input.
			</para>
		</simplesect>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-richtextarea { }
.v-richtextarea .gwt-RichTextToolbar { }
.v-richtextarea .gwt-RichTextArea { }]]></programlisting>

			<para>
				The rich text area consists of two main parts: the toolbar with overall
				style <literal>.gwt-RichTextToolbar</literal> and the editor area with
				style <literal>.gwt-RichTextArea</literal>. The editor area obviously
				contains all the elements and their styles that the HTML content
				contains. The toolbar contains buttons and drop-down list boxes with the
				following respective style names:
			</para>

			<programlisting><![CDATA[.gwt-ToggleButton { }
.gwt-ListBox { }]]></programlisting>

		</simplesect>
		
	</section>

	<section xml:id="components.datefield">
		<title>Date and Time Input with <classname>DateField</classname></title>
		<para>
			The <classname>DateField</classname> component provides the means to display
			and input date and time. The field comes in two variations:
			<classname>PopupDateField</classname>, with a numeric input box and a popup
			calendar view, and <classname>InlineDateField</classname>, with the calendar
			view always visible. The <classname>DateField</classname> base class defaults
			to the popup variation.
		</para>

        <para>
            The example below illustrates the use of the <classname>DateField</classname>
            baseclass, which is equivalent to the
            <classname>PopupDateField</classname>. We set the initial time of the date
            field to current time by using the default constructor of the
            <classname>java.util.Date</classname> class.
        </para>

        <programlisting><![CDATA[// Create a DateField with the default style
DateField date = new DateField();
	
// Set the date and time to present
date.setValue(new Date());]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.datefield.basic"/>.
        </para>

		<figure xml:id="figure.components.datefield.basic">
			<title><classname>DateField</classname> (<classname>PopupDateField</classname>) for Selecting Date and Time</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/datefield-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/datefield-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <section xml:id="components.datefield.popupdatefield">
            <title><classname>PopupDateField</classname></title>

            <para>
                The <classname>PopupDateField</classname> provides date input using a text
                box for the date and time. As the <classname>DateField</classname>
                defaults to this component, the use is exactly the same as described
                earlier. Clicking the handle right of the date opens a popup view for
                selecting the year, month, and day, as well as time. Also the
                <keycap>Down</keycap> key opens the popup. Once opened, the user can
                navigate the calendar using the cursor keys.
            </para>

            <para>
                The date and time selected from the popup are displayed in the text box
                according to the default date and time format of the current locale, or as
                specified with <methodname>setDateFormat()</methodname>. The same format
                definitions are used for parsing user input.
            </para>

            <simplesect xml:id="components.datefield.popupdatefield.format">
                <title>Date and Time Format</title>

                <para>
                    The date and time are normally displayed according to the default
                    format for the current locale (see <xref
                    linkend="components.features.locale"/>). You can specify a custom
                    format with <methodname>setDateFormat()</methodname>. It takes a
                    format string that follows the format of the
                    <classname>SimpleDateFormat</classname> in Java.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[// Display only year, month, and day in ISO format
date.setDateFormat("yyyy-MM-dd");]]></programlisting>

                <para>
                    The result is shown in <xref
                    linkend="figure.components.datefield.popupdatefield.format"/>.
                </para>

                <figure xml:id="figure.components.datefield.popupdatefield.format">
                    <title>Custom Date Format for
                    <classname>PopupDateField</classname></title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/datefield-formatting.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata smallscale="75%" align="center" fileref="img/components/datefield-formatting.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    The same format specification is also used for parsing user-input date
                    and time, as described later. 
                </para>
            </simplesect>

            <simplesect>
                <title>Handling Malformed User Input</title>

                <para>
                    A user can easily input a malformed or otherwise invalid date or
                    time. <classname>DateField</classname> has two validation layers:
                    first on the client-side and then on the server-side.
                </para>

                <para>
                    The validity of the entered date is first validated on the
                    client-side, immediately when the input box loses focus. If the date
                    format is invalid, the <literal>v-datefield-parseerror</literal> style
                    is set. Whether this causes a visible indication of a problem depends
                    on the theme. The built-in <literal>reindeer</literal> theme does not
                    shown any indication by default, making server-side handling of the
                    problem more convenient.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.mydate.v-datefield-parseerror .v-textfield {
    background: pink;
}]]></programlisting>

                <para>
                    The <methodname>setLenient(true)</methodname> setting enables relaxed
                    interpretation of dates, so that invalid dates, such as February 30th
                    or March 0th, are wrapped to the next or previous month, for example.
                </para>

                <para>
                    The server-side validation phase occurs when the date value is sent to
                    the server. If the date field is set in immediate state, it occurs
                    immediately after the field loses focus. Once this is done and if the
                    status is still invalid, an error indicator is displayed beside the
                    component. Hovering the mouse pointer over the indicator shows the
                    error message.
                </para>

                <para>
                    You can handle the errors by overriding the
                    <methodname>handleUnparsableDateString()</methodname> method. The
                    method gets the user input as a string parameter and can provide a
                    custom parsing mechanism, as shown in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a date field with a custom parsing and a
// custom error message for invalid format
PopupDateField date = new PopupDateField("My Date") {
    @Override
    protected Date handleUnparsableDateString(String dateString)
    throws Property.ConversionException {
        // Try custom parsing
        String fields[] = dateString.split("/");
        if (fields.length >= 3) {
            try {
                int year  = Integer.parseInt(fields[0]);
                int month = Integer.parseInt(fields[1])-1;
                int day   = Integer.parseInt(fields[2]);
                GregorianCalendar c =
                    new GregorianCalendar(year, month, day);
                return c.getTime();
            } catch (NumberFormatException e) {
                throw new Property.
                    ConversionException("Not a number");
            }
        }
        
        // Bad date
        throw new Property.
            ConversionException("Your date needs two slashes");
    }
};
        
// Display only year, month, and day in slash-delimited format
date.setDateFormat("yyyy/MM/dd");

// Don't be too tight about the validity of dates
// on the client-side
date.setLenient(true);]]></programlisting>

                <para>
                    The handler method must either return a parsed
                    <classname>Date</classname> object or throw a
                    <classname>ConversionException</classname>. Returning
                    <parameter>null</parameter> will set the field value to
                    <parameter>null</parameter> and clear the input box.
                </para>
            </simplesect>

            <simplesect>
                <title>Customizing the Error Message</title>

                <para>
                    In addition to customized parsing, overriding the handler method for
                    unparseable input is useful for internationalization and other
                    customization of the error message. You can also use it for another
                    way for reporting the errors, as is done in the example below:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a date field with a custom error message for invalid format
PopupDateField date = new PopupDateField("My Date") {
    @Override
    protected Date handleUnparsableDateString(String dateString)
    throws Property.ConversionException {
        // Have a notification for the error
        Notification.show(
                "Your date needs two slashes",
                Notification.TYPE_WARNING_MESSAGE);
        
        // A failure must always also throw an exception
        throw new Property.ConversionException("Bad date");
    }
};]]></programlisting>

                <para>
                    If the input is invalid, you should always throw the exception;
                    returning a <parameter>null</parameter> value would make the input
                    field empty, which is probably undesired.
                </para>
            </simplesect>

            <simplesect>
                <title>Input Prompt</title>

                <para>
                    Like other fields that have a text box,
                    <classname>PopupDateField</classname> allows an input prompt that is
                    visible until the user has input a value. You can set the prompt with
                    <methodname>setInputPrompt</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[PopupDateField date = new PopupDateField();

// Set the prompt
date.setInputPrompt("Select a date");
        
// Set width explicitly to accommodate the prompt
date.setWidth("10em");]]></programlisting>

                <para>
                    The date field doesn't automatically scale to accommodate the prompt,
                    so you need to set it explicitly with
                    <methodname>setWidth()</methodname>.
                </para>

                <para>
                    The input prompt is not available in the
                    <classname>DateField</classname> superclass.
                </para>
            </simplesect>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-datefield, v-datefield-popupcalendar {}
  .v-textfield, v-datefield-textfield {}
  .v-datefield-button {}]]></programlisting>

                <para>
                    The top-level element of <classname>DateField</classname> and all its
                    variants have <literal>v-datefield</literal> style. The base class and
                    the <classname>PopupDateField</classname> also have the
                    <literal>v-datefield-popupcalendar</literal> style.
                </para>
                
                <para>
                    In addition, the top-level element has a style that indicates the
                    resolution, with <literal>v-datefield-</literal> basename and an
                    extension, which is one of <literal>full</literal>,
                    <literal>day</literal>, <literal>month</literal>, or
                    <literal>year</literal>. The <literal>-full</literal> style is enabled
                    when the resolution is smaller than a day. These styles are used
                    mainly for controlling the appearance of the popup calendar.
                </para>

                <para>
                    The text box has <literal>v-textfield</literal> and
                    <literal>v-datefield-textfield</literal> styles, and the calendar
                    button <literal>v-datefield-button</literal>.
                </para>

                <para>
                    Once opened, the calendar popup has the following styles at the top
                    level:
                </para>

                <programlisting><![CDATA[.v-datefield-popup {}
  .v-popupcontent {}
    .v-datefield-calendarpanel {}]]></programlisting>

                <para>
                    The top-level element of the floating popup calendar has
                    <literal>.v-datefield-popup</literal> style. Observe that the popup
                    frame is outside the HTML structure of the component, hence it is not
                    enclosed in the <literal>v-datefield</literal> element and does not
                    include any custom styles.

                    <!-- NOTE: May be changed in #5752. -->

                    The content in the <literal>v-datefield-calendarpanel</literal> is the
                    same as in <classname>InlineDateField</classname>, as described in
                    <xref linkend="components.datefield.calendar"/>.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.datefield.calendar">
			<title><classname>InlineDateField</classname></title>

			<para>
				The <classname>InlineDateField</classname> provides a date picker
				component with a month view. The user can navigate months and years by
				clicking the appropriate arrows. Unlike with the popup variant, the month
				view is always visible in the inline field.
			</para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Create a DateField with the default style
InlineDateField date = new InlineDateField();
    
// Set the date and time to present
date.setValue(new java.util.Date());]]></programlisting>

            <para>
                The result is shown in <xref
                linkend="figure.components.datefield.inlinedatefield"/>.
            </para>

            <figure xml:id="figure.components.datefield.inlinedatefield">
                <title>Example of the <classname>InlineDateField</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/datefield-inlinedatefield.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="150" align="center" fileref="img/components/datefield-inlinedatefield.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The user can also navigate the calendar using the cursor keys.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-datefield {}
  .v-datefield-calendarpanel {}
    .v-datefield-calendarpanel-header {}
      .v-datefield-calendarpanel-prevyear {}
      .v-datefield-calendarpanel-prevmonth {}
      .v-datefield-calendarpanel-month {}
      .v-datefield-calendarpanel-nextmonth {}
      .v-datefield-calendarpanel-nextyear {}
    .v-datefield-calendarpanel-body {}
      .v-datefield-calendarpanel-weekdays,
      .v-datefield-calendarpanel-weeknumbers {}
        .v-first {}
        .v-last {}
      .v-datefield-calendarpanel-weeknumber {}
      .v-datefield-calendarpanel-day {}
    .v-datefield-calendarpanel-time {}
      .v-datefield-time {}
        .v-select {}
        .v-label {}]]></programlisting>

                <para>
                    The top-level element has the <literal>v-datefield</literal> style. In
                    addition, the top-level element has a style name that indicates the
                    resolution of the calendar, with <literal>v-datefield-</literal>
                    basename and an extension, which is one of <literal>full</literal>,
                    <literal>day</literal>, <literal>month</literal>, or
                    <literal>year</literal>. The <literal>-full</literal> style is enabled
                    when the resolution is smaller than a day.
                </para>

                <para>
                    The <literal>v-datefield-calendarpanel-weeknumbers</literal> and
                    <literal>v-datefield-calendarpanel-weeknumber</literal> styles are
                    enabled when the week numbers are enabled. The former controls the
                    appearance of the weekday header and the latter the actual week
                    numbers.
                </para>

                <para>
                    The other style names should be self-explanatory. For weekdays, the
                    <literal>v-first</literal> and <literal>v-last</literal> styles allow
                    making rounded endings for the weekday bar.
                </para>
            </simplesect>
		</section>

		<section>
            <title>Time Resolution</title>

            <para>
                The <classname>DateField</classname> displays dates by default. It can
                also display the time in hours and minutes, or just the month or year. The
                visibility of the input components is controlled by <emphasis>time
                resolution</emphasis>, which can be set with
                <methodname>setResolution()</methodname> method. The method takes as its
                parameters the lowest visible component, typically
                <parameter>DateField.Resolution.DAY</parameter> for just dates and
                <parameter>DateField.Resolution.MIN</parameter> for dates with time in
                hours and minutes. Please see the API Reference for the complete list of
                resolution parameters.
            </para>
        </section>

		<section>
			<title>DateField Locale</title>

			<para>
				The date and time are displayed according to the locale of the user, as
				reported by the browser. You can set a custom locale with the
				<methodname>setLocale()</methodname> method of
				<classname>AbstractComponent</classname>, as described in <xref
				linkend="components.features.locale"/>. Only Gregorian calendar is
				supported.
			</para>
		</section>
	</section>

	<section xml:id="components.button">
		<title><classname>Button</classname></title>

		<para>
			The <classname>Button</classname> is a user interface component that is
			normally used for finalizing input and initiating some action. When the user
			clicks a button, a <classname>Button.ClickEvent</classname> is emitted. A
			listener that inherits the <classname>Button.ClickListener</classname>
			interface can handle clicks with the <methodname>buttonClick()</methodname>
			method.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[public class TheButton extends CustomComponent
                       implements Button.ClickListener {
    Button thebutton;

    public TheButton() {
        // Create a Button with the given caption.
        thebutton = new Button ("Do not push this button");
        
        // Listen for ClickEvents.
        thebutton.addListener(this);

        setCompositionRoot(thebutton);
    }
    
    /** Handle click events for the button. */
    public void buttonClick (Button.ClickEvent event) {
        thebutton.setCaption ("Do not push this button again");
    }
}]]></programlisting>

		<figure>
			<title>An Example of a Button</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="150" align="center" fileref="img/components/button-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			As a user interface often has several buttons, you can differentiate
			between them either by comparing the <classname>Button</classname>
			object reference returned by the <methodname>getButton()</methodname>
			method of <classname>Button.ClickEvent</classname> to a kept
			reference or by using a separate listener method for each button. The
			listening object and method can be given to the constructor. For a
			detailed description of these patterns together with some examples,
			please see <xref linkend="architecture.events"/>.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-button { }]]></programlisting>

			<para>
				The exact CSS style name can be different if a <classname>Button</classname>
				has the <parameter>switchMode</parameter> attribute enabled. See the
				alternative CSS styles below.
			</para>

            <para>
                Adding the "<literal>small</literal>" style name enables a smaller style
                for the <classname>Button</classname>. You can also use the
                <parameter>BUTTON_SMALL</parameter> constant in
                <classname>Runo</classname> and <classname>Reindeer</classname> theme
                classes as well. The <classname>BaseTheme</classname> class also has a
                <parameter>BUTTON_LINK</parameter> style, with "<literal>link</literal>"
                style name, which makes the button look like a hyperlink.
            </para>
		</simplesect>
	</section>

	<section xml:id="components.checkbox">
		<title><classname>CheckBox</classname></title>

		<para>
			<classname>CheckBox</classname> is a two-state selection component that can be
			either checked or unchecked. The caption of the check box will be placed right
			of the actual check box. Vaadin provides two ways to create check boxes:
			individual check boxes with the <classname>CheckBox</classname> component
			described in this section and check box groups with the
			<classname>OptionGroup</classname> component in multiple selection mode, as
			described in <xref linkend="components.selecting.optiongroup"/>.
		</para>

		<para>
			Clicking on a check box will change its state. The state is a
			<classname>Boolean</classname> property that you can set with the
			<methodname>setValue()</methodname> method and obtain with the
			<methodname>getValue()</methodname> method of the
			<classname>Property</classname> interface.  Changing the value of a check box
			will cause a <classname>ValueChangeEvent</classname>, which can be handled by
			a <classname>ValueChangeListener</classname>.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[// A check box with default state (not checked, false).
final CheckBox checkbox1 = new CheckBox("My CheckBox");
main.addComponent(checkbox1);

// Another check box with explicitly set checked state.
final CheckBox checkbox2 = new CheckBox("Checked CheckBox");
checkbox2.setValue(true);
main.addComponent(checkbox2);

// Make some application logic. We use anonymous listener
// classes here. The above references were defined as final
// to allow accessing them from inside anonymous classes.
checkbox1.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Copy the value to the other checkbox.
        checkbox2.setValue(checkbox1.getValue());
    }
});
checkbox2.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Copy the value to the other checkbox.
        checkbox1.setValue(checkbox2.getValue());
    }
});]]></programlisting>

		<figure>
			<title>An Example of a Check Box</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="150" align="center" fileref="img/components/checkbox-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			For an example on the use of check boxes in a table, see <xref
			linkend="components.table"/>.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-checkbox { }
  .v-checkbox > input { }
  .v-checkbox > label { }]]></programlisting>

            <para>
                The top-level element of a <classname>CheckBox</classname> has the
                <literal>v-checkbox</literal> style. It contains two sub-elements: the
                actual check box <literal>input</literal> element and the
                <literal>label</literal> element. If you want to have the label on the
                left, you can change the positions with "<literal>direction:
                rtl</literal>" for the top element.
            </para>
		</simplesect>
	</section>

	<section xml:id="components.selecting">
		<title>Selecting Items</title>

		<para>
			Vaadin gives many alternatives for selecting one or more items from a list,
			using drop-down and regular lists, radio button and check box groups, tables,
			trees, and so on.
		</para>

		<para>
			The core library includes the following selection components, all based on the
			<classname>AbstractSelect</classname> class:
		</para>

        <variablelist>
            <varlistentry>
                <term><classname>Select</classname></term>
                <listitem>
                    In single selection mode, a drop-down list with a text input area,
                    which the user can use to filter the displayed items. In multiselect
                    mode, a list box equivalent to <classname>ListSelect</classname>.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ComboBox</classname></term>
                <listitem>
                    A drop-down list for single selection. Otherwise as
                    <classname>Select</classname>, but the user can also enter new
                    items. The component also provides an input prompt.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ListSelect</classname></term>
                <listitem>
                    A vertical list box for selecting items in either single or multiple
                    selection mode.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>NativeSelect</classname></term>
                <listitem>
                    Provides selection using the native selection component of the
                    browser, typically a drop-down list for single selection and a
                    multi-line list in multiselect mode. This uses the
                    <literal>&lt;select&gt;</literal> element in HTML.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>OptionGroup</classname></term>
                <listitem>
                    Shows the items as a vertically arranged group of radio buttons in the
                    single selection mode and of check boxes in multiple selection mode.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>TwinColSelect</classname></term>
                <listitem>
                    Shows two list boxes side by side where the user can select items from
                    a list of available items and move them to a list of selected items
                    using control buttons.
                </listitem>
            </varlistentry>
        </variablelist>

		<para>
			In addition, the <classname>Tree</classname> and <classname>Table</classname>
			components allow special forms of selection. They also inherit the
			<classname>AbstractSelect</classname>.
		</para>

        <section xml:id="components.selecting.databinding">
            <title>Binding Selection Components to Data</title>

            <para>
                The selection components are strongly coupled with the Vaadin Data
                Model. The selectable items in all selection components are objects that
                implement the <classname>Item</classname> interface and are contained in a
                <classname>Container</classname>. The current selection is bound to the
                <classname>Property</classname> interface.
            </para>

            <para>
                Even though the data model is used, the selection components allow simple
                use in the most common cases. Each selection component is bound to a
                default container type, which supports management of items without need to
                implement a container.
            </para>

            <para>
                See <xref linkend="datamodel"/> for a detailed description of the data
                model, its interfaces, and built-in implementations.
            </para>

            <section xml:id="components.selecting.databinding.adding">
                <title>Adding New Items</title>
            
                <para>
                    New items are added with the <methodname>addItem()</methodname> method
                    defined in the <classname>Container</classname> interface.
                </para>

                <programlisting><![CDATA[// Create a selection component
Select select = new Select ("Select something here");

// Add some items and give each an item ID
select.addItem("Mercury");
select.addItem("Venus");
select.addItem("Earth");]]></programlisting>

                <para>
                    The <methodname>addItem()</methodname> method creates an empty
                    <classname>Item</classname>, which is identified by its <emphasis>item
                    identifier</emphasis> (IID) object, given as the parameter. This item ID
                    is by default used also as the caption of the item, as explained in
                    the next section. The identifier is typically a
                    <classname>String</classname>. The item is of a type specific to the
                    container and has itself little relevance for most selection
                    components, as the properties of an item may not be used in any way
                    (except in <classname>Table</classname>), only the item ID.
                </para>

                <para>
                    The item identifier can be of any object type. We could as well have
                    given integers for the item identifiers and set the captions
                    explicitly with <methodname>setItemCaption()</methodname>. You could
                    also add an item with the parameterless
                    <methodname>addItem()</methodname>, which returns an automatically
                    generated item ID.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a selection component
Select select = new Select("My Select");
        
// Add an item with a generated ID
Object itemId = select.addItem();
select.setItemCaption(itemId, "The Sun");
        
// Select the item
select.setValue(itemId);]]></programlisting>

                <para>
                    Some container types may support passing the actual data object to the
                    add method. For example, you can add items to a
                    <classname>BeanItemContainer</classname> with
                    <methodname>addBean()</methodname>. Such implementations can use a
                    separate item ID object, or the data object itself as the item ID, as
                    is done in <methodname>addBean()</methodname>. In the latter case you
                    can not depend on the default way of acquiring the item caption; see
                    the description of the different caption modes later.
                </para>

                <para>
                    The following section describes the different options for determining
                    the item captions.
                </para>
            </section>

            <section xml:id="components.selecting.databinding.captions">
                <title>Item Captions</title>

                <para>
                    The displayed captions of items in a selection component can be set
                    explicitly with <methodname>setItemCaption()</methodname> or
                    determined from the item IDs or item properties. This behaviour is
                    defined with the <emphasis>caption mode</emphasis>, which you can set
                    with <methodname>setItemCaptionMode()</methodname>. The default mode
                    is <parameter>ITEM_CAPTION_MODE_EXPLICIT_DEFAULTS_ID</parameter>,
                    which uses the item identifiers for the captions, unless given
                    explicitly.
                </para>

                <para>
                    In addition to a caption, an item can have an icon. The icon is set
                    with <methodname>setItemIcon()</methodname>.
                </para>

                <variablelist>
                    <title>Caption Modes for Selection Components</title>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_EXPLICIT_DEFAULTS_ID</constant></term>
                        <listitem>
                            <para>
                                This is the default caption mode and its flexibility
                                allows using it in most cases. By default, the item
                                identifier will be used as the caption. The identifier
                                object does not necessarily have to be a string; the
                                caption is retrieved with
                                <methodname>toString()</methodname> method. If the caption
                                is specified explicitly with
                                <methodname>setItemCaption()</methodname>, it overrides
                                the item identifier.
                            </para>

                            <programlisting><?pocket-size 65% ?><![CDATA[Select select = new Select("Moons of Mars");
        
// Use the item ID also as the caption of this item
select.addItem(new Integer(1));
        
// Set item caption for this item explicitly
select.addItem(2); // same as "new Integer(2)"
select.setItemCaption(2, "Deimos");]]></programlisting>

                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_EXPLICIT</constant></term>
                        <listitem>
                            <para>
                                Captions must be explicitly specified with
                                <methodname>setItemCaption()</methodname>. If they are
                                not, the caption will be empty. Such items with empty
                                captions will nevertheless be displayed in the
                                <classname>Select</classname> component as empty items. If
                                they have an icon, they will be visible.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_ICON_ONLY</constant></term>
                        <listitem>
                            <para>
                                Only icons are shown, captions are hidden.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_ID</constant></term>
                        <listitem>
                            <para>
                                String representation of the item identifier object is
                                used as caption. This is useful when the identifier is a
                                string, and also when the identifier is an complex object
                                that has a string representation. For example:
                            </para>
                            
                            <programlisting><?pocket-size 70% ?><![CDATA[Select select = new Select("Inner Planets");
select.setItemCaptionMode(Select.ITEM_CAPTION_MODE_ID);
        
// A class that implements toString()
class PlanetId extends Object implements Serializable {
    String planetName;
    PlanetId (String name) {
        planetName = name;
    }
    public String toString () {
        return "The Planet " + planetName;
    }
}

// Use such objects as item identifiers
String planets[] = {"Mercury", "Venus", "Earth", "Mars"};
for (int i=0; i<planets.length; i++)
    select.addItem(new PlanetId(planets[i]));]]></programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_INDEX</constant></term>
                        <listitem>
                            <para>
                                Index number of item is used as caption. This caption mode is
                                applicable only to data sources that implement the
                                <classname>Container.Indexed</classname> interface. If the
                                interface is not available, the component will throw a
                                <classname>ClassCastException</classname>. The
                                <classname>Select</classname> component itself does not implement
                                this interface, so the mode is not usable without a separate data
                                source. An <classname>IndexedContainer</classname>, for example,
                                would work.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_ITEM</constant></term>
                        <listitem>
                            <para>
                                <classname>String</classname> representation of item, acquired
                                with <methodname>toString()</methodname>, is used as the
                                caption. This is applicable mainly when using a custom
                                <classname>Item</classname> class, which also requires using a
                                custom <classname>Container</classname> that is used as a data
                                source for the <classname>Select</classname> component.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_PROPERTY</constant></term>
                        <listitem>
                            <para>
                                Item captions are read from the <classname>String</classname>
                                representation of the property with the identifier specified with
                                <methodname>setItemCaptionPropertyId()</methodname>. This is
                                useful, for example, when you have a container that you use as the
                                data source for a <classname>Select</classname>, and you want to
                                use a specific property for caption.
                            </para>
                            
                            <para>
                                In the example below, we bind a selection component to a bean
                                container and use a property of the bean as the caption.
                            </para>
                            
                            <programlisting><?pocket-size 65% ?><![CDATA[/* A bean with a "name" property. */
public class Planet implements Serializable {
    String name;

    public Planet(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

void propertyModeExample() {
    VerticalLayout layout = new VerticalLayout();

    // Have a bean container to put the beans in
    BeanItemContainer<Planet> container =
        new BeanItemContainer<Planet>(Planet.class);

    // Put some example data in it
    container.addItem(new Planet("Mercury"));
    container.addItem(new Planet("Venus"));
    container.addItem(new Planet("Earth"));
    container.addItem(new Planet("Mars"));

    // Create a selection component bound to the container
    Select select = new Select("Planets", container);

    // Set the caption mode to read the caption directly
    // from the 'name' property of the bean
    select.setItemCaptionMode(
            Select.ITEM_CAPTION_MODE_PROPERTY);
    select.setItemCaptionPropertyId("name");

    layout.addComponent(select);]]></programlisting>

                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>


            <section>
                <title>Getting and Setting Selection</title>

                <para>
                    A selection component provides the current selection as the property of
                    the component (with the <classname>Property</classname> interface). The
                    property value is an item identifier object that identifies the selected
                    item. You can get the identifier with <methodname>getValue()</methodname>
                    of the <classname>Property</classname> interface.
                </para>

                <para>
                    You can select an item with the corresponding
                    <methodname>setValue()</methodname> method. In multiselect mode, the
                    property will be an unmodifiable set of item identifiers. If no item
                    is selected, the property will be <parameter>null</parameter> in
                    single selection mode or an empty collection in multiselect mode.
                </para>

                <para>
                    The <classname>Select</classname> and <classname>NativeSelect</classname>
                    components will show "-" selection when no actual item is selected. This is
                    the <emphasis>null selection item identifier</emphasis>. You can set an
                    alternative ID with <methodname>setNullSelectionItemId()</methodname>. Setting
                    the alternative null ID is merely a visual text; the
                    <methodname>getValue()</methodname> will still return
                    <parameter>null</parameter> value if no item is selected, or an empty set in
                    multiselect mode.
                </para>

                <para>
                    The item identifier of the currently selected item will be set as the
                    property of the <classname>Select</classname> object. You can
                    access it with the <methodname>getValue()</methodname> method of the
                    <classname>Property</classname> interface of the component. Also,
                    when handling changes in a <classname>Select</classname> component
                    with the <classname>Property.ValueChangeListener</classname>
                    interface, the <classname>Property.ValueChangeEvent</classname> will
                    have the selected item as the property of the event, accessible with the
                    <methodname>getProperty()</methodname> method.
                </para>

                <figure>
                    <title>Selected Item</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="150" align="center" fileref="img/components/select-selected1.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>
        </section>
		<!-- <para>
		While the default caption mode is flexible enough for most
		cases where the appearance of a <classname>Select</classname>
		component is fixed, the other modes may be useful for cases where the
		user can configure what type of information is shown in the
		component. Typical situation is allowing the user to choose between
		"Show text only", "Show icons only", and "Show both icons and text".
		</para>-->

        <!-- TODO Select is no more, replace with ComboBox. -->
		<section xml:id="components.selecting.select">
			<title>Basic <classname>Select</classname> Component</title>

			<para>
				The <classname>Select</classname> component allows, in single selection
				mode, selecting an item from a drop-down list. The component also has a
				text field area, which allows entering search text by which the items
				shown in the drop-down list are filtered.
			</para>

            <para>
                In multiple selection mode, the component shows the items in a vertical
                list box, identical to <classname>ListSelect</classname>.
            </para>

			<figure>
				<title>The Select Component</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="130" align="center" fileref="img/components/select-select.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<section>
				<title>Filtered Selection</title>
				
				<para>
					The <classname>Select</classname> component allows filtering the items
					available for selection. The component shows as an input box for
					entering text. The text entered in the input box is used for filtering
					the available items shown in a drop-down list. Pressing
					<keycap>Enter</keycap> will complete the item in the input
					box. Pressing <keycap>Up</keycap>- and <keycap>Down</keycap>-arrows
					can be used for selecting an item from the drop-down list. The
					drop-down list is paged and clicking on the scroll buttons will change
					to the next or previous page. The list selection can also be done with
					the arrow keys on the keyboard. The shown items are loaded from the
					server as needed, so the number of items held in the component can be
					quite large.
				</para>
			
				<para>
					Vaadin provides two filtering modes:
					<parameter>FILTERINGMODE_CONTAINS</parameter> matches any item that
					contains the string given in the text field part of the component and
					<parameter>FILTERINGMODE_STARTSWITH</parameter> matches only items
					that begin with the given string. The filtering mode is set with
					<methodname>setFilteringMode()</methodname>. Setting the filtering
					mode to the default value <parameter>FILTERINGMODE_OFF</parameter>
					disables filtering.
				</para>

                <programlisting><?pocket-size 65% ?><![CDATA[Select select = new Select("Enter containing substring");

select.setFilteringMode(AbstractSelect.Filtering.FILTERINGMODE_CONTAINS);

/* Fill the component with some items. */
final String[] planets = new String[] {
        "Mercury", "Venus", "Earth", "Mars",
        "Jupiter", "Saturn", "Uranus", "Neptune" };

for (int i = 0; i < planets.length; i++)
    for (int j = 0; j < planets.length; j++) {
        select.addItem(planets[j] + " to " + planets[i]);]]></programlisting>

				<para>
					The above example uses the containment filter that matches to all
					items containing the input string. As shown in <xref
					linkend="figure.select.filter"/> below, when we type some text in the
					input area, the drop-down list will show all the matching items.
				</para>

				<figure xml:id="figure.select.filter">
					<title>Filtered Selection</title>
					<mediaobject>
						<imageobject>
							<imagedata smallscale="100%" align="center" fileref="img/components/select-filter3.png"/>
						</imageobject>
					</mediaobject>
				</figure>
            </section>
					
            <simplesect>
                <title>CSS Style Rules</title>
                
                <programlisting><![CDATA[.v-filterselect { }
.v-filterselect-input { }
.v-filterselect-button { }
.v-filterselect-suggestpopup { }
.v-filterselect-prefpage-off { }
.v-filterselect-suggestmenu { }
.v-filterselect-status { }
.v-select { }
.v-select-select { }]]></programlisting>
					
                <para>
                    In its default state, only the input field of the
                    <classname>Select</classname> component is visible. The entire
                    component is enclosed in <literal>v-filterselect</literal> style, the
                    input field has <literal>v-filterselect-input</literal> style and the
                    button in the right end that opens and closes the drop-down result
                    list has <literal>v-filterselect-button</literal> style.
                </para>

                <para>
                    The drop-down result list has an overall
                    <literal>v-filterselect-suggestpopup</literal> style. It contains the
                    list of suggestions with <literal>v-filterselect-suggestmenu</literal>
                    style and a status bar in the bottom with
                    <literal>v-filterselect-status</literal> style. The list of
                    suggestions is padded with an area with
                    <literal>v-filterselect-prefpage-off</literal> style above and below
                    the list.
                </para>

                <para>
                    In multiselect-mode, the styles of the component aere identical to
                    <classname>ListSelect</classname> component, with
                    <literal>v-select</literal> overall style and
                    <literal>v-select-select</literal> for the native selection element.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.selecting.listselect">
            <title><classname>ListSelect</classname></title>

            <para>
                The <classname>ListSelect</classname> component is list box that shows the
                selectable items in a vertical list. If the number of items exceeds the
                height of the component, a scrollbar is shown. The component allows both
                single and multiple selection modes, which you can set with
                <methodname>setMultiSelect()</methodname>. It is visually identical in
                both modes.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create the selection component
ListSelect select = new ListSelect("My Selection");
        
// Add some items
select.addItem("Mercury");
select.addItem("Venus");
select.addItem("Earth");
...

select.setNullSelectionAllowed(false);

// Show 5 items and a scrollbar if there are more
select.setRows(5);]]></programlisting>

            <para>
                The number of visible items is set with
                <methodname>setRows()</methodname>.
            </para>

            <figure xml:id="figure.selecting.listselect.basic">
                <title>The <classname>ListSelect</classname> Component</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="80%" align="center" fileref="img/components/listselect-basic.png"/>
                    </imageobject>
                </mediaobject>
            </figure>


			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select {}
.v-select-select {}]]></programlisting>

				<para>
					The component has a <literal>v-select</literal> overall style. The
					native <literal>select</literal> element has
					<literal>v-select-select</literal> style.
				</para>
			</simplesect>
        </section>

		<section xml:id="components.selecting.nativeselect">
			<title>Native Selection Component <classname>NativeSelect</classname></title>
			
			<para>
				<classname>NativeSelect</classname> offers the native selection component
				of web browsers, using the HTML <literal>&lt;select&gt;</literal>
				element. The component is shown as a drop-down list.
			</para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create the selection component
final NativeSelect select = new NativeSelect("Native Selection");
        
// Add some items
select.addItem("Mercury");
select.addItem("Venus");
...
        
// Set the width in "columns" as in TextField
select.setColumns(10);
        
select.setNullSelectionAllowed(false);]]></programlisting>

            <para>
                The <methodname>setColumns()</methodname> allows setting the width of the
                list as "columns", which is a measure that depends on the browser.
            </para>

            <figure xml:id="figure.selecting.nativeselect.basic">
                <title>The <classname>NativeSelect</classname> Component</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="80%" align="center" fileref="img/components/nativeselect-basic.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Multiple selection mode is not allowed; you should use the
                <classname>ListSelect</classname> component instead. Also adding new
                items, which would be enabled with
                <methodname>setNewItemsAllowed()</methodname>, is not allowed.
            </para>

			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select {}
.v-select-select {}]]></programlisting>

				<para>
					The component has a <literal>v-select</literal> overall style. The
					native <literal>select</literal> element has
					<literal>v-select-select</literal> style.
				</para>
			</simplesect>
		</section>

		<section xml:id="components.selecting.optiongroup">
			<title>Radio Button and Check Box Groups with <classname>OptionGroup</classname></title>
			<para>
				The <classname>OptionGroup</classname> class provides selection from
				alternatives using a group of radio buttons in single selection mode. In
				multiple selection mode, the items show up as check boxes.
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[OptionGroup optiongroup = new OptionGroup("My Option Group");

// Use the multiple selection mode.
myselect.setMultiSelect(true);]]></programlisting>

            <para>
                <xref linkend="figure.components.selecting.optiongroup"/> shows the
                <classname>OptionGroup</classname> in both single and multiple selection mode.
            </para>

			<figure xml:id="figure.components.selecting.optiongroup">
				<title>Option Button Group in Single and Multiple Selection Mode</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="130" align="center" fileref="img/components/select-optiongroup.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can create check boxes individually using the
				<classname>CheckBox</classname> class, as described in <xref
				linkend="components.checkbox"/>. The advantages of the
				<classname>OptionGroup</classname> component are that as it maintains the
				individual check box objects, you can get an array of the currently
				selected items easily, and that you can easily change the appearance of a
				single component.
			</para>

            <section>
                <title>Disabling Items</title>

                <para>
                    You can disable individual items in an
                    <classname>OptionGroup</classname> with
                    <methodname>setItemEnabled()</methodname>. The user can not select or
                    deselect disabled items in multi-select mode, but in single-select
                    mode the use can change the selection from a disabled to an enabled
                    item. The selections can be changed programmatically regardless of
                    whether an item is enabled or disabled. You can find out whether an
                    item is enabled with <methodname>isItemEnabled()</methodname>.
                </para>

                <para>
                    The <methodname>setItemEnabled()</methodname> identifies the item to
                    be disabled by its item ID.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have an option group
OptionGroup group = new OptionGroup("My Disabled Group");
group.addItem("One");
group.addItem("Two");
group.addItem("Three");

// Disable one item
group.setItemEnabled("Two", false);]]></programlisting>

                <para>
                    The item IDs are also used for the captions in this example. The
                    result is shown in <xref
                    linkend="figure.components.selecting.optiongroup.disabling"/>.
                </para>

                <figure xml:id="figure.components.selecting.optiongroup.disabling">
                    <title><classname>OptionGroup</classname> with a Disabled Item</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="70%" align="center" fileref="img/components/optiongroup-disabling.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    Setting an item as disabled turns on the <literal>v-disabled</literal>
                    style for it.
                </para>
            </section>

			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select-optiongroup {}
.v-select-option.v-checkbox {}
.v-select-option.v-radiobutton {}]]></programlisting>

				<para>
					The <literal>v-select-optiongroup</literal> is the overall style for
					the component. Each check box will have the
					<literal>v-checkbox</literal> style, borrowed from the
					<classname>CheckBox</classname> component, and each radio button the
					<literal>v-radiobutton</literal> style. Both the radio buttons and
					check boxes will also have the <literal>v-select-option</literal>
					style that allows styling regardless of the option type. Disabled
					items have additionally the <literal>v-disabled</literal> style.
				</para>

                <para>
                    The options are normally laid out vertically. You can use horizontal
                    layout by setting <literal>display: inline-block</literal> for the
                    options. The <literal>nowrap</literal> setting for the overall element
                    prevents wrapping if there is not enough horizontal space in the
                    layout, or if the horizontal width is undefined.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[/* Lay the options horizontally */
.v-select-optiongroup-horizontal .v-select-option {
    display: inline-block;
}

/* Avoid wrapping if the layout is too tight */
.v-select-optiongroup-horizontal {
    white-space: nowrap;
}

/* Some extra spacing is needed */
.v-select-optiongroup-horizontal
  .v-select-option.v-radiobutton {
    padding-right: 10px;
}]]></programlisting>

                <para>
                    Use of the above rules requires setting a custom
                    <literal>horizontal</literal> style name for the component. The result
                    is shown in <xref
                    linkend="figure.components.selecting.optiongroup.horizontal"/>.
                </para>

                <figure xml:id="figure.components.selecting.optiongroup.horizontal">
                    <title>Horizontal <classname>OptionGroup</classname></title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="70%" align="center" fileref="img/components/optiongroup-horizontal.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

			</simplesect>
		</section>

		<section xml:id="components.selecting.twincolselect">
			<title>Twin Column Selection with <classname>TwinColSelect</classname></title>
			<para>
				The <classname>TwinColSelect</classname> field provides a multiple
				selection component that shows two lists side by side, with the left
				column containing unselected items and the right column the selected
				items. The user can select items from the list on the left and click on
				the "&gt;&gt;" button to move them to the list on the right. Items can be
				deselected by selecting them in the right list and clicking on the
				"&lt;&lt;" button.
			</para>

			<para>
                <classname>TwinColSelect</classname> is always in multi-select mode, so
                its property value is always a collection of the item IDs of the selected
                items, that is, the items in the right column.
            </para>

            <para>
                The selection columns can have their own captions, separate from the
                overall component caption, which is managed by the containing layout. You
                can set the column captions with
                <methodname>setLeftColumnCaption()</methodname> and
                <methodname>setRightColumnCaption()</methodname>.
            </para>

            <book-example id="component.select.twincolselect.captions" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[final TwinColSelect select =
    new TwinColSelect("Select Targets to Destroy");

// Set the column captions (optional)
select.setLeftColumnCaption("These are left");
select.setRightColumnCaption("These are done for");
        
// Put some data in the select
String planets[] = {"Mercury", "Venus", "Earth", "Mars",
        "Jupiter", "Saturn", "Uranus", "Neptune"};
for (int pl=0; pl<planets.length; pl++)
    select.addItem(planets[pl]);

// Set the number of visible items
select.setRows(planets.length);]]></programlisting>

            <para>
                The resulting component is shown in <xref
                linkend="figure.components.selecting.twincolselect.captions"/>.
            </para>

			<figure xml:id="figure.components.selecting.twincolselect.captions">
				<title>Twin Column Selection</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/select-twincol.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                The <methodname>setRows()</methodname> method sets the height of the
                component by the number of visible items in the selection boxes. Setting
                the height with <methodname>setHeight()</methodname> to a defined value
                overrides the rows setting.
            </para>
            
			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select-twincol {}
  .v-select-twincol-options-caption {}
  .v-select-twincol-selections-caption {}
  .v-select-twincol-options {}
  .v-select-twincol-buttons {}
    .v-button {}
      .v-button-wrap {}
        .v-button-caption {}
    .v-select-twincol-deco {}
  .v-select-twincol-selections {}]]></programlisting>

                <para>
                    The <classname>TwinColSelect</classname> component has an overall
                    <literal>v-select-twincol</literal> style. If set, the left and right
                    column captions have
                    <literal>v-select-twincol-options-caption</literal> and
                    <literal>v-select-twincol-options-caption</literal> style names,
                    respectively. The left box, which displays the unselected items, has
                    <literal>v-select-twincol-options-caption</literal> style and the
                    right box, which displays the selected items, has
                    <literal>v-select-twincol-options-selections</literal> style. Between
                    them is the button area, which has overall
                    <literal>v-select-twincol-buttons</literal> style; the actual buttons
                    reuse the styles for the <classname>Button</classname>
                    component. Between the buttons is a divider element with
                    <literal>v-select-twincol-deco</literal> style.
                </para>

			</simplesect>
		</section>


		<section xml:id="components.selecting.newitems">
			<title>Allowing Adding New Items</title>

			<para>
				The selection components allow the user to add new items, with a user
				interface similar to combo boxes in desktop user interfaces. You need to
				enable the <parameter>newItemsAllowed</parameter> mode with the
				<methodname>setNewItemsAllowed()</methodname> method.
			</para>

			<programlisting><![CDATA[myselect.setNewItemsAllowed(true);]]></programlisting>

            <para>
                The user interface for adding new items depends on the selection component
                and the selection mode. The regular <classname>Select</classname>
                component in single selection mode, which appears as a combo box, allows
                you to simply type the new item in the combo box and hit
                <keycap>Enter</keycap> to add it. In most other selection components, as
                well as in the multiple selection mode of the regular
                <classname>Select</classname> component, a text field that allows entering
                new items is shown below the selection list, and clicking the
                <guibutton>+</guibutton> button will add the item in the list, as
                illustrated in <xref linkend="figure.components.selecting.newitems"/>.
            </para>

			<figure xml:id="figure.components.selecting.newitems">
				<title>Select Component with Adding New Items Allowed</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/components/select-addnewitems.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				The identifier of an item added by the user will be a
				<classname>String</classname> object identical to the caption of the
				item. You should consider this if the item identifier of automatically
				filled items is some other type or otherwise not identical to the caption.
			</para>

			<para>
				Adding new items is possible in both single and multiple
				selection modes and in all styles. Adding new items may not be
				possible if the <classname>Select</classname> is bound to an
				external <classname>Container</classname> that does not allow
				adding new items.
			</para>
		</section>

		<section xml:id="components.selecting.multiple">
			<title>Multiple Selection Mode</title>

			<!-- UNFINISHED: Check if outdated. -->
			
			<para>
				Setting the <classname>Select</classname>,
				<classname>NativeSelect</classname>, or <classname>OptionGroup</classname>
				components to multiple selection mode with the
				<methodname>setMultiSelect()</methodname> method changes their appearance
				to allow selecting multiple items.
			</para>

            <variablelist>
                <varlistentry>
                    <term><classname>Select</classname> and <classname>NativeSelect</classname></term>
                    <listitem>
                        <para>
                            These components appear as a native HTML selection list, as
                            shown in <xref
                            linkend="figure.components.selecting.newitems"/>. By holding
                            the <keycap>Ctrl</keycap> or <keycap>Shift</keycap> key
                            pressed, the user can select multiple items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><classname>OptionGroup</classname></term>
                    <listitem>
                        The option group, which is a radio button group in single
                        selection mode, will show as a check box group in multiple
                        selection mode. See <xref
                        linkend="components.selecting.optiongroup"/>.
                    </listitem>
                </varlistentry>
            </variablelist>

			<para>
                The <classname>TwinColSelect</classname>, described in <xref
                linkend="components.selecting.twincolselect"/>, is a special multiple
                selection mode that is not meaningful for single selection.
            </para>

			<programlisting><![CDATA[myselect.setMultiSelect(true);]]></programlisting>

			<para>
				As in single selection mode, the selected items are set as the property of
				the <classname>Select</classname> object. In multiple selection mode, the
				property is a <classname>Collection</classname> of currently selected
				items. You can get and set the property with the
				<methodname>getValue()</methodname> and
				<methodname>setValue()</methodname> methods as usual.
			</para>

			<para>
                A change in the selection will trigger a
                <classname>ValueChangeEvent</classname>, which you can handle with a
                <classname>Propery.ValueChangeListener</classname>. As usual, you should
                use <methodname>setImmediate(true)</methodname> to trigger the event
                immediately when the user changes the selection. The following example
                shows how to handle selection changes with a listener.
			</para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class SelectExample
           extends CustomComponent
           implements Property.ValueChangeListener {
    // Create a Select object with a caption.
    Select select = new Select("This is a Select component");

    VerticalLayout layout = new VerticalLayout();
    Label status = new Label("-");
    
    SelectExample () {
        setCompositionRoot (layout);
        layout.addComponent(select);

        // Fill the component with some items.
        final String[] planets = new String[] {
            "Mercury", "Venus", "Earth", "Mars",
            "Jupiter", "Saturn", "Uranus", "Neptune"};
        for (int i=0; i<planets.length; i++)
            select.addItem(planets[i]);

        // By default, the change event is not triggered
        // immediately when the selection changes.
        // This enables the immediate events.
        select.setImmediate(true);
        
        // Listen for changes in the selection.
        select.addListener(this);

        layout.addComponent(status);
    }

    /* Respond to change in the selection. */
    public void valueChange(Property.ValueChangeEvent event) {
        // The event.getProperty() returns the Item ID (IID) 
        // of the currently selected item in the component.
        status.setValue("Currently selected item ID: " +
                        event.getProperty());
    }
}]]></programlisting>

        </section>

		<section xml:id="components.selecting.features">
            <title>Other Common Features</title>

            <section>
                <title>Item Icons</title>

                <para>
                    You can set an icon for each item with
                    <methodname>setItemIcon()</methodname>, or define an item property
                    that provides the icon resource with
                    <methodname>setItemIconPropertyId()</methodname>, in a fashion similar
                    to captions. Notice, however, that icons are not supported in
                    <classname>NativeSelect</classname>,
                    <classname>TwinColSelect</classname>, and some other selection
                    components and modes. This is because HTML does not support images
                    inside the native <literal>select</literal> elements. Icons are also
                    not really visually applicable.
                </para>
            </section>
        </section>

	</section>

    <!-- ================================================================== -->
    <!-- Table                                                              -->
    <!-- ================================================================== -->

	<section xml:id="components.table">
		<title><classname>Table</classname></title>

        <indexterm xml:id="term.components.table" class="startofrange">
            <primary><classname>Table</classname></primary>
        </indexterm>

        <para>
            <emphasis>Because of pressing release schedules to get this edition to your
            hands, we were unable to completely update this section. The description of the
            <classname>Table</classname> component should be mostly up-to-date, but some
            data binding related topics still require significant revision. Please consult
            the web version once it is updated, or the next print edition.</emphasis>
        </para>

		<para>
			The <classname>Table</classname> component is intended for presenting tabular
			data organized in rows and columns. The <classname>Table</classname> is one of
			the most versatile components in Vaadin. Table cells can include text
			or arbitrary UI components. You can easily implement editing of the table data,
			for example clicking on a cell could change it to a text field for editing.
		</para>

		<para>
			The data contained in a <classname>Table</classname> is managed using the Data
			Model of Vaadin (see <xref linkend="datamodel"/>), through
			the <classname>Container</classname> interface of the
			<classname>Table</classname>. This makes it possible to bind a table directly
			to a data source, such as a database query. Only the visible part of the table
			is loaded into the browser and moving the visible window with the scrollbar loads
			content from the server. While the data is being loaded, a tooltip will be
			displayed that shows the current range and total number of items in the
			table. The rows of the table are <emphasis>items</emphasis> in the container
			and the columns are <emphasis>properties</emphasis>. Each table row (item) is
			identified with an <emphasis>item identifier</emphasis> (IID), and each column
			(property) with a <emphasis>property identifier</emphasis> (PID).
		</para>

		<para>
			When creating a table, you first need to define columns with
			<methodname>addContainerProperty()</methodname>. This method comes in two
			flavors. The simpler one takes the property ID of the column and uses it also
			as the caption of the column. The more complex one allows differing PID and
			header for the column. This may make, for example, internationalization of
			table headers easier, because if a PID is internationalized, the
			internationalization has to be used everywhere where the PID is used. The
			complex form of the method also allows defining an icon for the column from a
			resource. The "default value" parameter is used when new properties (columns)
			are added to the table, to fill in the missing values. (This default has no
			meaning in the usual case, such as below, where we add items after defining
			the properties.)
		</para>

        <programlisting><?pocket-size 65% ?><![CDATA[/* Create the table with a caption. */
Table table = new Table("This is my Table");

/* Define the names and data types of columns.
 * The "default value" parameter is meaningless here. */
table.addContainerProperty("First Name", String.class,  null);
table.addContainerProperty("Last Name",  String.class,  null);
table.addContainerProperty("Year",       Integer.class, null);

/* Add a few items in the table. */
table.addItem(new Object[] {
    "Nicolaus","Copernicus",new Integer(1473)}, new Integer(1));
table.addItem(new Object[] {
    "Tycho",   "Brahe",     new Integer(1546)}, new Integer(2));
table.addItem(new Object[] {
    "Giordano","Bruno",     new Integer(1548)}, new Integer(3));
table.addItem(new Object[] {
    "Galileo", "Galilei",   new Integer(1564)}, new Integer(4));
table.addItem(new Object[] {
    "Johannes","Kepler",    new Integer(1571)}, new Integer(5));
table.addItem(new Object[] {
    "Isaac",   "Newton",    new Integer(1643)}, new Integer(6));]]></programlisting>

		<para>
			In this example, we used an increasing <classname>Integer</classname> object
			as the Item Identifier, given as the second parameter to
			<methodname>addItem()</methodname>. The actual rows are given simply as object
			arrays, in the same order in which the properties were added. The objects must
			be of the correct class, as defined in the
			<methodname>addContainerProperty()</methodname> calls.
		</para>

		<figure>
			<title>Basic Table Example</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="120" align="center" fileref="img/components/table-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Scalability of the <classname>Table</classname> is largely dictated by
			the container. The default <classname>IndexedContainer</classname> is
			relatively heavy and can cause scalability problems, for example, when
			updating the values. Use of an optimized application-specific
			container is recommended. Table does not have a limit for the number
			of items and is just as fast with hundreds of thousands of items as
			with just a few. With the current implementation of scrolling, there
			is a limit of around 500 000 rows, depending on the browser and the pixel
			height of rows.
		</para>

		<section xml:id="components.table.selecting">
			<title>Selecting Items in a Table</title>

			<para>
				The <classname>Table</classname> allows selecting one or more items by
				clicking them with the mouse. When the user selects an item, the IID of the
				item will be set as the property of the table and a
				<classname>ValueChangeEvent</classname> is triggered. To enable selection,
				you need to set the table <emphasis>selectable</emphasis>. You will also
				need to set it as <emphasis>immediate</emphasis> in most cases, as we do
				below, because without it, the change in the property will not be
				communicated immediately to the server.
			</para>

			<para>
				The following example shows how to enable the selection of items in a
				<classname>Table</classname> and how to handle
				<classname>ValueChangeEvent</classname> events that are caused by changes
				in selection. You need to handle the event with the
				<methodname>valueChange()</methodname> method of the
				<classname>Property.ValueChangeListener</classname> interface.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Allow selecting items from the table.
table.setSelectable(true);

// Send changes in selection immediately to server.
table.setImmediate(true);

// Shows feedback from selection.
final Label current = new Label("Selected: -");

// Handle selection change.
table.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        current.setValue("Selected: " + table.getValue());
    }
});]]></programlisting>

			<figure>
				<title>Table Selection Example</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/components/table-example2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				If the user clicks on an already selected item, the selection will
				deselected and the table property will have <parameter>null</parameter>
				value. You can disable this behaviour by setting
				<methodname>setNullSelectionAllowed(false)</methodname> for the table.
			</para>

            <para>
                The selection is the value of the table's property, so you can get it with
                <methodname>getValue()</methodname>. You can get it also from a reference
                to the table itself. In single selection mode, the value is the item
                identifier of the selected item or <parameter>null</parameter> if no item
                is selected. In multiple selection mode (see below), the value is a
                <classname>Set</classname> of item identifiers. Notice that the set is
                unmodifiable, so you can not simply change it to change the selection.
			</para>

            <simplesect>
                <title>Multiple Selection Mode</title>

                <para>
                    A table can also be in <emphasis>multiselect</emphasis> mode, where a
                    user can select multiple items by clicking them with left mouse button
                    while holding the <keycap>Ctrl</keycap> key (or <keycap>Meta</keycap>
                    key) pressed. If <keycap>Ctrl</keycap> is not held, clicking an item
                    will select it and other selected items are deselected. The user can
                    select a range by selecting an item, holding the
                    <keycap>Shift</keycap> key pressed, and clicking another item, in
                    which case all the items between the two are also selected. Multiple
                    ranges can be selected by first selecting a range, then selecting an
                    item while holding <keycap>Ctrl</keycap>, and then selecting another
                    item with both <keycap>Ctrl</keycap> and <keycap>Shift</keycap>
                    pressed.
                </para>

                <para>
                    The multiselect mode is enabled with the
                    <methodname>setMultiSelect()</methodname> method of the
                    <classname>Select</classname> interface of
                    <classname>Table</classname>. Setting table in multiselect mode does
                    not implicitly set it as <emphasis>selectable</emphasis>, so it must
                    be set separately.
                </para>

                <para>
                    The <methodname>setMultiSelectMode()</methodname> property affects the
                    control of multiple selection:
                    <parameter>MultiSelectMode.DEFAULT</parameter> is the default
                    behaviour, which requires holding the <keycap>Ctrl</keycap> (or
                    <keycap>Meta</keycap>) key pressed while selecting items, while in
                    <parameter>MultiSelectMode.SIMPLE</parameter> holding the
                    <keycap>Ctrl</keycap> key is not needed. In the simple mode, items can
                    only be deselected by clicking them.
                </para>
            </simplesect>
		</section>

		<section xml:id="components.table.features">
			<title>Table Features</title>
			
			<section>
				<title>Page Length and Scrollbar</title>

				<para>
					The default style for <classname>Table</classname> provides a table
					with a scrollbar. The scrollbar is located at the right side of the
					table and becomes visible when the number of items in the table
					exceeds the page length, that is, the number of visible items. You can
					set the page length with <methodname>setPageLength()</methodname>.
				</para>

				<para>
					Setting the page length to zero makes all the rows in a table visible,
					no matter how many rows there are. Notice that this also effectively
					disables buffering, as all the entire table is loaded to the browser
					at once. Using such tables to generate reports does not scale up very
					well, as there is some inevitable overhead in rendering a table with
					Ajax. For very large reports, generating HTML directly is a more
					scalable solution.
				</para>
			</section>

			<section>
				<title>Resizing Columns</title>

                <para>
                    You can set the width of a column programmatically from the
                    server-side with <methodname>setColumnWidth()</methodname>. The column
                    is identified by the property ID and the width is given in pixels.
                </para>

				<para>
					The user can resize table columns by dragging the resize handle
					between two columns. Resizing a table column causes a
					<classname>ColumnResizeEvent</classname>, which you can handle with a
					<classname>Table.ColumnResizeListener</classname>. The table must be
					set in immediate mode if you want to receive the resize events
					immediately, which is typical.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[table.addListener(new Table.ColumnResizeListener() {
    public void columnResize(ColumnResizeEvent event) {
        // Get the new width of the resized column
        int width = event.getCurrentWidth();
        
        // Get the property ID of the resized column
        String column = (String) event.getPropertyId();

        // Do something with the information
        table.setColumnFooter(column, String.valueOf(width) + "px");
    }
});
        
// Must be immediate to send the resize events immediately
table.setImmediate(true);]]></programlisting>

                <para>
                    See <xref linkend="figure.component.table.columnresize"/> for a result
                    after the columns of a table has been resized.
                </para>

                <figure xml:id="figure.component.table.columnresize">
                    <title>Resizing Columns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" align="center" fileref="img/components/table-column-resize.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
			</section>

			<section>
				<title>Reordering Columns</title>
			
				<para>
                    If <methodname>setColumnReorderingAllowed(true)</methodname> is set,
                    the user can reorder table columns by dragging them with the mouse
                    from the column header,
				</para>
			</section>

			<section xml:id="component.table.columncollapsing">
                <title>Collapsing Columns</title>

                <para>
                    When <methodname>setColumnCollapsingAllowed(true)</methodname> is set,
                    the right side of the table header shows a drop-down list that allows
                    selecting which columns are shown. Collapsing columns is different
                    than hiding columns with <methodname>setVisibleColumns()</methodname>,
                    which hides the columns completely so that they can not be made
                    visible (uncollapsed) from the user interface.
                </para>

                <para>
                    You can collapse columns programmatically with
                    <methodname>setColumnCollapsed()</methodname>. Collapsing must be
                    enabled before collapsing columns with the method or it will throw an
                    <classname>IllegalAccessException</classname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Allow the user to collapse and uncollapse columns
table.setColumnCollapsingAllowed(true);

// Collapse this column programmatically
try {
    table.setColumnCollapsed("born", true);
} catch (IllegalAccessException e) {
    // Can't occur - collapsing was allowed above
    System.err.println("Something horrible occurred");
}
        
// Give enough width for the table to accommodate the
// initially collapsed column later
table.setWidth("250px");]]></programlisting>

                <para>
                    See <xref linkend="figure.component.table.columncollapsing"/>.
                </para>

                <figure xml:id="figure.component.table.columncollapsing">
                    <title>Collapsing Columns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" align="center" fileref="img/components/table-column-collapsing.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    If the table has undefined width, it minimizes its width to fit the
                    width of the visible columns. If some columns are initially collapsed,
                    the width of the table may not be enough to accomodate them later,
                    which will result in an ugly horizontal scrollbar. You should consider
                    giving the table enough width to accomodate columns uncollapsed by the
                    user.
                </para>
            </section>

			<section>
				<title>Components Inside a Table</title>

				<para>
					The cells of a <classname>Table</classname> can contain any user
					interface components, not just strings. If the rows are higher than
					the row height defined in the default theme, you have to define the
					proper row height in a custom theme.
				</para>

				<para>
					When handling events for components inside a
					<classname>Table</classname>, such as for the
					<classname>Button</classname> in the example below, you usually need
					to know the item the component belongs to. Components do not
					themselves know about the table or the specific item in which a
					component is contained.  Therefore, the handling method must use some
					other means for finding out the Item ID of the item. There are a few
					possibilities. Usually the easiest way is to use the
					<methodname>setData()</methodname> method to attach an arbitrary
					object to a component. You can subclass the component and include the
					identity information there. You can also simply search the entire
					table for the item with the component, although that solution may not
					be so scalable.
				</para>

				<para>
					The example below includes table rows with a
					<classname>Label</classname> in XHTML formatting mode, a multiline
					<classname>TextField</classname>, a <classname>CheckBox</classname>,
					and a <classname>Button</classname> that shows as a link.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[// Create a table and add a style to allow setting the row height in theme.
final Table table = new Table();
table.addStyleName("components-inside");

/* Define the names and data types of columns.
 * The "default value" parameter is meaningless here. */
table.addContainerProperty("Sum",            Label.class,     null);
table.addContainerProperty("Is Transferred", CheckBox.class,  null);
table.addContainerProperty("Comments",       TextField.class, null);
table.addContainerProperty("Details",        Button.class,    null);

/* Add a few items in the table. */
for (int i=0; i<100; i++) {
    // Create the fields for the current table row
    Label sumField = new Label(String.format(
                   "Sum is <b>$%04.2f</b><br/><i>(VAT incl.)</i>",
                   new Object[] {new Double(Math.random()*1000)}),
                               Label.CONTENT_XHTML);
    CheckBox transferredField = new CheckBox("is transferred");
    
    // Multiline text field. This required modifying the 
    // height of the table row.
    TextField commentsField = new TextField();
    commentsField.setRows(3);
    
    // The Table item identifier for the row.
    Integer itemId = new Integer(i);
    
    // Create a button and handle its click. A Button does not
    // know the item it is contained in, so we have to store the
    // item ID as user-defined data.
    Button detailsField = new Button("show details");
    detailsField.setData(itemId);
    detailsField.addListener(new Button.ClickListener() {
        public void buttonClick(ClickEvent event) {
            // Get the item identifier from the user-defined data.
            Integer iid = (Integer)event.getButton().getData();
            Notification.show("Link " +
                              iid.intValue() + " clicked.");
        } 
    });
    detailsField.addStyleName("link");
    
    // Create the table row.
    table.addItem(new Object[] {sumField, transferredField,
                                commentsField, detailsField},
                  itemId);
}

// Show just three rows because they are so high.
table.setPageLength(3);]]></programlisting>

				<para>
					The row height has to be set higher than the default with a style rule
					such as the following:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[/* Table rows contain three-row TextField components. */
.v-table-components-inside .v-table-cell-content {
	height: 54px;
}]]></programlisting>

				<para>
					The table will look as shown in <xref
					linkend="figure.components.table.components-inside"/>.
				</para>

				<figure xml:id="figure.components.table.components-inside">
					<title>Components in a Table</title>
					<mediaobject>
						<imageobject>
							<imagedata smallscale="100%" align="center" fileref="img/components/table-components.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<title>Iterating Over a Table</title>

				<para>
					As the items in a <classname>Table</classname> are not indexed, iterating
					over the items has to be done using an iterator. The
					<methodname>getItemIds()</methodname> method of the
					<classname>Container</classname> interface of <classname>Table</classname>
					returns a <classname>Collection</classname> of item identifiers over which
					you can iterate using an <classname>Iterator</classname>. For an example
					about iterating over a <classname>Table</classname>, please see <xref
						linkend="datamodel.container"/>. Notice that you may not modify the
					<classname>Table</classname> during iteration, that is, add or remove
					items. Changing the data is allowed.
				</para>
			</section>

            <section>
                <title>Filtering Table Contents</title>

                <para>
                    A table can be filtered if its container data source implements the
                    <classname>Filterable</classname> interface, as the default
                    <classname>IndexedContainer</classname> does. See <xref
                    linkend="datamodel.container.filtered"/>.
                    
                    <indexterm><primary>Container</primary><secondary>Filterable</secondary></indexterm>
                </para>
            </section>
		</section>

        <section xml:id="components.table.editing">
            <title>Editing the Values in a Table</title>
            
            <para>
                Normally, a <classname>Table</classname> simply displays the items and
                their fields as text. If you want to allow the user to edit the values,
                you can either put them inside components as we did above, or you can
                simply call <methodname>setEditable(true)</methodname> and the cells are
                automatically turned into editable fields.
            </para>

            <para>
                Let us begin with a regular table with a some columns with usual Java
                types, namely a <classname>Date</classname>,
                <classname>Boolean</classname>, and a <classname>String</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a table. It is by default not editable.
final Table table = new Table();

// Define the names and data types of columns.
table.addContainerProperty("Date",     Date.class,  null);
table.addContainerProperty("Work",     Boolean.class, null);
table.addContainerProperty("Comments", String.class,  null);

// Add a few items in the table.
for (int i=0; i<100; i++) {
    Calendar calendar = new GregorianCalendar(2008,0,1);
    calendar.add(Calendar.DAY_OF_YEAR, i);
    
    // Create the table row.
    table.addItem(new Object[] {calendar.getTime(),
                                new Boolean(false),
                                ""},
                  new Integer(i)); // Item identifier
}

table.setPageLength(8);
layout.addComponent(table);]]></programlisting>

            <para>
                You could put the table in editable mode right away if you need to. We'll
                continue the example by adding a mechanism to switch the
                <classname>Table</classname> from and to the editable mode.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final CheckBox switchEditable = new CheckBox("Editable");
switchEditable.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        table.setEditable(((Boolean)event.getProperty()
                             .getValue()).booleanValue());
    }
});
switchEditable.setImmediate(true);
layout.addComponent(switchEditable);]]></programlisting>

            <para>
                Now, when you check to checkbox, the components in the table turn into
                editable fields, as shown in <xref
                linkend="figure.component.table.editable"/>.
            </para>

            <figure xml:id="figure.component.table.editable">
                <title>A Table in Normal and Editable Mode</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/table-editable3.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="45" smallscale="100%" align="center" fileref="img/components/table-editable3.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section>
                <title>Field Factories</title>

                <para>
                    The field components that allow editing the values of particular types
                    in a table are defined in a field factory that implements the
                    <classname>TableFieldFactory</classname> interface. The default
                    implementation is <classname>DefaultFieldFactory</classname>, which
                    offers the following crude mappings:
                </para>
                
                <table>
                    <title>Type to Field Mappings in <classname>DefaultFieldFactory</classname></title>
                    <tgroup cols="2" align="left">
                        <thead>
                            <row valign="top">
                                <entry>Property Type</entry>
                                <entry>Mapped to Field Class</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="top">
                                <entry><classname>Date</classname></entry>
                                <entry>A <classname>DateField</classname>. </entry>
                            </row>
                            <row valign="top">
                                <entry><classname>Boolean</classname></entry>
                                <entry>A <classname>CheckBox</classname>.</entry>
                            </row>
                            <row valign="top">
                                <entry><classname>Item</classname></entry>
                                
                                <entry>A <classname>Form</classname> (deprecated in Vaadin
                                7). The fields of the form are automatically created from
                                the item's properties using a
                                <classname>FormFieldFactory</classname>. The normal use
                                for this property type is inside a
                                <classname>Form</classname> and is less useful inside a
                                <classname>Table</classname>.</entry>
                            </row>
                            <row valign="top">
                                <entry><emphasis>other</emphasis></entry>
                                
                                <entry>A <classname>TextField</classname>. The text field
                                    manages conversions from the basic types, if
                                    possible.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                
                <para>
                    Field factories are covered with more detail in <xref
                        linkend="datamodel.itembinding"/>. You could just implement the
                    <classname>TableFieldFactory</classname> interface, but we recommend that
                    you extend the <classname>DefaultFieldFactory</classname> according to
                    your needs. In the default implementation, the mappings are defined in the
                    <methodname>createFieldByPropertyType()</methodname> method (you might
                    want to look at the source code) both for tables and forms.
                </para>
            </section>

            <section>
                <title>Navigation in Editable Mode</title>

                <para>
                    In the editable mode, the editor fields can have focus. Pressing
                    <keycap>Tab</keycap> moves the focus to next column or, at the last
                    column, to the first column of the next item. Respectively, pressing
                    <keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves
                    the focus backward. If the focus is in the last column of the last
                    visible item, the pressing <keycap>Tab</keycap> moves the focus
                    outside the table. Moving backward from the first column of the first
                    item moves the focus to the table itself. Some updates to the table,
                    such as changing the headers or footers or regenerating a column, can
                    move the focus from an editor component to the table itself.
                </para>

                <para>
                    The default behaviour may be undesirable in many cases. For example,
                    the focus also goes through any read-only editor fields and can move
                    out of the table inappropriately. You can provide better navigation is
                    to use event handler for shortcut keys such as <keycap>Tab</keycap>,
                    <keycap>Arrow Up</keycap>, <keycap>Arrow Down</keycap>, and
                    <keycap>Enter</keycap>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Keyboard navigation
class KbdHandler implements Handler {
    Action tab_next = new ShortcutAction("Tab",
            ShortcutAction.KeyCode.TAB, null);
    Action tab_prev = new ShortcutAction("Shift+Tab",
            ShortcutAction.KeyCode.TAB,
            new int[] {ShortcutAction.ModifierKey.SHIFT});
    Action cur_down = new ShortcutAction("Down",
            ShortcutAction.KeyCode.ARROW_DOWN, null);
    Action cur_up   = new ShortcutAction("Up",
            ShortcutAction.KeyCode.ARROW_UP,   null);
    Action enter   = new ShortcutAction("Enter",
            ShortcutAction.KeyCode.ENTER,      null);
    public Action[] getActions(Object target, Object sender) {
        return new Action[] {tab_next, tab_prev, cur_down,
                             cur_up, enter};
    }

    public void handleAction(Action action, Object sender,
                             Object target) {
        if (target instanceof TextField) {
            // Move according to keypress
            int itemid = (Integer) ((TextField) target).getData();
            if (action == tab_next || action == cur_down)
                itemid++;
            else if (action == tab_prev || action == cur_up)
                itemid--;
            // On enter, just stay where you were. If we did
            // not catch the enter action, the focus would be
            // moved to wrong place.
            
            if (itemid >= 0 && itemid < table.size()) {
                TextField newTF = valueFields.get(itemid);
                if (newTF != null)
                    newTF.focus();
            }
        }
    }
}

// Panel that handles keyboard navigation
Panel navigator = new Panel();
navigator.addStyleName(Reindeer.PANEL_LIGHT);
navigator.addComponent(table);
navigator.addActionHandler(new KbdHandler());]]></programlisting>

                <para>
                    The main issue in implementing keyboard navigation in an editable
                    table is that the editor fields do not know the table they are in. To
                    find the parent table, you can either look up in the component
                    container hierarchy or simply store a reference to the table with
                    <methodname>setData()</methodname> in the field component. The other
                    issue is that you can not acquire a reference to an editor field from
                    the <classname>Table</classname> component. One solution is to use
                    some external collection, such as a <classname>HashMap</classname>, to
                    map item IDs to the editor fields.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Can't access the editable components from the table so
// must store the information
final HashMap<Integer,TextField> valueFields =
    new HashMap<Integer,TextField>();]]></programlisting>

                <para>
                    The map has to be filled in a
                    <classname>TableFieldFactory</classname>, such as in the
                    following. You also need to set the reference to the table there and
                    you can also set the initial focus there.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[table.setTableFieldFactory(new TableFieldFactory () {
    public Field createField(Container container, Object itemId,
            Object propertyId, Component uiContext) {
        TextField field = new TextField((String) propertyId);
        
        // User can only edit the numeric column
        if ("Source of Fear".equals(propertyId))
            field.setReadOnly(true);
        else { // The numeric column
            // The field needs to know the item it is in
            field.setData(itemId);
            
            // Remember the field
            valueFields.put((Integer) itemId, field);
            
            // Focus the first editable value
            if (((Integer)itemId) == 0)
                field.focus();
        }
        return field;
    }
});]]></programlisting>

                <para>
                    The issues are complicated by the fact that the editor fields are not
                    generated for the entire table, but only for a cache window that
                    includes the visible items and some items above and below it. For
                    example, if the beginning of a big scrollable table is visible, the
                    editor component for the last item does not exist. This issue is
                    relevant mostly if you want to have wrap-around navigation that jumps
                    from the last to first item and vice versa.
                </para>
            </section>

        </section>

        <section xml:id="components.table.headersfooters">
            <title>Column Headers and Footers</title>
            
            <para>
                <classname>Table</classname> supports both column headers and footers; the
                headers are enabled by default.
            </para>

            <section xml:id="components.table.headersfooters.headers">
                <title>Headers</title>

                <para>
                    The table header displays the column headers at the top of the
                    table. You can use the column headers to reorder or resize the
                    columns, as described earlier. By default, the header of a column is
                    the property ID of the column, unless given explicitly with
                    <methodname>setColumnHeader()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Define the properties
table.addContainerProperty("lastname", String.class, null);
table.addContainerProperty("born", Integer.class, null);
table.addContainerProperty("died", Integer.class, null);

// Set nicer header names
table.setColumnHeader("lastname", "Name");
table.setColumnHeader("born", "Born");
table.setColumnHeader("died", "Died");]]></programlisting>

                <para>
                    The text of the column headers and the visibility of the header
                    depends on the <emphasis>column header mode</emphasis>. The header is
                    visible by default, but you can disable it with
                    <methodname>setColumnHeaderMode(Table.COLUMN_HEADER_MODE_HIDDEN)</methodname>.
                </para>
            </section>

            <section xml:id="components.table.headersfooters.footers">
                <title>Footers</title>

                <para>
                    The table footer can be useful for displaying sums or averages of
                    values in a column, and so on. The footer is not visible by default;
                    you can enable it with
                    <methodname>setFooterVisible(true)</methodname>. Unlike in the header,
                    the column headers are empty by default. You can set their value with
                    <methodname>setColumnFooter()</methodname>. The columns are identified
                    by their property ID.
                </para>

                <para>
                    The following example shows how to calculate average of the values in
                    a column:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have a table with a numeric column
Table table = new Table("Custom Table Footer");
table.addContainerProperty("Name", String.class, null);
table.addContainerProperty("Died At Age", Integer.class, null);
        
// Insert some data
Object people[][] = {{"Galileo",  77},
                     {"Monnier",  83},
                     {"Vaisala",  79},
                     {"Oterma",   86}};
for (int i=0; i<people.length; i++)
    table.addItem(people[i], new Integer(i));
        
// Calculate the average of the numeric column
double avgAge = 0;
for (int i=0; i<people.length; i++)
    avgAge += (Integer) people[i][1];
avgAge /= people.length;

// Set the footers
table.setFooterVisible(true);
table.setColumnFooter("Name", "Average");
table.setColumnFooter("Died At Age", String.valueOf(avgAge));

// Adjust the table height a bit
table.setPageLength(table.size());]]></programlisting>

                <para>
                    The resulting table is shown in <xref
                    linkend="figure.components.table.headersfooters.footer"/>.
                </para>

				<figure xml:id="figure.components.table.headersfooters.footer">
					<title>A Table with a Footer</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/components/table-footer.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="120" smallscale="80%" align="center" fileref="img/components/table-footer.png"/>
						</imageobject>
					</mediaobject>
				</figure>
            </section>

            <section>
                <title>Handling Mouse Clicks on Headers and Footers</title>

                <para>
                    Normally, when the user clicks a column header, the table will be
                    sorted by the column, assuming that the data source is
                    <classname>Sortable</classname> and sorting is not disabled. In some
                    cases, you might want some other functionality when the user clicks
                    the column header, such as selecting the column in some way.
                </para>

                <para>
                    Clicks in the header cause a <classname>HeaderClickEvent</classname>,
                    which you can handle with a
                    <classname>Table.HeaderClickListener</classname>. Click events on the
                    table header (and footer) are, like button clicks, sent immediately to
                    server, so there is no need to set
                    <methodname>setImmediate()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Handle the header clicks
table.addListener(new Table.HeaderClickListener() {
    public void headerClick(HeaderClickEvent event) {
        String column = (String) event.getPropertyId();
        Notification.show("Clicked " + column +
                "with " + event.getButtonName());
    }
});
        
// Disable the default sorting behavior
table.setSortDisabled(true);]]></programlisting>

                <para>
                    Setting a click handler does not automatically disable the sorting
                    behavior of the header; you need to disable it explicitly with
                    <methodname>setSortDisabled(true)</methodname>. Header click events
                    are not sent when the user clicks the column resize handlers to drag
                    them.
                </para>


                <para>
                    The <classname>HeaderClickEvent</classname> object provides the
                    identity of the clicked column with
                    <methodname>getPropertyId()</methodname>. The
                    <methodname>getButton()</methodname> reports the mouse button with
                    which the click was made: <parameter>BUTTON_LEFT</parameter>,
                    <parameter>BUTTON_RIGHT</parameter>, or
                    <parameter>BUTTON_MIDDLE</parameter>. The
                    <methodname>getButtonName()</methodname> a human-readable button name
                    in English: "<parameter>left</parameter>",
                    "<parameter>right</parameter>", or
                    "<parameter>middle</parameter>". The
                    <methodname>isShiftKey()</methodname>,
                    <methodname>isCtrlKey()</methodname>, etc., methods indicate if the
                    <keycap>Shift</keycap>, <keycap>Ctrl</keycap>, <keycap>Alt</keycap> or
                    other modifier keys were pressed during the click.
                </para>

                <para>
                    Clicks in the footer cause a <classname>FooterClickEvent</classname>,
                    which you can handle with a
                    <classname>Table.FooterClickListener</classname>. Footers do not have
                    any default click behavior, like the sorting in the header. Otherwise,
                    handling clicks in the footer is equivalent to handling clicks in the
                    header.
                </para>
            </section>
        </section>

		<section xml:id="components.table.columngenerator">
			<title>Generated Table Columns</title>

			<para>
				You might want to have a column that has values calculated from other
				columns. Or you might want to format table columns in some way, for
				example if you have columns that display currencies. The
				<classname>ColumnGenerator</classname> interface allows defining custom
				generators for such columns.
			</para>

			<para>
				You add new generated columns to a <classname>Table</classname> with
				<methodname>addGeneratedColumn()</methodname>. It takes the column
				identifier as its parameters. Usually you want to have a more
				user-friendly and possibly internationalized column header. You can set
				the header and a possible icon by calling
				<methodname>addContainerProperty()</methodname>
				<emphasis>before</emphasis> adding the generated column.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Define table columns. 
table.addContainerProperty(
    "date",     Date.class,   null, "Date",         null, null);
table.addContainerProperty(
    "quantity", Double.class, null, "Quantity (l)", null, null);
table.addContainerProperty(
    "price",    Double.class, null, "Price (e/l)",  null, null);
table.addContainerProperty(
    "total",    Double.class, null, "Total (e)",    null, null);

// Define the generated columns and their generators.
table.addGeneratedColumn("date",
                         new DateColumnGenerator());
table.addGeneratedColumn("quantity",
                         new ValueColumnGenerator("%.2f l"));
table.addGeneratedColumn("price",
                         new PriceColumnGenerator());
table.addGeneratedColumn("total",
                         new ValueColumnGenerator("%.2f e"));]]></programlisting>

			<para>
				Notice that the <methodname>addGeneratedColumn()</methodname> always
				places the generated columns as the last column, even if you defined some
				other order previously. You will have to set the proper order with
				<methodname>setVisibleColumns()</methodname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[table.setVisibleColumns(new Object[] {"date", "quantity", "price", "total"});]]></programlisting>

			<para>
				The generators are objects that implement the
				<classname>Table.ColumnGenerator</classname> interface and its
				<methodname>generateCell()</methodname> method. The method gets the
				identity of the item and column as its parameters, in addition to the
				table object. It has to return a component object.
			</para>
				
			<para>
				The following example defines a generator for formatting
				<classname>Double</classname> valued fields according to a format string
				(as in <classname>java.util.Formatter</classname>).
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/** Formats the value in a column containing Double objects. */
class ValueColumnGenerator implements Table.ColumnGenerator {
    String format; /* Format string for the Double values. */

    /**
     * Creates double value column formatter with the given
     * format string.
     */
    public ValueColumnGenerator(String format) {
        this.format = format;
    }

    /**
     * Generates the cell containing the Double value.
     * The column is irrelevant in this use case.
     */
    public Component generateCell(Table source, Object itemId,
                                  Object columnId) {
        // Get the object stored in the cell as a property
        Property prop =
            source.getItem(itemId).getItemProperty(columnId);
        if (prop.getType().equals(Double.class)) {
            Label label = new Label(String.format(format,
                    new Object[] { (Double) prop.getValue() }));
            
            // Set styles for the column: one indicating that it's
            // a value and a more specific one with the column
            // name in it. This assumes that the column name
            // is proper for CSS.
            label.addStyleName("column-type-value");
            label.addStyleName("column-" + (String) columnId);
            return label;
        }
        return null;
    }
}]]></programlisting>

            <!-- TODO: The following was removed because it's probably false (#3189). -->
			<!-- para>
				If you wish to have a custom style for the cells, you have to set it in
				the generator. A <classname>CellStyleGenerator</classname> defined for a
				table will not be called for the cells of generated columns.
			</para -->

			<para>
				The generator is called for all the visible (or more accurately cached)
				items in a table. If the user scrolls the table to another position in the
				table, the columns of the new visible rows are generated dynamically. The
				columns in the visible (cached) rows are also generated always when an
				item has a value change. It is therefore usually safe to calculate the
				value of generated cells from the values of different rows (items).
			</para>

			<para>
				When you set a table as <parameter>editable</parameter>, regular fields
				will change to editing fields. When the user changes the values in the
				fields, the generated columns will be updated automatically. Putting a
				table with generated columns in editable mode has a few quirks. The
				editable mode of <classname>Table</classname> does not affect generated
				columns. You have two alternatives: either you generate the editing fields
				in the generator or, in case of formatter generators, remove the generator
				in the editable mode. The example below uses the latter approach.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Have a check box that allows the user
// to make the quantity and total columns editable.
final CheckBox editable = new CheckBox(
    "Edit the input values - calculated columns are regenerated");

editable.setImmediate(true);
editable.addListener(new ClickListener() {
    public void buttonClick(ClickEvent event) {
        table.setEditable(editable.booleanValue());
        
        // The columns may not be generated when we want to
        // have them editable.
        if (editable.booleanValue()) {
            table.removeGeneratedColumn("quantity");
            table.removeGeneratedColumn("total");
        } else { // Not editable
            // Show the formatted values.
            table.addGeneratedColumn("quantity",
                new ValueColumnGenerator("%.2f l"));
            table.addGeneratedColumn("total",
                new ValueColumnGenerator("%.2f e"));
        }
        // The visible columns are affected by removal
        // and addition of generated columns so we have
        // to redefine them.
        table.setVisibleColumns(new Object[] {"date", "quantity",
                 "price", "total", "consumption", "dailycost"});
    }
});]]></programlisting>

            <para>
                You will also have to set the editing fields in
                <parameter>immediate</parameter> mode to have the update occur immediately
                when an edit field loses the focus. You can set the fields in
                <parameter>immediate</parameter> mode with the a custom
                <classname>TableFieldFactory</classname>, such as the one given below,
                that just extends the default implementation to set the mode:
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class ImmediateFieldFactory extends DefaultFieldFactory {
    public Field createField(Container container,
                             Object itemId,
                             Object propertyId,
                             Component uiContext) {
        // Let the DefaultFieldFactory create the fields...
        Field field = super.createField(container, itemId,
                                        propertyId, uiContext);
        
        // ...and just set them as immediate.
        ((AbstractField)field).setImmediate(true);
        
        return field;
    }
}
...
table.setTableFieldFactory(new ImmediateFieldFactory());]]></programlisting>

			<para>
				If you generate the editing fields with the column generator, you avoid
				having to use such a field factory, but of course have to generate the
				fields for both normal and editable modes.
			</para>

			<para>
				<xref linkend="figure.ui.table.generated"/> shows a table with
				columns calculated (blue) and simply formatted (black) with column
				generators.
			</para>

			<figure xml:id="figure.ui.table.generated">
				<title>Table with Generated Columns in Normal and Editable Mode</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/table-generatedcolumns1.png"/>
					</imageobject>
				</mediaobject>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/table-generatedcolumns2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

        <section xml:id="components.table.columnformatting">
            <title>Formatting Table Columns</title>

            <para>
                The displayed values of properties shown in a table are normally formatted
                using the <methodname>toString()</methodname> method of each
                property. Customizing the format of a column can be done in several ways:
            </para>

            <itemizedlist>
                <listitem>Using <classname>ColumnGenerator</classname> to generate a
                second column that is formatted. The original column needs to be set
                invisible. See <xref
                linkend="components.table.columngenerator"/>.</listitem>

                <listitem>Using a <classname>PropertyFormatter</classname> as a proxy
                between the table and the data property. This also normally requires using
                an mediate container in the table.</listitem>

                <listitem>Overriding the default
                <methodname>formatPropertyValue()</methodname> in
                <classname>Table</classname>.</listitem>
            </itemizedlist>

            <para>
                As using a <classname>PropertyFormatter</classname> is generally much more
                awkward than overriding the
                <methodname>formatPropertyValue()</methodname>, its use is not described
                here.
            </para>

            <para>
                You can override <methodname>formatPropertyValue()</methodname> as is done
                in the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a table that overrides the default
// property (column) format
final Table table = new Table("Formatted Table") {
    @Override
    protected String formatPropertyValue(Object rowId,
            Object colId, Property property) {
        // Format by property type
        if (property.getType() == Date.class) {
            SimpleDateFormat df =
                new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
            return df.format((Date)property.getValue());
        }

        return super.formatPropertyValue(rowId, colId, property);
    }
};
        
// The table has some columns
table.addContainerProperty("Time", Date.class, null);
        
... Fill the table with data ...]]></programlisting>

            <para>
                You can also distinguish between columns by the
                <parameter>colId</parameter> parameter, which is the property ID of the
                column. <classname>DecimalFormat</classname> is useful for formatting
                decimal values.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[... in formatPropertyValue() ...
} else if ("Value".equals(pid)) {
    // Format a decimal value for a specific locale
    DecimalFormat df = new DecimalFormat("#.00",
            new DecimalFormatSymbols(locale));
    return df.format((Double) property.getValue());
}
...
table.addContainerProperty("Value", Double.class, null);]]></programlisting>

            <para>
                A table with the formatted date and decimal value columns is shown in
                <xref linkend="figure.components.table.columnformatting"/>.
            </para>

            <figure xml:id="figure.components.table.columnformatting">
                <title>Formatted Table Columns</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/table-columnformatting.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/table-columnformatting.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can use CSS for further styling of table rows, columns, and individual
                cells by using a <classname>CellStyleGenerator</classname>. It is
                described in <xref linkend="components.table.css"/>.
            </para>
        </section>

		<section xml:id="components.table.css">
			<title>CSS Style Rules</title>

            <para>
                Styling the overall style of a <classname>Table</classname> can be done
                with the following CSS rules.
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[.v-table {}
  .v-table-header-wrap {}
    .v-table-header {}
      .v-table-header-cell {}
        .v-table-resizer {} /* Column resizer handle. */
        .v-table-caption-container {}
  .v-table-body {}
    .v-table-row-spacer {}
    .v-table-table {}
      .v-table-row {}
        .v-table-cell-content {}]]></programlisting>

			<para>
				Notice that some of the widths and heights in a table are calculated
				dynamically and can not be set in CSS.
			</para>

			<section>
				<title>Setting Individual Cell Styles</title>

				<para>
					The <classname>Table.CellStyleGenerator</classname> interface allows
					you to set the CSS style for each individual cell in a table. You need
					to implement the <methodname>getStyle()</methodname>, which gets the
					row (item) and column (property) identifiers as parameters and can
					return a style name for the cell. The returned style name will be
					concatenated to prefix "<literal>v-table-cell-content-</literal>".
				</para>

                <para>
                    The <methodname>getStyle()</methodname> is called also for each row,
                    so that the <parameter>propertyId</parameter> parameter is
                    <literal>null</literal>. This allows setting a row style.
                </para>

				<para>
					Alternatively, you
					can use a <classname>Table.ColumnGenerator</classname> (see <xref
					linkend="components.table.columngenerator"/>) to generate the actual UI
					components of the cells and add style names to them.
				</para>
			
				<programlisting><?pocket-size 65% ?><![CDATA[Table table = new Table("Table with Cell Styles");
table.addStyleName("checkerboard");

// Add some columns in the table. In this example, the property
// IDs of the container are integers so we can determine the
// column number easily.
table.addContainerProperty("0", String.class, null, "", null, null);
for (int i=0; i<8; i++)
    table.addContainerProperty(""+(i+1), String.class, null,
                         String.valueOf((char) (65+i)), null, null);

// Add some items in the table.
table.addItem(new Object[]{
    "1", "R", "N", "B", "Q", "K", "B", "N", "R"}, new Integer(0));
table.addItem(new Object[]{
    "2", "P", "P", "P", "P", "P", "P", "P", "P"}, new Integer(1));
for (int i=2; i<6; i++)
    table.addItem(new Object[]{String.valueOf(i+1), 
                 "", "", "", "", "", "", "", ""}, new Integer(i));
table.addItem(new Object[]{
    "7", "P", "P", "P", "P", "P", "P", "P", "P"}, new Integer(6));
table.addItem(new Object[]{
    "8", "R", "N", "B", "Q", "K", "B", "N", "R"}, new Integer(7));
table.setPageLength(8);

// Set cell style generator
table.setCellStyleGenerator(new Table.CellStyleGenerator() {
    public String getStyle(Object itemId, Object propertyId) {
        // Row style setting, not relevant in this example.
        if (propertyId == null)
            return "green"; // Will not actually be visible

        int row = ((Integer)itemId).intValue();
        int col = Integer.parseInt((String)propertyId);
        
        // The first column.
        if (col == 0)
            return "rowheader";
        
        // Other cells.
        if ((row+col)%2 == 0)
            return "black";
        else
            return "white";
    }
});]]></programlisting>
				
				<para>
					You can then style the cells, for example, as follows:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[/* Center the text in header. */
.v-table-header-cell {
    text-align: center;
}

/* Basic style for all cells. */
.v-table-checkerboard .v-table-cell-content {
    text-align: center;
    vertical-align: middle;
    padding-top: 12px;
    width: 20px;
    height: 28px;
}

/* Style specifically for the row header cells. */
.v-table-cell-content-rowheader {
	background: #E7EDF3
     url(../default/table/img/header-bg.png) repeat-x scroll 0 0;
}

/* Style specifically for the "white" cells. */
.v-table-cell-content-white {
    background: white;
    color: black;
}

/* Style specifically for the "black" cells. */
.v-table-cell-content-black {
    background: black;
    color: white;
}]]></programlisting>

				<para>
					The table will look as shown in <xref
					linkend="figure.components.table.cell-style"/>.
				</para>

				<figure xml:id="figure.components.table.cell-style">
					<title>Cell Style Generator for a Table</title>
					<mediaobject>
						<imageobject role="fo">
							<imagedata align="center" scale="75" fileref="img/components/table-cellstylegenerator1.png"/>
						</imageobject>
						<imageobject role="html">
							<imagedata smallscale="125" align="center" fileref="img/components/table-cellstylegenerator1.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>

		<!-- programlisting><![CDATA[]]></programlisting -->
        <indexterm startref="term.components.table" class="endofrange"/>
	</section>

	<section xml:id="components.tree">
		<title><classname>Tree</classname></title>

		<para>
			The <classname>Tree</classname> component allows a natural way to represent
			data that has hierarchical relationships, such as filesystems or message
			threads. The <classname>Tree</classname> component in Vaadin works
			much like the tree components of most modern desktop user interface toolkits,
			for example in directory browsing.
		</para>

		<para>
			The typical use of the <classname>Tree</classname> component is for displaying
			a hierachical menu, like a menu on the left side of the screen, as in <xref
			linkend="figure.components.tree"/>, or for displaying filesystems or
			other hierarchical datasets. The <parameter>menu</parameter> style makes the
			appearance of the tree more suitable for this purpose.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[final Object[][] planets = new Object[][]{
        new Object[]{"Mercury"}, 
        new Object[]{"Venus"},
        new Object[]{"Earth", "The Moon"},    
        new Object[]{"Mars", "Phobos", "Deimos"},
        new Object[]{"Jupiter", "Io", "Europa", "Ganymedes",
                                "Callisto"},
        new Object[]{"Saturn",  "Titan", "Tethys", "Dione",
                                "Rhea", "Iapetus"},
        new Object[]{"Uranus",  "Miranda", "Ariel", "Umbriel",
                                "Titania", "Oberon"},
        new Object[]{"Neptune", "Triton", "Proteus", "Nereid",
                                "Larissa"}};
        
Tree tree = new Tree("The Planets and Major Moons");

/* Add planets as root items in the tree. */
for (int i=0; i<planets.length; i++) {
    String planet = (String) (planets[i][0]);
    tree.addItem(planet);
    
    if (planets[i].length == 1) {
        // The planet has no moons so make it a leaf.
        tree.setChildrenAllowed(planet, false);
    } else {
        // Add children (moons) under the planets.
        for (int j=1; j<planets[i].length; j++) {
            String moon = (String) planets[i][j];
            
            // Add the item as a regular item.
            tree.addItem(moon);
            
            // Set it to be a child.
            tree.setParent(moon, planet);
            
            // Make the moons look like leaves.
            tree.setChildrenAllowed(moon, false);
        }

        // Expand the subtree.
        tree.expandItemsRecursively(planet);
    }
}

main.addComponent(tree);]]></programlisting>

		<para>
			<xref linkend="figure.components.tree"/> below shows the tree from the code
			example in a practical situation.
		</para>

		<figure xml:id="figure.components.tree" float="center" floatstyle="before">
			<title>A <classname>Tree</classname> Component as a Menu</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/tree-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/components/tree-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can read or set the currently selected item by the value property of the
			<classname>Tree</classname> component, that is, with
			<methodname>getValue()</methodname> and
			<methodname>setValue()</methodname>. When the user clicks an item on a tree,
			the tree will receive an <classname>ValueChangeEvent</classname>, which you
			can catch with a <classname>ValueChangeListener</classname>. To receive the
			event immediately after the click, you need to set the tree as
			<classname>setImmediate(true)</classname>.
		</para>

		<para>
			The <classname>Tree</classname> component uses
			<classname>Container</classname> data sources much like the
			<classname>Table</classname> component, with the addition that it also
			utilizes hierarchy information maintained by a
			<classname>HierarchicalContainer</classname>. The contained items can be of
			any item type supported by the container. The default container and its
			<methodname>addItem()</methodname> assume that the items are strings and the
			string value is used as the item ID.
		</para>
	</section>

	<section xml:id="components.menubar">
		<title><classname>MenuBar</classname></title>

		<para>
			The <classname>MenuBar</classname> component allows creating horizontal
			dropdown menus, much like the main menu in desktop applications.
		</para>

		<programlisting><![CDATA[// Create a menu bar
final MenuBar menubar = new MenuBar();
main.addComponent(menubar);]]></programlisting>

		<para>
			You insert the top-level menu items to a <classname>MenuBar</classname> object
			with the <methodname>addItem()</methodname> method. It takes a string label,
			an icon resource, and a command as its parameters. The icon and command are
			not required and can be <parameter>null</parameter>.
		</para>

		<programlisting><![CDATA[MenuBar.MenuItem beverages =
      menubar.addItem("Beverages", null, null);]]></programlisting>

		<para>
			The command is called when the user clicks the item. A menu command is a class
			that implements the <classname>MenuBar.Command</classname> interface.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[// A feedback component
final Label selection = new Label("-");
main.addComponent(selection);

// Define a common menu command for all the menu items.
MenuBar.Command mycommand = new MenuBar.Command() {
    public void menuSelected(MenuItem selectedItem) {
        selection.setValue("Ordered a " +
                           selectedItem.getText() +
                           " from menu.");
    }  
};]]></programlisting>

		<para>
			The <methodname>addItem()</methodname> method returns a
			<classname>MenuBar.MenuItem</classname> object, which you can use to add
			sub-menu items. The <classname>MenuItem</classname> has an identical
			<methodname>addItem()</methodname> method.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[// Put some items in the menu hierarchically
MenuBar.MenuItem beverages =
    menubar.addItem("Beverages", null, null);
MenuBar.MenuItem hot_beverages =
    beverages.addItem("Hot", null, null);
hot_beverages.addItem("Tea", null, mycommand);
hot_beverages.addItem("Coffee", null, mycommand);
MenuBar.MenuItem cold_beverages =
    beverages.addItem("Cold", null, null);
cold_beverages.addItem("Milk", null, mycommand);

// Another top-level item
MenuBar.MenuItem snacks =
    menubar.addItem("Snacks", null, null);
snacks.addItem("Weisswurst", null, mycommand);
snacks.addItem("Salami", null, mycommand);

// Yet another top-level item
MenuBar.MenuItem services =
    menubar.addItem("Services", null, null);
services.addItem("Car Service", null, mycommand);]]></programlisting>

		<para>
			The menu will look as follows:
		</para>

		<figure>
			<title>Menu Bar</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/menubar-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="85" smallscale="70%" align="center" fileref="img/components/menubar-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-menubar { }
.gwt-MenuItem {}
.gwt-MenuItem-selected {}]]></programlisting>
			
			<para>
				The menu bar has the overall style name
				<literal>.v-menubar</literal>. Each menu item has
				<literal>.gwt-MenuItem</literal> style normally and
				<literal>.gwt-MenuItem-selected</literal> when the item is selected.
			</para>
			
		</simplesect>
	</section>

	<section xml:id="components.embedded">
		<title>Embedded Resources</title>

		<para>
            You can embed images in Vaadin UIs with the <classname>Image</classname>
            component, Adobe Flash graphics with <classname>Flash</classname>, and other
            web content with <classname>BrowserFrame</classname>. There is also a generic
            <classname>Embedded</classname> component for embedding other object
            types. The embedded content is referenced as <emphasis>resources</emphasis>,
            as described in <xref linkend="application.resources"/>.
		</para>

		<para>
			The following example displays an image as a class resource loaded with the
			class loader:
		</para>

		<programlisting><![CDATA[Image image = new Image("Yes, logo:",
    new ClassResource("vaadin-logo.png"));
main.addComponent(image);]]></programlisting>

        <para>
            The caption can be given as null to disable it. An empty string displays an
            empty caption which takes a bit space. The caption is managed by the
            containing layout.
        </para>

        <para>
            You can set an altenative text for an embedded resource with
            <methodname>setAlternateText()</methodname>, which can be shown if images are
            disabled in the browser for some reason. The text can be used for
            accessibility purposes, such as for text-to-speech generation.
        </para>

		<section xml:id="components.embedded.image">
			<title>Embedded <classname>Image</classname></title>

            <para>
                The <classname>Image</classname> component allows embedding an image
                resource in a Vaadin UI.
            </para>

		<programlisting><![CDATA[// Serve the image from the theme
Resource res = new ThemeResource("img/myimage.png");

// Display the image without caption
Image image = new Image(null, res);
layout.addComponent(image);]]></programlisting>


            <para>
                The <classname>Image</classname> component has by default undefined size
                in both directions, so it will automatically fit the size of the embedded
                image.

                <indexterm><primary>scroll bars</primary></indexterm>

                If you want scrolling with scroll bars, you can put the image inside a
                <classname>Panel</classname> that has a defined size to enable scrolling,
                as described in <xref linkend="layout.panel.scrolling"/>. You can also put
                it inside some other component container and set the <literal>overflow:
                auto</literal> CSS property for the container element in a theme to enable
                automatic scrollbars.  <indexterm>overflow CSS property</indexterm>
            </para>

            <book-example id="component.embedded.scrolling-css"></book-example>

            <section xml:id="components.embedded.image.generated">
                <title>Generating and Reloading Images</title>

                <para>
                    You can also generate the image content dynamically using a
                    <classname>StreamResource</classname>, as described in <xref
                    linkend="application.resources.stream"/>, or with a
                    <classname>RequestHandler</classname>.
                </para>

                <para>
                    If the image changes, the browser needs to reload it. Simply updating
                    the stream resource is not enough. Because of how caching is handled
                    in some browsers, you can cause a reload easiest by renaming the
                    filename of the resource with a unique name, such as one including a
                    timestamp. You should set cache time to zero with
                    <methodname>setCacheTime()</methodname> for the resource object when
                    you create it.

                    <!-- BUG #2470. -->
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create the stream resource with some initial filename
StreamResource imageResource =
    new StreamResource(imageSource, "initial-filename.png");

// Instruct browser not to cache the image
imageResource.setCacheTime(0);

// Display the image
Image image = new Image(null, imageResource);]]></programlisting>

                <para>
                    When refreshing, you also need to call
                    <methodname>markAsDirty()</methodname> for the
                    <classname>Image</classname> object.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// This needs to be done, but is not sufficient
image.markAsDirty();

// Generate a filename with a timestamp
SimpleDateFormat df = new SimpleDateFormat("yyyyMMddHHmmssSSS");
String filename = "myfilename-" + df.format(new Date()) + ".png";

// Replace the filename in the resource
imageResource.setFilename(makeImageFilename());]]></programlisting>
            </section>
        </section>
		
		<section xml:id="components.embedded.flash">
			<title>Adobe <classname>Flash</classname> Graphics</title>

			<para>
                The <classname>Flash</classname> component allows embedding Adobe Flash
                animations in Vaadin UIs.
			</para>

			<programlisting><![CDATA[Flash flash = new Flash(null,
    new ThemeResource("img/vaadin_spin.swf"));
layout.addComponent(flash);]]></programlisting>

			<para>
				You can set Flash parameters with <methodname>setParameter()</methodname>,
				which takes a parameter's name and value as strings. You can also set the
				<parameter>codeBase</parameter>, <parameter>archive</parameter>, and
				<parameter>standBy</parameter> attributes for the Flash object element in
				HTML.
			</para>
		</section>
		
		<section xml:id="components.embedded.browserframe">
			<title><classname>BrowserFrame</classname></title>

			<para>
				The <classname>BrowserFrame</classname> allows embedding web content
				inside an HTML <tag>&lt;iframe&gt;</tag> element. You can refer to an
				external URL with <classname>ExternalResource</classname>.
			</para>

            <para>
                As the <classname>BrowserFrame</classname> has undefined size by default,
                it is critical that you define a meaningful size for it, either fixed or
                relative.
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[BrowserFrame browser = new BrowserFrame("Browser",
    new ExternalResource("http://demo.vaadin.com/sampler/"));
browser.setWidth("600px");
browser.setHeight("400px");
layout.addComponent(browser);]]></programlisting>

            <para>
                Notice that web pages can prevent embedding them in an <tag>&lt;iframe&gt;</tag>.
            </para>
		</section>

		<section xml:id="components.embedded.embedded">
			<title>Generic <classname>Embedded</classname> Objects</title>

            <para>
                The generic <classname>Embedded</classname> component allows embedding all
                sorts of objects, such as SVG graphics, Java applets, and PDF documents,
                in addition to the images, Flash graphics, and browser frames which you
                can embed with the specialized components.
            </para>

            <para>
                For example, to display a Flash animation:
            </para>

			<programlisting><![CDATA[// A resource reference to some object
Resource res = new ThemeResource("img/vaadin_spin.swf");

// Display the object
Embedded object = new Embedded("My Object", res);
layout.addComponent(object);]]></programlisting>

            <para>
                Or an SVG image:
            </para>

			<programlisting><![CDATA[// A resource reference to some object
Resource res = new ThemeResource("img/reindeer.svg");

// Display the object
Embedded object = new Embedded("My SVG", res);
object.setMimeType("image/svg+xml"); // Unnecessary
layout.addComponent(object);]]></programlisting>

            <para>
                The MIME type of the objects is usually detected automatically from the
                filename extension with the <classname>FileTypeResolver</classname>
                utility in Vaadin. If not, you can set it explicitly with
                <methodname>setMimeType()</methodname>, as was done in the example above
                (where it was actually unnecessary).
            </para>

            <para>
                Some embeddable object types may require special support in the
                browser. You should make sure that there is a proper fallback mechanism if
                the browser does not support the embedded type.
            </para>
        </section>
	</section>

	<section xml:id="components.upload">
		<title><classname>Upload</classname></title>
		
		<para>
			The <classname>Upload</classname> component allows a user to upload
			files to the server. It displays a file name entry box, a file
			selection button, and an upload submit button. The user can either
			write the filename in the text area or click the <guibutton>Browse</guibutton> button to
			select a file. After the file is selected, the user sends the file by
			clicking the upload submit button.
		</para>

		<para>
            Uploading requires a receiver that implements
            <interfacename>Upload.Receiver</interfacename> to provide an output stream to
            which the upload is written by the server.
        </para>

		<programlisting><?pocket-size 75% ?><![CDATA[Upload upload = new Upload("Upload it here", receiver);]]></programlisting>

		<figure xml:id="figure.ui.upload">
			<title>Upload Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="80%" align="center" fileref="img/components/upload.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can set the text of the upload button with
			<methodname>setButtonCaption()</methodname>. Note that it is difficult to
			change the caption or look of the <guibutton>Browse</guibutton> button. This
			is a security feature of web browsers. The language of the
			<guibutton>Browse</guibutton> button is determined by the browser, so if you
			wish to have the language of the <classname>Upload</classname> component
			consistent, you will have to use the same language in your application.
		</para>

		<programlisting><![CDATA[upload.setButtonCaption("Upload Now");]]></programlisting>

		<para>
            You can also hide the upload button with

            <literal>.v-upload .v-button {display: none}</literal> in theme,

            have custom logic for starting the upload, and call
            <methodname>startUpload()</methodname> to start it. If the upload component
            has <methodname>setImmediate(true)</methodname> enabled, uploading starts
            immediately after choosing the file.
        </para>

        <simplesect xml:id="components.upload.receiving">
            <title>Receiving Upload Data</title>

            <para>
                The uploaded files are typically stored as files in a file system, in
                a database, or as temporary objects in memory. The upload component
                writes the received data to an
                <classname>java.io.OutputStream</classname> so you have plenty of
                freedom in how you can process the upload content.
            </para>
		
            <para>
                To use the <classname>Upload</classname> component, you need to implement the
                <classname>Upload.Receiver</classname> interface. The
                <methodname>receiveUpload()</methodname> method of the receiver is called when
                the user clicks the submit button. The method must return an
                <classname>OutputStream</classname>. To do this, it typically creates a file
                or a memory buffer to which the stream is written. The method gets the file
                name and MIME type of the file, as reported by the browser.
            </para>

            <para>
                When an upload is finished, successfully or unsuccessfully, the
                <classname>Upload</classname> component will emit the
                <classname>Upload.FinishedEvent</classname> event, which you can handle with
                an <classname>Upload.FinishedListener</classname> added to the upload
                component. The event object will include the file name, MIME type, and final
                length of the file. More specific <classname>Upload.FailedEvent</classname>
                and <classname>Upload.SucceededEvent</classname> events will be called in the
                cases where the upload failed or succeeded, respectively.
            </para>

            <para>
                The following example uploads images to <filename>/tmp/uploads</filename>
                directory in (UNIX) filesystem (the directory must exist or the upload
                fails). The component displays the uploaded image in an
                <classname>Image</classname> component.
            </para>

            <book-example id="component.upload.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[// Show uploaded file in this placeholder
final Embedded image = new Embedded("Uploaded Image");
image.setVisible(false);

// Implement both receiver that saves upload in a file and
// listener for successful upload
class ImageUploader implements Receiver, SucceededListener {
    public File file;
    
    public OutputStream receiveUpload(String filename,
                                      String mimeType) {
        // Create upload stream
        FileOutputStream fos = null; // Stream to write to
        try {
            // Open the file for writing.
            file = new File("/tmp/uploads/" + filename);
            fos = new FileOutputStream(file);
        } catch (final java.io.FileNotFoundException e) {
            new Notification("Could not open file<br/>",
                             e.getMessage(),
                             Notification.Type.ERROR_MESSAGE)
                .show(Page.getCurrent());
            return null;
        }
        return fos; // Return the output stream to write to
    }

    public void uploadSucceeded(SucceededEvent event) {
        // Show the uploaded file in the image viewer
        image.setVisible(true);
        image.setSource(new FileResource(file));
    }
};
ImageUploader receiver = new ImageUploader(); 

// Create the upload with a caption and set receiver later
Upload upload = new Upload("Upload Image Here", receiver);
upload.setButtonCaption("Start Upload");
upload.addSucceededListener(receiver);
        
// Put the components in a panel
Panel panel = new Panel("Cool Image Storage");
Layout panelContent = new VerticalLayout();
panelContent.addComponents(upload, image);
panel.setContent(panelContent);]]></programlisting>

            <para>
                Note that the example does not check the type of the uploaded files in any
                way, which will cause an error if the content is anything else but an
                image. The program also assumes that the MIME type of the file is resolved
                correctly based on the file name extension. After uploading an image, the
                component will look as shown in <xref linkend="figure.ui.upload.example"/>.
            </para>

            <figure xml:id="figure.ui.upload.example">
                <title>Image Upload Example</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/components/upload-example.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

		<simplesect xml:id="components.upload.css">
			<title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-upload { }
  .gwt-FileUpload { }
  .v-button { }
    .v-button-wrap { }
      .v-button-caption { }]]></programlisting>

			<para>
                The <classname>Upload</classname> component has an overall
                <literal>v-upload</literal> style. The upload button has the same
                structure and style as a regular <classname>Button</classname> component.
            </para>
        </simplesect>
	</section>

	<section xml:id="components.progressindicator">
		<title><classname>ProgressIndicator</classname></title>

		<para>
			The <classname>ProgressIndicator</classname> component allows displaying the
			progress of a task graphically. The progress is given as a floating-point
			value between 0.0 and 1.0.
		</para>

		<figure>
			<title>The Progress Indicator Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="140" align="center" fileref="img/components/progressindicator-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The progress indicator polls the server for updates for its value. If the
			value has changed, the progress is updated. Notice that the user application
			does not have to handle any polling event, but updating the component is done
			automatically.
		</para>

		<para>
			Creating a progress indicator is just like with any other component. You
			can give the initial progress value as a parameter for the constructor. The default
			polling frequency is 1000 milliseconds (one second), but you can set some
			other interval with the <methodname>setPollingInterval()</methodname> method.
		</para>

		<programlisting><![CDATA[// Create the indicator
final ProgressIndicator indicator =
        new ProgressIndicator(new Float(0.0));
main.addComponent(indicator);

// Set polling frequency to 0.5 seconds.
indicator.setPollingInterval(500);]]></programlisting>

		<simplesect>
			<title>CSS Style Rules</title>
				
			<programlisting><![CDATA[/* Base element. */
.v-progressindicator {}

/* Progress indication element on top of the base. */
.v-progressindicator div {}]]></programlisting>

			<para>
				The default style for the progress indicator uses an animated GIF image
				(<filename>img/base.gif</filename>) as the base background for the
				component. The progress is a <literal>&lt;div&gt;</literal> element inside
				the base. When the progress element grows, it covers more and more of the
				base background. By default, the graphic of the progress element is
				defined in <filename>img/progress.png</filename> under the default style
				directory. See
				<filename>com.vaadin.terminal.gwt/public/default/progressindicator/progressindicator.css</filename>.
			</para>
		</simplesect>

		<section>
			<title>Doing Heavy Computation</title>

			<para>
				The progress indicator is often used to display the progress of a heavy
				server-side computation task. In the following example, we create a thread
				in the server to do some "heavy work". All the thread needs to do is to
				set the value of the progress indicator with
				<methodname>setValue()</methodname> and the current progress is displayed
				automatically when the browser polls the server.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Create an indicator that makes you look busy
final ProgressIndicator indicator =
        new ProgressIndicator(new Float(0.0));
main.addComponent(indicator);

// Set polling frequency to 0.5 seconds.
indicator.setPollingInterval(500);

// Add a button to start working
final Button button = new Button("Click to start");
main.addComponent(button);

// Another thread to do some work
class WorkThread extends Thread {
    public void run () {
        double current = 0.0;
        while (true) {
            // Do some "heavy work"
            try {
                sleep(50); // Sleep for 50 milliseconds
            } catch (InterruptedException) {}
            
            // Show that you have made some progress:
            // grow the progress value until it reaches 1.0.
            current += 0.01;
            if (current>1.0)
                indicator.setValue(new Float(1.0));
            else 
                indicator.setValue(new Float(current));
            
            // After all the "work" has been done for a while,
            // take a break.
            if (current > 1.2) {
                // Restore the state to initial.
                indicator.setValue(new Float(0.0));
                button.setVisible(true);
                break;
            }
        }
    }
}

// Clicking the button creates and runs a work thread
button.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        final WorkThread thread = new WorkThread();
        thread.start();
        
        // The button hides until the work is done.
        button.setVisible(false);
    }
});]]></programlisting>

			<figure>
				<title>Starting Heavy Work</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="140" align="center" fileref="img/components/progressindicator-example2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

	<section xml:id="components.slider">
		<title><classname>Slider</classname></title>

        <para>
            The <classname>Slider</classname> is a vertical or horizontal bar that allows
            setting a numeric value within a defined range by dragging a bar handle with
            the mouse. The value is shown when dragging the handle.
        </para>

        <para>
            <classname>Slider</classname> has a number of different constructors that take
            a combination of the caption, <emphasis>minimum</emphasis> and
            <emphasis>maximum</emphasis> value, <emphasis>resolution</emphasis>, and the
            <emphasis>orientation</emphasis> of the slider.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create a vertical slider
final Slider vertslider = new Slider(1, 100);
vertslider.setOrientation(SliderOrientation.VERTICAL);]]></programlisting>

        <variablelist>
            <title>Slider Properties</title>
            <varlistentry>
                <term><emphasis>min</emphasis></term>
                <listitem>
                    <para>
                        Minimum value of the slider range. The default is 0.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>max</emphasis></term>
                <listitem>
                    <para>
                        Maximum value of the slider range. The default is 100.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>resolution</emphasis></term>
                <listitem>
                    <para>
                        The number of digits after the decimal point. The default is 0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>orientation</emphasis></term>
                <listitem>
                    <para>
                        The orientation can be either horizontal
                        (<parameter>SliderOrientation.HORIZONTAL</parameter>) or vertical
                        (<parameter>SliderOrientation.VERTICAL</parameter>). The default
                        is horizontal.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para>
            As the <classname>Slider</classname> is a field component, you can handle
            value changes with a <classname>ValueChangeListener</classname>. The value of
            the <classname>Slider</classname> field is a <classname>Double</classname>
            object.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Shows the value of the vertical slider
final Label vertvalue = new Label();
vertvalue.setSizeUndefined();

// Handle changes in slider value.
vertslider.addValueChangeListener(
    new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        double value = (Double) vertslider.getValue();

        // Use the value
        box.setHeight((float) value, Sizeable.UNITS_PERCENTAGE);
        vertvalue.setValue(String.valueOf(value));
    }
});

// The slider has to be immediate to send the changes
// immediately after the user drags the handle.
vertslider.setImmediate(true);]]></programlisting>

        <para>
            You can set the value with the <methodname>setValue()</methodname> method
            defined in <classname>Slider</classname> that takes the value as a native
            double value. The setter can throw a
            <classname>ValueOutOfBoundsException</classname>, which you must handle.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Set the initial value. This has to be set after the
// listener is added if we want the listener to handle
// also this value change.
try {
	vertslider.setValue(50.0);
} catch (ValueOutOfBoundsException e) {
}]]></programlisting>

        <para>
            Alternatively, you can use the regular
            <methodname>setValue(Object)</methodname>, which does not do bounds checking.
        </para>

        <para>
            <xref linkend="figure.components.slider.example1"/> shows both vertical (from
            the code examples) and horizontal sliders that control the size of a box. The
            slider values are displayed also in separate labels.
        </para>

        <figure xml:id="figure.components.slider.example1">
            <title>The <classname>Slider</classname> Component</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/slider-example1-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="70%" align="center" fileref="img/components/slider-example1-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <simplesect>
            <title>CSS Style Rules</title>

            <programlisting><![CDATA[.v-slider {}
.v-slider-base {}
.v-slider-handle {}]]></programlisting>

            <para>
                The enclosing style for the <classname>Slider</classname> is
                <literal>v-slider</literal>. The slider bar has style
                <literal>v-slider-base</literal>. Even though the handle is higher (for
                horizontal slider) or wider (for vertical slider) than the bar, the handle
                element is nevertheless contained within the slider bar element. The
                appearance of the handle comes from a background image defined in the
                <emphasis>background</emphasis> CSS property.
            </para>
        </simplesect>  
    </section>

    <section xml:id="components.calendar">
        <title><classname>Calendar</classname></title>

        <para>
            The <classname>Calendar</classname> component allows organizing and displaying
            calendar events. The main features of the calendar include:
        </para>

        <itemizedlist>
            <listitem>
                Monthly, weekly, and daily views
            </listitem>
            <listitem>
                Two types of events: all-day events and events with a time range
            </listitem>
            <listitem>
                Add events directly, from a <classname>Container</classname>, or with an event provider
            </listitem>
            <listitem>
                Control the range of the visible dates
            </listitem>
            <listitem>
                Selecting and editing date or time range by dragging
            </listitem>
            <listitem>
                Drag and drop events to calendar
            </listitem>
            <listitem>
                Support for localization and timezones
            </listitem>
        </itemizedlist>

        <para>
            User interaction with the calendar elements, such as date and week captions as
            well as events, is handled with event listeners. Also date/time range
            selections, event dragging, and event resizing can be listened by the
            server. The weekly view has navigation buttons to navigate forward and
            backward in time. These actions are also listened by the server. Custom
            navigation can be implemented using event handlers<phrase condition="web">, as
            described in <xref linkend="components.calendar.customizing"/></phrase>.
        </para>

        <para>
            The data source of a calendar can be practically anything, as its events are
            queried dynamically by the component. You can bind the calendar to a Vaadin
            container, or to any other data source by implementing an <emphasis>event
            provider</emphasis>.
        </para>

        <para>
            The <classname>Calendar</classname> has undefined size by default and you
            usually want to give it a fixed or relative size, for example as follows.
        </para>

        <programlisting><![CDATA[Calendar cal = new Calendar("My Calendar");
cal.setWidth("600px");
cal.setHeight("300px");]]></programlisting>

        <para>
            After creating the calendar, you need to set a time range for it, which also
            controls the view mode, and set up the data source for calendar events.
        </para>

        <section xml:id="components.calendar.daterange">
            <title>Date Range and View Mode</title>

            <para>
                The Vaadin Calendar has two types of views that are shown depending on the
                date range of the calendar. The <emphasis>weekly view</emphasis> displays
                a week by default. It can show anything between one to seven days a week,
                and is also used as a single-day view. The view mode is determined from
                the <emphasis>date range</emphasis> of the calendar, defined by a start
                and an end date. Calendar will be shown in a <emphasis>monthly
                view</emphasis> when the date range is over than one week (seven days)
                long. The date range is always calculated in an accuracy of one
                millisecond.
            </para>

            <figure xml:id="figure.components.calendar.daterange.monthly" float="center" floatstyle="before">
                <title>Monthly view with All-Day and Normal Events</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/addons/calendar-monthly.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/addons/calendar-monthly.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The monthly view, shown in <xref
                linkend="figure.components.calendar.daterange.monthly"/>, can easily be
                used to control all types of events, but it is best suited for events that
                last for one or more days. You can drag the events to move them. In the
                figure, you can see two longer events that are highlighted with a blue and
                green background color. Other markings are shorter day events that last
                less than a 24 hours. These events can not be moved by dragging in the
                monthly view.
            </para>

            <figure xml:id="figure.components.calendar.daterange.weekly" float="center" floatstyle="before">
                <title>Weekly View</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/addons/calendar-weekly.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/addons/calendar-weekly.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                In <xref linkend="figure.components.calendar.daterange.weekly"/>, you can
                see four normal day events and also all-day events at the top of the time
                line grid.
            </para>

            <para>
                In the following, we set the calendar to show only one day, which is
                the current day.
            </para>

            <programlisting><![CDATA[cal.setStartDate(new Date());
cal.setEndDate(new Date());]]></programlisting>

            <para>
                Notice that although the range we set above is actually zero time long,
                the calendar still renders the time from 00:00 to 23:59. This is normal,
                as the Vaadin Calendar is guaranteed to render at least the date range
                provided, but may expand it. This behaviour is important to notice when we
                implement our own event providers.
            </para>
        </section>

        <section xml:id="components.calendar.events">
            <title>Calendar Events</title>

            <para>
                All occurrences in a calendar are represented as
                <emphasis>events</emphasis>. You have three ways to manage the calendar
                events:
            </para>

            <itemizedlist>
                <listitem>
                    Add events directly to the <classname>Calendar</classname> object using
                    the <methodname>addEvent()</methodname>
                </listitem>
            
                <listitem>
                    Use a <interfacename>Container</interfacename> as a data source
                </listitem>
            
                <listitem>
                    Use the <emphasis>event provider</emphasis> mechanism
                </listitem>
            </itemizedlist>

            <para>
                You can add events with <methodname>addEvent()</methodname> and remove
                them with the <methodname>removeEvent()</methodname>. These methods will
                use the underlying event provider to write the modifications to the data
                source.
            </para>

            <section xml:id="components.calendar.events.types">
                <title>Event Interfaces and Providers</title>

                <para>
                    Events are handled though the
                    <interfacename>CalendarEvent</interfacename> interface. The concrete
                    class of the event depends on the specific
                    <classname>CalendarEventProvider</classname> used in the calendar.
                </para>

                <para>
                    By default, <classname>Calendar</classname> uses a
                    <classname>BasicEventProvider</classname> to provide events, which
                    uses <classname>BasicEvent</classname> instances.
                </para>

                <para>
                    Calendar does not depend on any particular data source
                    implementation. Events are queried by the
                    <classname>Calendar</classname> from the provider that just has to
                    implement the <interfacename>CalendarEventProvider</interfacename>
                    interface. It is up to the event provider that
                    <classname>Calendar</classname> gets the correct events.
                </para>

                <para>
                    You can bind any Vaadin <classname>Container</classname> to a
                    calendar, in which case a
                    <classname>ContainerEventProvider</classname> is used
                    transparently. The container must be ordered by start date and time of
                    the events. See <xref linkend="datamodel.container"/> for basic
                    information about containers.
                </para>
            </section>

            <section xml:id="components.calendar.events.details">
                <title>Event Types</title>

                <para>
                    A calendar event requires a start time and an end time. These are the
                    only mandatory properties. In addition, an event can also be set as an
                    all-day event by setting the <literal>all-day</literal> property of
                    the event. You can also set the <literal>description</literal> of an
                    event, which is displayed as a tooltip in the user interface.
                </para>

                <para>
                    If the <literal>all-day</literal> field of the event is
                    <literal>true</literal>, then the event is always rendered as an
                    all-day event. In the monthly view, this means that no start time is
                    displayed in the user interface and the event has an colored
                    background. In the weekly view, all-day events are displayed in the
                    upper part of the screen, and rendered similarly to the monthly
                    view. In addition, when the time range of an event is 24 hours or
                    longer, it is rendered as an all-day event in the monthly view.
                </para>

                <para>
                    When the time range of an event is equal or less than 24 hours, with
                    the accuracy of one millisecond, the event is considered as a normal
                    day event. Normal event has a start and end times that may be on
                    different days.
                </para>
            </section>

            <section xml:id="components.calendar.events.basic">
                <title>Basic Events</title>

                <para>
                    The easiest way to add and manage events in a calendar is to use the
                    <emphasis>basic event</emphasis> management API.  Calendar uses by
                    default a <classname>BasicEventProvider</classname>, which keeps the
                    events in memory in an internal reprensetation.
                </para>

                <para>
                    For example, the following adds a two-hour event starting from the
                    current time. The standard Java
                    <classname>GregorianCalendar</classname> provides various ways to
                    manipulate date and time.
                </para>

                <book-example id="calendar.monthlyview" style="float: right"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[// Add a two-hour event
GregorianCalendar start = new GregorianCalendar();
GregorianCalendar end   = new GregorianCalendar();
end.add(java.util.Calendar.HOUR, 2);
calendar.addEvent(new BasicEvent("Calendar study",
        "Learning how to use Vaadin Calendar",
        start.getTime(), end.getTime()));]]></programlisting>


                <para>
                    This adds a new event that lasts for 3 hours. As the BasicEventProvider
                    and BasicEvent implement some optional event interfaces provided by the
                    calendar package, there is no need to refresh the calendar. Just create
                    events, set their properties and add them to the Event Provider.
                </para>
            </section>
        </section>

        <section xml:id="components.calendar.container">
            <title>Getting Events from a Container</title>

            <para>
                You can use any Vaadin <interfacename>Container</interfacename> that
                implements the <interfacename>Indexed</interfacename> interface as the
                data source for calendar events. The <classname>Calendar</classname> will
                listen to change events from the container as well as write changes to the
                container. You can attach a container to a <classname>Calendar</classname>
                with <methodname>setContainerDataSource()</methodname>.
            </para>

            <para>
                In the following example, we bind a
                <classname>BeanItemContainer</classname> that contains built-in
                <classname>BasicEvent</classname> events to a calendar.
            </para>

            <book-example id="calendar.beanitemcontainer" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// Create the calendar
Calendar calendar = new Calendar("Bound Calendar");

// Use a container of built-in BasicEvents
final BeanItemContainer<BasicEvent> container =
    new BeanItemContainer<BasicEvent>(BasicEvent.class);        

// Create a meeting in the container
container.addBean(new BasicEvent("The Event", "Single Event",
            new GregorianCalendar(2012,1,14,12,00).getTime(),
            new GregorianCalendar(2012,1,14,14,00).getTime()));

// The container must be ordered by the start time. You
// have to sort the BIC every time after you have added
// or modified events.
container.sort(new Object[]{"start"}, new boolean[]{true});

calendar.setContainerDataSource(container, "caption",
    "description", "start", "end", "styleName");]]></programlisting>

            <para>
                The container must either use the default property IDs for event data, as
                defined in the <interfacename>CalendarEvent</interfacename> interface, or
                provide them as parameters for the
                <methodname>setContainerDataSource()</methodname> method, as we did in the
                example above.
            </para>

            <section xml:id="components.calendar.container.sorting">
                <title>Keeping the Container Ordered</title>

                <para>
                    The events in the container <emphasis>must</emphasis> be kept ordered
                    by their start date/time.  Failing to do so may and will result in the
                    events not showing in the calendar properly.
                </para>

                <para>
                    Ordering depends on the container. With some containers, such as
                    <classname>BeanItemContainer</classname>, you have to sort the
                    container explicitly every time after you have added or modified
                    events, usually with the <methodname>sort()</methodname> method, as we
                    did in the example above. Some container, such as
                    <classname>JPAContainer</classname>, keep the in container
                    automatically order if you provide a sorting rule.
                </para>

                <para>
                    For example, you could order a <classname>JPAContainer</classname> by
                    the following rule, assuming that the start date/time is held in the
                    <literal>startDate</literal> property:
                </para>

                <book-example id="calendar.jpacontainer" style="float: right"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[// The container must be ordered by start date. For JPAContainer
// we can just set up sorting once and it will stay ordered.
container.sort(new String[]{"startDate"}, new boolean[]{true});]]></programlisting>

            </section>

            <section xml:id="components.calendar.container.customization" condition="web">
                <title>Delegation of Event Management</title>

                <para>
                    Setting a container as the calendar data source with
                    <methodname>setContainerDataSource()</methodname> automatically switches
                    to <classname>ContainerEventProvider</classname>. You can manipulate the
                    event data through the API in <classname>Calendar</classname> and the user
                    can move and resize event through the user interface. The event provider
                    delegates all such calendar operations to the container.
                </para>

                <para>
                    If you add events through the <classname>Calendar</classname> API,
                    notice that you may be unable to create events of the type held in the
                    container or adding them requires some container-specific
                    operations. In such case, you may need to customize the
                    <methodname>addEvent()</methodname> method.
                </para>

                <para>
                    For example, <classname>JPAContainer</classname> requires adding new
                    items with <methodname>addEntity()</methodname>. You could first add
                    the entity to the container or entity manager directly and then pass
                    it to the <methodname>addEvent()</methodname>. That does not, however,
                    work if the entity class does not implement
                    <interfacename>CalendarEvent</interfacename>. This is actually the
                    case always if the property names differ from the ones defined in the
                    interface. You could handle creating the underlying entity objects in
                    the <methodname>addEvent()</methodname> as follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a JPAContainer
final JPAContainer<MyCalendarEvent> container =
    JPAContainerFactory.make(MyCalendarEvent.class,
                             "book-examples");

// Customize the event provider for adding events
// as entities
ContainerEventProvider cep =
        new ContainerEventProvider(container) {
    @Override
    public void addEvent(CalendarEvent event) {
        MyCalendarEvent entity = new MyCalendarEvent(
            event.getCaption(), event.getDescription(),
            event.getStart(), event.getEnd(),
            event.getStyleName());
        container.addEntity(entity);
    }
}

// Set the container as the data source
calendar.setEventProvider(cep);
        
// Now we can add events to the database through the calendar
BasicEvent event = new BasicEvent("The Event", "Single Event",
    new GregorianCalendar(2012,1,15,12,00).getTime(),
    new GregorianCalendar(2012,1,15,14,00).getTime());
calendar.addEvent(event);]]></programlisting>
            </section>
        </section>

        <section xml:id="components.calendar.eventprovider" condition="web">
            <title>Implementing an Event Provider</title>

            <para>
                If the two simple ways of storing and managing events for a calendar are
                not enough, you may need to implement a custom event provider. It is the
                most flexible way of providing events. You need to attach the event
                provider to the <classname>Calendar</classname> using the
                <methodname>setEventProvider()</methodname> method.
            </para>

            <para>
                Event queries are done by asking the event provider for all the events
                between two given dates. The range of these dates is guaranteed to be at
                least as long as the start and end dates set for the component. The
                component can, however, ask for a longer range to ensure correct
                rendering. In particular, all start dates are expanded to the start of the
                day, and all end dates are expanded to the end of the day.
            </para>

            <section xml:id="components.calendar.eventprovider.customevents">
                <title>Custom Events</title>
            
                <para>
                    An event provider could use the built-in
                    <classname>BasicEvent</classname>, but it is usually more proper to define
                    a custom event type that is bound directly to the data source. Custom
                    events may be useful for some other purposes as well, such as when you
                    need to add extra information to an event or customize how it is acquired.
                </para>

                <para>
                    Custom events must implement the <interfacename>CalendarEvent</interfacename>
                    interface or extend an existing event class. The built-in
                    <classname>BasicEvent</classname> class should serve as a good example of
                    implementing simple events. It keeps the data in member variables.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class BasicEvent
       implements CalendarEventEditor, EventChangeNotifier {
   ...

   public String getCaption() {
        return caption;
    }

    public String getDescription() {
        return description;
    }

    public Date getEnd() {
        return end;
    }

    public Date getStart() {
        return start;
    }

    public String getStyleName() {
        return styleName;
    }

    public boolean isAllDay() {
        return isAllDay;
    }

    public void setCaption(String caption) {
        this.caption = caption;
        fireEventChange();
    }

    public void setDescription(String description) {
        this.description = description;
        fireEventChange();
    }

    public void setEnd(Date end) {
        this.end = end;
        fireEventChange();
    }

    public void setStart(Date start) {
        this.start = start;
        fireEventChange();
    }

    public void setStyleName(String styleName) {
        this.styleName = styleName;
        fireEventChange();
    }

    public void setAllDay(boolean isAllDay) {
        this.isAllDay = isAllDay;
        fireEventChange();
    }

    public void addListener(EventChangeListener listener) {
        ...
    }
    
    public void removeListener(EventChangeListener listener) {
        ...
    }

    protected void fireEventChange() {...}
}]]></programlisting>

                <para>
                    You may have noticed that there was some additional code in the
                    <classname>BasicEvent</classname> that was not in the
                    <interfacename>CalendarEvent</interfacename> interface. Namely
                    <classname>BasicEvent</classname> also implements two additional
                    interfaces:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><interfacename>CalendarEditor</interfacename></term>
                        <listitem>
                            <para>
                                This interface defines setters for all the fields, and is
                                required for some of the default handlers to work.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><interfacename>EventChangeNotifier</interfacename></term>
                        <listitem>
                            <para>
                                This interface adds the possibility to listen for changes in
                                the event, and enables the <classname>Calendar</classname> to
                                render the changes immediately.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                
                <para>
                    The start time and end time are mandatory, but caption, description,
                    and style name are not. The style name is used as a part of the CSS
                    class name for the HTML DOM element of the event.
                </para>

                <para>
                    In addition to the basic event interfaces, you can enhance the
                    functionality of your event and event provider classes by using the
                    <classname>EventChange</classname> and
                    <classname>EventSetChange</classname> events. They let the
                    <classname>Calendar</classname> component to know about changes in
                    events and update itself accordingly. The
                    <classname>BasicEvent</classname> and
                    <classname>BasicEventProvider</classname> examples given earlier
                    include a simple implementation of these interfaces.
                </para>
            </section>

            <section xml:id="components.calendar.eventprovider.eventprovider">
                <title>Implementing the Event Provider</title>

                <para>
                    An event provider needs to implement the
                    <interfacename>CalendarEventProvider</interfacename> interface. It has
                    only one method to be implemented. Whenever the calendar is painted,
                    <methodname>getEvents(Date, Date)</methodname> method is called and it
                    must return a list of events between the given start and end time.
                </para>

                <para>
                    The following example implementation returns only one example
                    event. The event starts from the current time and is five hours long.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class MyEventProvider implements CalendarEventProvider{
    public List<Event> getEvents(Date startDate, Date endDate){
        List<Event> events = new ArrayList<Event>();
        GregorianCalendar cal = new GregorianCalendar();
        cal.setTime(new Date());

        Date start = cal.getTime();
        cal.add(GregorianCalendar.HOUR, 5);
        Date end = cal.getTime();
        BasicEvent event = new BasicEvent();
        event.setCaption("My Event");
        event.setDescription("My Event Description");
        event.setStart(start);
        event.setEnd(end);
        events.add(event);

        return events;
    }
}]]></programlisting>

                <para>
                    It is important to notice that the <classname>Calendar</classname> may
                    query for dates beyond the range defined by start date and end
                    date. Particularly, it may expand the date range to make sure the user
                    interface is rendered correctly.
                </para>
            </section>
        </section>

        <section xml:id="components.calendar.appearance" condition="web">
            <title>Styling a Calendar</title>

            <para>
                Configuring the appearance of the Vaadin Calendar component is one of the
                basic tasks. At the least, you need to consider its sizing in your user
                interface. You also quite probably want to use some color or colors for
                events.
            </para>

            <section xml:id="components.calendar.appearance.sizing">
                <title>Sizing</title>

                <para>
                    The Calendar supports component sizing as usual for defined (fixed or
                    relative) sizes. When using an undefined size for the calendar, all
                    the sizes come from CSS. In addition, when the height is undefined, a
                    scrollbar is displayed in the weekly view to better fit the cells to
                    the user interface.
                </para>

                <para>
                    Below is a list of style rules that define the size of a Calendar with
                    undefined size (these are the defaults):
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.v-calendar-month-sizedheight .v-calendar-month-day {
	height: 100px;
}

.v-calendar-month-sizedwidth .v-calendar-month-day {
	width: 100px;
}

.v-calendar-header-month-Hsized .v-calendar-header-day {
	width: 101px;
}

/* for IE */
.v-ie6 .v-calendar-header-month-Hsized .v-calendar-header-day {
	width: 104px;
}

/* for others */
.v-calendar-header-month-Hsized td:first-child {
	padding-left: 21px;
}

.v-calendar-header-day-Hsized {
	width: 200px;
}

.v-calendar-week-numbers-Vsized .v-calendar-week-number {
	height: 100px;
	line-height: 100px;
}

.v-calendar-week-wrapper-Vsized {
	height: 400px;
	overflow-x: hidden !important;
}

.v-calendar-times-Vsized .v-calendar-time {
	height: 38px;
}

.v-calendar-times-Hsized .v-calendar-time {
	width: 42px;
}

.v-calendar-day-times-Vsized .v-slot,.v-calendar-day-times-Vsized .v-slot-even {
	height: 18px;
}

.v-calendar-day-times-Hsized, .v-calendar-day-times-Hsized .v-slot,.v-calendar-day-times-Hsized .v-slot-even {
	width: 200px;
}]]></programlisting>
            </section>

            <section xml:id="components.calendar.appearance.event-style">
                <title>Event Style</title>

                <para>
                    Events can be styled with CSS by setting them a <emphasis>style name
                    suffix</emphasis>. The suffix is retrieved with the
                    <methodname>getStyleName()</methodname> method in
                    <interfacename>CalendarEvent</interfacename>. If you use
                    <classname>BasicEvent</classname> events, you can set the suffix with
                    <methodname>setStyleName()</methodname>.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[BasicEvent event = new BasicEvent("Wednesday Wonder", ... );
event.setStyleName("mycolor");
calendar.addEvent(event);]]></programlisting>

                <para>
                    Suffix <literal>mycolor</literal> would create
                    <literal>v-calendar-event-mycolor</literal> class for regular events
                    and <literal>v-calendar-event-mycolor-add-day</literal> for all-day
                    events. You could style the events with the following rules:
                </para>

                <programlisting><?pocket-size 65% ?>.v-calendar .v-calendar-event-mycolor {}
.v-calendar .v-calendar-event-mycolor-all-day {}
.v-calendar .v-calendar-event-mycolor .v-calendar-event-caption {}
.v-calendar .v-calendar-event-mycolor .v-calendar-event-content {}</programlisting>

            </section>
        </section>

        <section xml:id="components.calendar.visible-hours-days" condition="web">
            <title>Visible Hours and Days</title>

            <para>
                As we saw in <xref linkend="calendar.using.daterange"/>, you can set the
                range of dates that are shown by the Calendar. But what if you wanted to
                show the entire month but hide the weekends? Or show only hours from 8 to
                16 in the weekly view? The <methodname>setVisibleDays()</methodname> and
                <methodname>setVisibleHours()</methodname> methods allow you to do that.
            </para>

            <programlisting><?pocket-size 75% ?>calendar.setVisibleDays(1,5);   // Monday to Friday
calendar.setVisibleHours(0,15); // Midnight until 4 pm</programlisting>

            <para>
                After the above settings, only weekdays from Monday to Friday would be
                shown. And when the calendar is in the weekly view, only the time range
                from 00:00 to 16:00 would be shown.
            </para>

            <para>
                Note that the excluded times are never shown so you should take care when
                setting the date range. If the date range contains only dates / times that
                are excluded, nothing will be displayed. Also note that even if a date is
                not rendered because these settings, the event provider may still be
                queried for events for that date.
            </para>
        </section>

        <section xml:id="components.calendar.drag-and-drop" condition="web">
            <title>Drag and Drop</title>

            <para>
                Vaadin Calendar can act as a drop target for drag and drop, described in
                <xref linkend="advanced.dragndrop"/>. With the functionality, the user
                could drag events, for example, from a table to a calendar.
            </para>

            <para>
                To support dropping, a <classname>Calendar</classname> must have a drop
                handler. When the drop handler is set, the days in the monthly view and
                the time slots in the weekly view can receive drops. Other locations, such
                as day names in the weekly view, can not currently receive drops.
            </para>

            <para>
                Calendar uses its own implementation of
                <interfacename>TargetDetails</interfacename>:
                <classname>CalendarTargetdetails</classname>. It holds information about
                the the drop location, which in the context of
                <classname>Calendar</classname> means the date and time. The drop target
                location can be retrieved via the <methodname>getDropTime()</methodname>
                method. If the drop is done in the monthly view, the returned date does
                not have exact time information. If the drop happened in the weekly view,
                the returned date also contains the start time of the slot.
            </para>

            <para>
                Below is a short example of creating a drop handler and using the drop
                information to create a new event:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[private Calendar createDDCalendar() {
  Calendar calendar = new Calendar();
  calendar.setDropHandler(new DropHandler() {
    public void drop(DragAndDropEvent event) {
      CalendarTargetDetails details = 
              (CalendarTargetDetails) event.getTargetDetails();
      
      TableTransferable transferable = 
              (TableTransferable) event.getTransferable();

      createEvent(details, transferable);
      removeTableRow(transferable);
    }

    public AcceptCriterion getAcceptCriterion() {
      return AcceptAll.get();
    }

  });

  return calendar;
}


protected void createEvent(CalendarTargetDetails details,
  TableTransferable transferable) {
  Date dropTime = details.getDropTime();
  java.util.Calendar timeCalendar = details.getTargetCalendar()
                                    .getInternalCalendar();
  timeCalendar.setTime(dropTime);
  timeCalendar.add(java.util.Calendar.MINUTE, 120);
  Date endTime = timeCalendar.getTime();

  Item draggedItem = transferable.getSourceComponent().
                            getItem(transferable.getItemId());

  String eventType = (String)draggedItem.
                            getItemProperty("type").getValue();

  String eventDescription = "Attending: "
             + getParticipantString(
                 (String[]) draggedItem.
                   getItemProperty("participants").getValue());

  BasicEvent newEvent = new BasicEvent();
  newEvent.setAllDay(!details.hasDropTime());
  newEvent.setCaption(eventType);
  newEvent.setDescription(eventDescription);
  newEvent.setStart(dropTime);
  newEvent.setEnd(endTime);

  BasicEventProvider ep = (BasicEventProvider) details
                       .getTargetCalendar().getEventProvider();
  ep.addEvent(newEvent);
}]]></programlisting>
        </section>

        <section xml:id="components.calendar.contextmenu" condition="web">
            <title>Using the Context Menu</title>
            
            <para>
                Vaadin Calendar allows the use of context menu (mouse right-click) to
                manage events. As in other context menus in Vaadin, the menu items are
                handled in Vaadin as <emphasis>actions</emphasis> by an <emphasis>action
                handler</emphasis>. To enable a context menu, you have to implement a
                Vaadin <interfacename>Action.Handler</interfacename> and add it to the
                calendar with <methodname>addActionHandler()</methodname>.
            </para>

            <para>
                An action handler must implement two methods:
                <methodname>getActions()</methodname> and
                <methodname>handleAction()</methodname>. The
                <methodname>getActions()</methodname> is called for each day displayed in
                the calendar view. It should return a list of allowed actions for that
                day, that is, the items of the context menu. The
                <parameter>target</parameter> parameter is the context of the click - a
                <classname>CalendarDateRange</classname> that spans over the day. The
                <parameter>sender</parameter> is the <classname>Calendar</classname>
                object.
            </para>

            <para>
                The <methodname>handleActions()</methodname> receives the target context in
                the <parameter>target</parameter>. If the context menu was opened on an event,
                the target is the <interfacename>Event</interfacename> object, otherwise it is
                a <classname>CalendarDateRange</classname>.
            </para>
        </section>

        <section xml:id="components.calendar.localization" condition="web">
            <title>Localization and Formatting</title>

            <section xml:id="components.calendar.localization.locale">
                <title>Setting the Locale and Time Zone</title>

                <para>
                    Month and weekday names are shown in the language of the locale
                    setting of the <classname>Calendar</classname>. The translations are
                    acquired from the standard Java locale data. By default,
                    <classname>Calendar</classname> uses the system default locale for its
                    internal calendar, but you can change it with
                    <methodname>setLocale(Locale locale)</methodname>. Setting the locale
                    will update also other location specific date and time settings, such
                    as the first day of the week, time zone, and time format. However,
                    time zone and time format can be overridden by settings in the
                    <classname>Calendar</classname>.
                </para>

                <para>
                    For example, the following would set the language to US English:
                </para>

                <programlisting><![CDATA[cal.setLocale(Locale.US);]]></programlisting>

                <para>
                    The locale defines the default time zone. You can change it with the
                    <methodname>setTimeZone()</methodname> method, which takes a
                    <classname>java.util.TimeZone</classname> object as its parameter. Setting
                    timezone to null will reset timezone to the locale default.
                </para>

                <para>
                    For example, the following would set the Finnish time zone, which is EET
                </para>

                <programlisting><![CDATA[cal.setTimeZone(TimeZone.getTimeZone("Europe/Helsinki"));]]></programlisting>
            </section>

            <section xml:id="components.calendar.localization.datecaption">
                <title>Time and Date Caption Format</title>

                <para>
                    The time may be shown either in 24 or 12 hour format. The default
                    format is defined by the locale, but you can change it with the
                    <methodname>setTimeFormat()</methodname> method. Giving a
                    <literal>null</literal> setting will reset the time format to the
                    locale default.
                </para>

                <programlisting><![CDATA[cal.setTimeFormat(TimeFormat.Format12H);]]></programlisting>

                <para>
                    You can change the format of the date captions in the week view with
                    the <methodname>setWeeklyCaptionFormat(String
                    dateFormatPattern)</methodname> method. The date format pattern should
                    follow the format of the standard Java
                    <classname>java.text.SimpleDateFormat</classname> class.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><![CDATA[cal.setWeeklyCaptionFormat("dd-MM-yyyy");]]></programlisting>
            </section>
        </section>

        <section xml:id="components.calendar.customizing" condition="web">
            <title>Customizing the Calendar</title>

            <para>
                In this section, we give a tutorial for how to make various basic
                customizations of the Vaadin Calendar. The event provider and styling was
                described earlier, so now we concentrate on other features of the Calendar
                API.
            </para>

            <section xml:id="components.calendar.customizing.overview">
                <title>Overview of Handlers</title>

                <para>
                    Most of the handlers related to calendar events have sensible default
                    handlers. These are found in the
                    <package>com.vaadin.ui.handler</package> package. The default handlers
                    and their functionalities are described below.
                </para>

                <itemizedlist>
                    <listitem>
                        <classname>BasicBackwardHandler</classname>. Handles clicking the
                        back-button of the weekly view so that the viewed month is changed
                        to the previous one.
                    </listitem>

                    <listitem>
                        <classname>BasicForwardHandler</classname>. Handles clicking the
                        forward-button of the weekly view so that the viewed month is
                        changed to the next one.
                    </listitem>

                    <listitem>
                        <classname>BasicWeekClickHandler</classname>. Handles clicking the
                        week numbers int the monthly view so that the viewable date range
                        is changed to the clicked week.
                    </listitem>

                    <listitem>
                        <classname>BasicDateClickHandler</classname>. Handles clicking the
                        dates on both the monthly view and the weekly view. Changes the
                        viewable date range so that only the clicked day is visible.
                    </listitem>

                    <listitem>
                        <classname>BasicEventMoveHandler</classname>. Handles moving the
                        events in both monthly view and the weekly view. Events can be
                        moved and their start and end dates are changed correctly, but
                        only if the event implements
                        <classname>CalendarEventEditor</classname> (implemented by
                        <classname>BasicEvent</classname>).
                    </listitem>

                    <listitem>
                        <classname>BasicEventResizeHandler</classname>. Handles resizing
                        the events in the weekly view. Events can be resized and their
                        start and end dates are changed correctly, but only if the event
                        implements <classname>CalendarEventEditor</classname> (implemented
                        by the <classname>BasicEvent</classname>).
                    </listitem>
                </itemizedlist>

                <para>
                    All of these handlers are automatically set when creating a new
                    <classname>Calendar</classname>. If you wish to disable some of the
                    default functionality, you can simply set the corresponding handler to
                    <literal>null</literal>. This will prevent the functionality from ever
                    appearing on the user interface. For example, if you set the
                    <classname>EventMoveHandler</classname> to <literal>null</literal>, the
                    user will be unable to move events in the browser.
                </para>
            </section>

            <section xml:id="components.calendar.customizing.creating">
                <title>Creating a Calendar</title>

                <para>
                    Let us first create a new <classname>Calendar</classname>
                    instance. Here we use our own event provider, the
                    <classname>MyEventProvider</classname> described in <xref
                    linkend="calendar.eventprovider.eventprovider"/>.
                </para>

                <programlisting><![CDATA[Calendar cal = new Calendar(new MyEventProvider());]]></programlisting>

                <para>
                    This initializes the Calendar. To customize the viewable date range,
                    we must set a start and end date to it.
                </para>

                <para>
                    There is only one visible event in the timeline, starting from the
                    current time. That is what our event provider passes to the
                    client. <!-- TODO See the figure 3. -->
                </para>

                <!-- TODO Figure 3: Weekly view with  a single visible day and one event. -->

                <para>
                    It would be nice to also be able to control the navigation forward and
                    backward. The default navigation is provided by the default handlers,
                    but perhaps we want to restrict the users so they can only navigate
                    dates in the current year. Maybe we also want to pose some other
                    restrictions to the clicking week numbers and dates.
                </para>

                <para>
                    These restrictions and other custom logic can be defined with custom
                    handlers. You can find the handlers in the
                    <package>com.vaadin.addon.calendar.ui.handler</package> package and
                    they can be easily extended. Note that if you don not want to extend
                    the default handlers, you are free to implement your own. The
                    interfaces are described in
                    <interfacename>CalendarComponentEvents</interfacename>.
                </para>
            </section>
        </section>

        <section xml:id="components.calendar.navigation">
            <title>Backward and Forward Navigation</title>

            <para>
                Vaadin Calendar has only limited built-in navigation support. The weekly
                view has navigation buttons in the top left and top right corners. <!--
                TODO See the figure 4. -->
            </para>

            <!-- TODO Figure 4: Backward and forward navigation buttons. -->
            <para>
                You can handle backward and forward navigation with a
                <interfacename>BackwardListener</interfacename> and
                <interfacename>ForwardListener</interfacename>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicBackwardHandler() {
  protected void setDates(BackwardEvent event,
                          Date start, Date end) {

      java.util.Calendar calendar = event.getComponent()
                                    .getInternalCalendar();
      if (isThisYear(calendar, end) 
           && isThisYear(calendar, start)) {
        super.setDates(event, start, end);
      }
  }});]]></programlisting>

            <para>
                The forward navigation handler can be implemented in the same way. The
                example handler restricts the dates to the current year.
            </para>
        </section>

        <section xml:id="components.calendar.dateclick" condition="web">
            <title>Date Click Handling</title>

            <para>
                By default, clicking a date either in month or week view switches to
                single-day view. The date click event is handled by a
                <interfacename>DateClickHandler</interfacename>.
            </para>

            <para>
                The following example handles click events so that when the user clicks
                the date header in the weekly view, it will switch to single-day view, and
                in the single-day view switch back to the weekly view.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicDateClickHandler() {
  public void dateClick(DateClickEvent event) {
    Calendar cal = event.getComponent();
    long currentCalDateRange = cal.getEndDate().getTime()
                               - cal.getStartDate().getTime();
    
    if (currentCalDateRange < VCalendar.DAYINMILLIS) {
      // Change the date range to the current week
      cal.setStartDate(cal.getFirstDateForWeek(event.getDate()));
      cal.setEndDate(cal.getLastDateForWeek(event.getDate()));

    } else {
      // Default behaviour, change date range to one day
      super.dateClick(event);
    }
  }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.weekclick" condition="web">
            <title>Handling Week Clicks</title>

            <para>
                The monthly view displays week numbers for each week row on the left side
                of the date grid. The week number are clickable and you can handle the
                click events by setting a <interfacename>WeekClickHandler</interfacename>
                for the <classname>Calendar</classname> object. The default handler
                changes the date range to be the clicked week.
            </para>

            <para>
                In the following example, we add a week click handler that changes the
                date range of the calendar to one week only if the start and end dates
                of the week are in the current month.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicWeekClickHandler() {
    protected void setDates(WeekClick event,
                          Date start, Date end) {
        java.util.Calendar calendar = event.getComponent()
                                  .getInternalCalendar();
        if (isThisMonth(calendar, start) 
            && isThisMonth(calendar,  end)) {
            super.setDates(event, start, end);
        }
    }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.eventclick" condition="web">
            <title>Handling Event Clicks</title>

            <para>
                The calendar events in all views are are clickable. There is no
                default handler. Just like the date and week click handlers, event
                click handling is enabled by setting an
                <interfacename>EventClickHandler</interfacename> for the
                <classname>Calendar</classname> object.
            </para>

            <para>
                You can get hold of the clicked event by the
                <methodname>getCalendarEvent()</methodname> method in the
                <classname>EventClick</classname> object passed to the handler, as
                shown in the following example.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.addListener(new EventClickListener() {
    public void eventClick(EventClick event) {
        BasicEvent e = (BasicEvent) event.getCalendarEvent();

        // Do something with it
        new Notification("Event clicked: " + e.getCaption(),
            e.getDescription()).show(Page.getCurrent());
    }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.eventdrag" condition="web">
            <title>Event Dragging</title>

            <para>
                The user can drag an event to change its position in time. The default
                handler sets the start and end time of the event accordingly. You can do
                many things with a custom move handler, such as restrict moving events.
            </para>

            <para>
                In the following example, we add a
                <interfacename>EventMoveHandler</interfacename> to a
                <classname>Calendar</classname>. The event handler updates the new
                position to the datasource, but only if the new dates are in the current
                month. This requires making some changes to the event provider class.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicEventMoveHandler() {
  private java.util.Calendar javaCalendar;

  public void eventMove(MoveEvent event) {
    javaCalendar = event.getComponent().getInternalCalendar();
    super.eventMove(event);
  }
  
  protected void setDates(CalendarEventEditor event,
                          Date start, Date end) {
    if (isThisMonth(javaCalendar, start)
        && isThisMonth(javaCalendar, end)) {
      super.setDates(event, start, end);
    }
  }
});]]></programlisting>

            <para>
                For the above example to work, the example event provider presented
                earlier needs to be changed slightly so that it doesn't always create a
                new event when <methodname>getEvents()</methodname> is called.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public static class MyEventProvider
              implements CalendarEventProvider {
  private List<CalendarEvent> events =
        new ArrayList<CalendarEvent>();

  public MyEventProvider() {
    events = new ArrayList<CalendarEvent>();
    GregorianCalendar cal = new GregorianCalendar();
    cal.setTime(new Date());

    Date start = cal.getTime();
    cal.add(GregorianCalendar.HOUR, 5);
    Date end = cal.getTime();
    BasicEvent event = new BasicEvent();
    event.setCaption("My Event");
    event.setDescription("My Event Description");
    event.setStart(start);
    event.setEnd(end);
    events.add(event);
  }

  public void addEvent(CalendarEvent BasicEvent) {
    events.add(BasicEvent);
  }

  public List<CalendarEvent> getEvents(Date startDate, 
                                       Date endDate) {
    return events;
  }
}]]></programlisting>

            <para>
                After these changes, the user can move events around as earlier, but
                dropping an event, the start and end dates are checked by the
                server. Note that as the server-side must move the event in order for it
                to render to the place it was dropped. The server can also reject moves by
                not doing anything when the event is received.
            </para>
        </section>

        <section xml:id="components.calendar.dragselection" condition="web">
            <title>Handling Drag Selection</title>

            <para>
                Drag selection works both in the monthly and weekly views. To listen for
                drag selection, you can add a
                <interfacename>RangeSelectListener</interfacename> to the
                <classname>Calendar</classname>. There is no default handler for range
                select.
            </para>

            <para>
                In the code example below, we create an new event when any date range is
                selected. Drag selection opens a window where the user is asked for a
                caption for the new event. After confirming, the new event is be passed to
                the event provider and calendar is updated. Note that as our example event
                provider and event classes do not implement the event change interface, we
                must refresh the <classname>Calendar</classname> manually after changing
                the events.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new RangeSelectHandler() {
  public void rangeSelect(RangeSelectEvent event) {
    BasicEvent calendarEvent = new BasicEvent();
    calendarEvent.setStart(event.getStart());
    calendarEvent.setEnd(event.getEnd());

    // Create popup window and add a form in it.
    VerticalLayout layout = new VerticalLayout();
    layout.setMargin(true);
    layout.setSpacing(true);

    final Window w = new Window(null, layout);
    ...

    // Wrap the calendar event to a BeanItem 
    // and pass it to the form
    final BeanItem<CalendarEvent> item = 
                         new BeanItem<CalendarEvent>(myEvent);

    final Form form = new Form();
    form.setItemDataSource(item);
    ...

    layout.addComponent(form);

    HorizontalLayout buttons = new HorizontalLayout();
    buttons.setSpacing(true);
    buttons.addComponent(new Button("OK", new ClickListener() {

        public void buttonClick(ClickEvent event) {
            form.commit();
            // Update event provider's data source
            provider.addEvent(item.getBean());
            // Calendar needs to be repainted
            cal.requestRepaint();
            getMainWindow().removeWindow(w);
        }
    }));

    ...
  }
});]]></programlisting>
        </section>

        <section xml:id="components.calendar.eventresizing" condition="web">
            <title>Resizing Events</title>

            <para>
                The user can resize an event by dragging from both ends to change its
                start or end time. This offers a convenient way to change event times
                without the need to type anything. The default resize handler sets the
                start and end time of the event according to the resize.
            </para>

            <para>
                In the example below, we set a custom handler for resize events. The
                handler prevents any event to be resized over 12 hours in length. Note
                that this does not prevent the user from resizing an event over 12 hours
                in the client. The resize will just be corrected by the server.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicEventResizeHandler() {
  private static final long twelveHoursInMs = 12*60*60*1000;

  protected void setDates(CalendarEventEditor event, 
                          Date start, Date end) {
    long eventLength = end.getTime() - start.getTime();
    if (eventLength <= twelveHoursInMs) {
      super.setDates(event, start, end);
    }
  }
});]]></programlisting>
        </section>
    </section>

	<section xml:id="components.customcomponent">
		<title>Component Composition with <classname>CustomComponent</classname></title>

		<!-- UNFINISHED: Check that this is up-to-date. Probably is. -->

		<para>
			The ease of making new user interface components is one of the core features
			of Vaadin. Typically, you simply combine existing built-in components to
			produce composite components. In many applications, such composite components
			make up the majority of the user interface.
		</para>

        <para>
            To create a composite component, you need to inherit the
            <classname>CustomComponent</classname> and call the
            <methodname>setCompositionRoot()</methodname> in the constructor to set the
            <emphasis>composition root</emphasis> component. The root component is
            typically a layout component that contains multiple components.
        </para>

        <para>
            For example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyComposite extends CustomComponent {
    public MyComposite(String message) {
        // A layout structure used for composition
        Panel panel = new Panel("My Custom Component");
        panel.setContent(new VerticalLayout());
        
        // Compose from multiple components
        Label label = new Label(message);
        label.setSizeUndefined(); // Shrink
        panel.addComponent(label);
        panel.addComponent(new Button("Ok"));

        // Set the size as undefined at all levels
        panel.getContent().setSizeUndefined();
        panel.setSizeUndefined();
        setSizeUndefined();

        // The composition root MUST be set
        setCompositionRoot(panel);
    }
}]]></programlisting>

        <para>
            Take note of the sizing when trying to make a customcomponent that shrinks to
            fit the contained components. You have to set the size as undefined at all
            levels; the sizing of the composite component and the composition root are
            separate.
        </para>

        <para>
            You can use the component as follows:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[MyComposite mycomposite = new MyComposite("Hello");]]></programlisting>

        <para>
            The rendered component is shown in <xref
            linkend="figure.components.customcomponent"/>.
        </para>

		<figure xml:id="figure.components.customcomponent">
			<title>A Custom Composite Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="140" align="center" fileref="img/components/customcomponent-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            You can also inherit any other components, such as layouts, to attain similar
            composition.

            <indexterm><primary>Google Web Toolkit</primary></indexterm>

            Even further, you can create entirely new low-level components, by integrating
            pure client-side components or by extending the client-side functionality of
            built-in components. Development of new components is covered in <xref
            linkend="gwt"/>.
		</para>
	</section>

	<section xml:id="components.customfield">
		<title>Composite Fields with <classname>CustomField</classname></title>

        <para>
            The <classname>CustomField</classname> is a way to create composite components
            like with <classname>CustomComponent</classname>, except that it implements
            the <interfacename>Field</interfacename> interface and inherit
            <classname>AbstractField</classname>, described in <xref
            linkend="components.interfaces.fields"/>. A field allows editing a property
            value in the Vaadin data model, and can be bound to data with field groups, as
            described in <xref linkend="datamodel.itembinding"/>. The field values are
            buffered and can be validated with validators.
        </para>

        <para>
            A composite field class must implement the <methodname>getType()</methodname>
            and <methodname>initContent()</methodname> methods. The latter should return
            the content composite of the field. It is typically a layout component, but
            can be any component.
        </para>

        <!-- TODO Add example -->

        <para>
            It is also possible to override <methodname>validate()</methodname>,
            <methodname>setInternalValue()</methodname>,
            <methodname>commit()</methodname>,
            <methodname>setPropertyDataSource</methodname>,
            <methodname>isEmpty()</methodname> and other methods to implement different
            functionalities in the field. Methods overriding
            <methodname>setInternalValue()</methodname> should call the superclass method.
        </para>
    </section>
</chapter>
	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
