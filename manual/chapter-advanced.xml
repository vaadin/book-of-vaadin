<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="advanced">
	<title>Advanced Web Application Topics</title>

    <para>
        This chapter covers various features and topics often needed in
        applications.
    </para>

	<section xml:id="advanced.windows">
		<title>Handling Browser Windows</title>

		<para>
            The UI of a Vaadin application runs in a web page displayed in a browser
            window or tab. An application can be used from multiple UIs in different
            windows or tabs, either opened by the user using an URL or by the Vaadin
            application.
        </para>

        <para>
            In addition to native browser windows, Vaadin has a
            <classname>Window</classname> component, which is a floating panel or
            <emphasis>sub-window</emphasis> inside a page, as described in <xref
            linkend="layout.sub-window"/>.
        </para>

		<itemizedlist>
			<listitem>
				<emphasis>Native popup windows</emphasis>. An application can open popup
				windows for sub-tasks.
			</listitem>
			<listitem>
				<emphasis>Page-based browsing</emphasis>. The application can allow the
				user to open certain content to different windows. For example, in a
				messaging application, it can be useful to open different messages to
				different windows so that the user can browse through them while writing a
				new message.
			</listitem>
			<listitem>
				<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide an
				entry-point to some content provided by an application.
			</listitem>
			<listitem>
				<emphasis>Embedding UIs</emphasis>. UIs can be embedded in web
				pages, thus making it possible to provide different views to an
				application from different pages or even from the same page, while keeping
				the same session. See <xref linkend="advanced.embedding"/>.
			</listitem>
		</itemizedlist>

        <para>
            Use of multiple windows in an application may require defining and providing
            different UIs for the different windows. The UIs of an application share the
            same user session, that is, the <classname>VaadinSession</classname> object,
            as described in <xref linkend="application.lifecycle.session"/>. Each UI is
            identified by a URL that is used to access it, which makes it possible to
            bookmark application UIs. UI instances can even be created dynamically based
            on the URLs or other request parameters, such as browser information, as
            described in <xref linkend="application.lifecycle.ui"/>.
		</para>

		<para>
			Because of the special nature of AJAX applications, use of multiple windows
			uses require some caveats. <!-- TODO Re-enable We will go through them later in <xref
			linkend="advanced.windows.caveats"/>. -->
		</para>
		
        <section xml:id="advanced.windows.popup">
			<title>Opening Popup Windows</title>
            <indexterm zone="advanced.windows.popup">
                <primary>popup windows</primary>
            </indexterm>
            <indexterm zone="advanced.windows.popup">
                <primary>windows</primary>
                <secondary>popup</secondary>
            </indexterm>

            <para>
                Popup windows are native browser windows or tabs opened by user
                interaction with an existing window.  Due to browser security reasons, it
                is made incovenient for a web page to open popup windows using JavaScript
                commands. At the least, the browser will ask for a permission to open the
                popup, if it is possible at all. This limitation can be circumvented by
                letting the browser open the new window or tab directly by its URL when
                the user clicks some target. This is realized in Vaadin with the
                <classname>BrowserWindowOpener</classname> component extension, which
                causes the browser to open a window or tab when the component is clicked.
            </para>

            <section xml:id="advanced.windows.popup.ui">
                <title>The Popup Window UI</title>

                <para>
                    A popup Window displays an <classname>UI</classname>. The UI of a
                    popup window is defined just like a main UI in a Vaadin application,
                    and it can have a theme, title, and so forth.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@Theme("book-examples")
public static class MyPopupUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        getPage().setTitle("Popup Window");
        
        // Have some content for it
        VerticalLayout content = new VerticalLayout();
        Label label =
            new Label("I just popped up to say hi!");
        label.setSizeUndefined();
        content.addComponent(label);
        content.setComponentAlignment(label,
            Alignment.MIDDLE_CENTER);
        content.setSizeFull();
        setContent(content);
    }
}]]></programlisting>
            </section>

            <section xml:id="advanced.windows.popup.popping">
                <title>Popping It Up</title>

                <para>
                    A popup window is opened using the
                    <classname>BrowserWindowOpener</classname> extension, which you can
                    attach to any component. The constructor of the extension takes the
                    class object of the UI class to be opened as a parameter.
                </para>

                <para>
                    You can configure the features of the popup window with
                    <methodname>setFeatures()</methodname>. It takes as its parameter a
                    comma-separated list of window features, as defined in the HTML
                    specification.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><varname>status</varname>=<parameter>0|1</parameter></term>
                        <listitem>Whether the status bar at the bottom of the window should be enabled.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname></varname><parameter></parameter></term>
                        <listitem></listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>scrollbars</varname></term>
                        <listitem>Enables scrollbars in the window if the document area is bigger than the view area of the window.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>resizable</varname></term>
                        <listitem>Allows the user to resize the browser window (no effect for tabs).</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>menubar</varname></term>
                        <listitem>Enables the browser menu bar.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>location</varname></term>
                        <listitem>Enables the location bar.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>toolbar</varname></term>
                        <listitem>Enables the browser toolbar.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>height</varname>=<parameter>value</parameter></term>
                        <listitem>Specifies the height of the window in pixels.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>width</varname>=<parameter>value</parameter></term>
                        <listitem>Specifies the width of the window in pixels.</listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[// Create an opener extension
BrowserWindowOpener opener =
    new BrowserWindowOpener(MyPopupUI.class);
opener.setFeatures("height=200,width=300,resizable");

// Attach it to a button
Button button = new Button("Pop It Up");
opener.extend(button);]]></programlisting>

                <para>
                    The resulting popup window, which appears when the button is clicked,
                    is shown in <xref linkend="figure.advanced.windows.popup.popping"/>.
                </para>

                <figure xml:id="figure.advanced.windows.popup.popping">
                    <title>A Popup Window</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/advanced/windows-popup.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="70" smallscale="80%" align="center" fileref="img/advanced/windows-popup.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>

            <section xml:id="advanced.windows.popup.target">
                <title>Popup Window Name (Target)</title>

                <para>
                    The target name is one of the default HTML target names
                    (<parameter>_new</parameter>, <parameter>_blank</parameter>,
                    <parameter>_top</parameter>, etc.) or a custom target name.  How the
                    window is exactly opened depends on the browser. Browsers that support
                    tabbed browsing can open the window in another tab, depending on the
                    browser settings.
                </para>
            </section>

            <section xml:id="advanced.windows.popup.url">
                <title>URL and Session</title>
                
                <para>
                    The URL path for a popup window UI is by default determined from
                    the UI class name, by prefixig it with
                    "<literal>popup/</literal>". For example, for the example UI giver
                    earlier, the URL would be
                    <literal>/book-examples/book/popup/MyPopupUI</literal>.
                </para>
            </section>
        </section>

        <section xml:id="advanced.windows.popup-closing">
            <title>Closing Popup Windows</title>

            <para>
                Besides closing popup windows from a native window close button, you can
                close them programmatically by calling the JavaScript
                <methodname>close()</methodname> method as follows.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyPopup extends UI {
    @Override
    protected void init(VaadinRequest request) {
        setContent(new Button("Close Window", event -> {// Java 8
            // Close the popup
            JavaScript.eval("close()");

            // Detach the UI from the session
            getUI().close();
        }));
    }
}]]></programlisting>

        </section>

		<!-- TODO Re-enable <section xml:id="advanced.windows.caveats">
			<title>Caveats in Using Multiple Windows</title>

			<section>
				<title>Communication Between Windows</title>
				
				<para>
                    Handling communication between multiple browser windows is not quite
                    as straight-forward as it is with sub-windows, as an UI running in a
                    browser window can not easily update the data shown in other
                    windows. The contents of a UI are normally updated only when the UI
                    makes a request to the server. The request can be caused by user input
                    or through polling. You could also use server push.
				</para>

				<para>
					However, changing the server-side state of a UI while processing a
					user event from another UI can potentially cause serious
					problems. Changing the client-side state of a UI does not always
					immediately communicate the changes to the server. The server-side
					state can therefore be out of sync with the client-side state.
				</para>

				<figure xml:id="figure.advanced.windows.polling">
					<title>Communication Between Two Browser Windows</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/advanced/window-polling-example1.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/advanced/window-polling-example1.png"/>
						</imageobject>
					</mediaobject>
				</figure>
                -->
                <!-- TODO: Provide an example. The old example was in MagiTestApplication.java (TK5.2) -->
			<!-- </section> -->
    </section>

	<section xml:id="advanced.embedding">
		<title>Embedding UIs in Web Pages</title>

		<para>
			Many web sites are not all Vaadin, but Vaadin UIs are used only for specific
			functionalities. In practice, many web applications are a mixture of dynamic
			web pages, such as JSP, and Vaadin UIs embedded in such pages.
		</para>

		<para>
			Embedding Vaadin UIs in web pages is easy and there are several different ways
			to embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for
			the UI and load the Vaadin Client-Side Engine with some simple JavaScript
			code. Another method is even easier, which is to simply use the
			<literal>&lt;iframe&gt;</literal> element. Both of these methods have
			advantages and disadvantages. One disadvantage of the
			<literal>&lt;iframe&gt;</literal> method is that the size of the
			<literal>&lt;iframe&gt;</literal> element is not flexible according to the
			content while the <literal>&lt;div&gt;</literal> method allows such
			flexibility. The following sections look closer into these two embedding
			methods.

            <!-- TODO enable once available again
            <phrase condition="web">Additionally, the Vaadin XS add-on allows embedding Vaadin
			UIs in websites running in another server.</phrase>
            -->
		</para>

		<section xml:id="advanced.embedding.div">
			<title>Embedding Inside a <literal>div</literal> Element</title>

			<para>
				You can embed one or more Vaadin UIs inside a web page with a method that
				is equivalent to loading the initial page content from the Vaadin servlet
				in a non-embedded UI. Normally, the <classname>VaadinServlet</classname>
				generates an initial page that contains the correct parameters for the
				specific UI. You can easily configure it to load multiple Vaadin UIs in
				the same page. They can have different widget sets and different themes.
			</para>

            <para>
                Embedding an UI requires the following basic tasks:
            </para>

            <itemizedlist>
                <listitem>Set up the page header</listitem>
                <listitem>Include a GWT history frame in the page</listitem>
                <listitem>Call the <filename>vaadinBootstrap.js</filename> file</listitem>
                <listitem>Define the <literal>&lt;div&gt;</literal> element for the UI</listitem>
                <listitem>Configure and initialize the UI</listitem>
            </itemizedlist>

			<para>
                Notice that you can view the loader page for the UI easily by opening the
                UI in a web browser and viewing the HTML source code of the page. You
                could just copy and paste the embedding code from the page, but some
                modifications and additional settings are required, mainly related to the
                URLs that have to be made relative to the page instead of the servlet URL.
			</para>

            <para condition="print">
                <emphasis>The DIV embedding API is about to change soon after printing
                this book edition. A tutorial that describes the feature should be made
                available at the Vaadin website.</emphasis>
            </para>

            <section xml:id="advanced.embedding.div.head" condition="web">
                <title>The Head Matter</title>

                <para>
                    The HTML page in which the Vaadin UI is embedded should be a valid
                    HTML 5 document. The content of the head element is largely up to
                    you. The character encoding must be UTF-8. Some meta declarations are
                    necessary for compatibility. You can also set the page favicon in the
                    head element.
                </para>

                <programlisting><?pocket-size 65% ?>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type"
          content="text/html; charset=UTF-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible"
          content="IE=9;chrome=1" /&gt;

    &lt;title&gt;<replaceable>This is my Embedding Page</replaceable>&lt;/title&gt;
  
    &lt;!-- Set up the favicon from the Vaadin theme --&gt;
    &lt;link rel="shortcut icon" type="image/vnd.microsoft.icon"
          href="/VAADIN/themes/<replaceable>reindeer</replaceable>/favicon.ico" /&gt;
    &lt;link rel="icon" type="image/vnd.microsoft.icon"
             href="/VAADIN/themes/<replaceable>reindeer</replaceable>/favicon.ico" /&gt; 
  &lt;/head&gt;</programlisting>
            </section>
            
            <section xml:id="advanced.embedding.div.body" condition="web">
                <title>The Body Matter</title>

                <para>
                    The page content must include some Vaadin-related definitions before
                    you can embed Vaadin UIs in it.
                </para>

                <para>
                    The <filename>vaadinBootstrap.js</filename> script makes definitions
                    for starting up the UI. It must be called before initializing the
                    UI. The source path must be relative to the path of the embedding
                    page.
                </para>

                <programlisting>&lt;body&gt;
  &lt;script type="text/javascript"
          src="<replaceable>./</replaceable>VAADIN/vaadinBootstrap.js"&gt;&lt;/script&gt;</programlisting>

                <para>
                    The bootstrap script is served by the Vaadin servlet from inside the
                    <filename>vaadin-server</filename> JAR.
                </para>

                <para>
                    Vaadin, or more precisely GWT, requires an invisible history frame,
                    which is used for tracking the page or fragment history in the
                    browser.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[  <iframe tabindex="-1" id="__gwt_historyFrame"
          style="position: absolute; width: 0; height: 0;
                 border: 0; overflow: hidden"
          src="javascript:false"></iframe>]]></programlisting>
            </section>

            <section xml:id="advanced.embedding.div.div" condition="web">
                <title>UI Placeholder Element</title>

                <para>
                    A Vaadin UI is embedded in a placeholder
                    <literal>&lt;div&gt;</literal> element. It should have the following
                    features:
                </para>

                <itemizedlist>
                    <listitem>The <literal>&lt;div&gt;</literal> element must have an
                    <literal>id</literal> attribute, which must be a unique ID in the
                    page, normally something that identifies the servlet of the UI
                    uniquely. </listitem>

                    <listitem>It must have at least the <literal>v-app</literal> style
                    class.</listitem>

                    <listitem>it should have a nested <literal>&lt;div&gt;</literal>
                    element with <literal>v-app-loading</literal> style class. This is a
                    placeholder for the loading indicator that is displayed while the UI
                    is being loaded.</listitem>

                    <listitem>It should also contain a <literal>&lt;noscript&gt;</literal>
                    element that is shown if the browser does not support JavaScript or it
                    has been disabled. The content of the element should instruct the use
                    to enable JavaScript in the browser.</listitem>
                </itemizedlist>

                <para>
                    The placeholder element can include style settings, typically a width
                    and height. If the sizes are not defined, the UI will have an
                    undefined size in the particular dimension, which must be in
                    accordance with the sizing of the UI components.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?>&lt;div style="<replaceable>width: 300px; border: 2px solid green;</replaceable>"
     id="helloworldui" class="v-app"&gt;
  &lt;div class="v-app-loading"&gt;&lt;/div&gt;
  &lt;noscript&gt;<replaceable>You have to enable javascript in your browser to</replaceable>
            <replaceable>use an application built with Vaadin.</replaceable>&lt;/noscript&gt;
&lt;/div&gt;</programlisting>

            </section>

            <section xml:id="advanced.embedding.div.init" condition="web">
                <title>Initializing the UI</title>

                <para>
                    The UI is loaded by calling the <literal>initApplication()</literal>
                    method for the <literal>vaadin</literal> object defined in the
                    bootstrap script. Before calling it, you should check that the
                    bootstrap script was loaded properly.
                </para>

                <programlisting><?pocket-size 75% ?>&lt;script type="text/javascript"&gt;//&lt;![CDATA[
  if (!window.vaadin)
      alert("<replaceable>Failed to load the bootstrap JavaScript:</replaceable>"+
            "<replaceable>VAADIN/vaadinBootstrap.js</replaceable>");</programlisting>

                <para>
                    The <literal>initApplication()</literal> takes two parameters. The
                    first parameter is the UI identifier, exactly as given as the
                    <literal>id</literal> attribute of the placeholder element. The second
                    parameter is an associative map that contains parameters for the
                    UI. 
                </para>

                <para>
                    The map must contain the following items:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><parameter>browserDetailsUrl</parameter></term>
                        <listitem>
                            <para>
                                This should be the URL path (relative to the embedding
                                page) to the Vaadin servlet of the UI. It is used by the
                                bootstrap to communicate browser details. A trailing slash
                                may be needed in some cases.
                            </para>

                            <para>
                                Notice that this parameter is not included in the loader
                                page generated by the servlet, because in that case, it
                                can default to the current URL.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>serviceUrl</parameter></term>
                        <listitem>
                            <para>
                                This is used for server requests after initial loading and
                                should be same as for
                                <parameter>browserDetailsUrl</parameter>. The two
                                parameters are redundant and either may be removed in
                                future. <!-- Bug #10122 -->
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>widgetset</parameter></term>
                        <listitem>
                            This should be the exact class name of the widget set for the
                            UI, that is, without the <filename>.gwt.xml</filename> file
                            name extension. If the UI has no custom widget set, you can
                            use the <classname>com.vaadin.DefaultWidgetSet</classname>.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>theme</parameter></term>
                        <listitem>
                            Name of the theme, such as one of the built-in themes
                            (<literal>reindeer</literal>, <literal>runo</literal>, or
                            <literal>chameleon</literal>) or a custom theme. It must exist
                            under the <filename>VAADIN/themes</filename> folder.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>versionInfo</parameter></term>
                        <listitem>
                            This parameter is itself an associative map that can contain
                            two parameters: <parameter>vaadinVersion</parameter> contains
                            the version number of the Vaadin version used by the
                            application. The <parameter>applicationVersion</parameter>
                            parameter contains the version of the particular
                            application. The contained parameters are optional, but the
                            <parameter>versionInfo</parameter> parameter itself is not.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>vaadinDir</parameter></term>
                        <listitem>
                            Relative path to the <filename>VAADIN</filename> directory. It
                            is relative to the URL of the embedding page.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>heartbeatInterval</parameter></term>
                        <listitem>
                            The <parameter>hearbeatInterval</parameter> parameter defines
                            the frequency of the keep-alive hearbeat for the UI in
                            seconds, as described in <xref
                            linkend="application.lifecycle.ui-expiration"/>.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>debug</parameter></term>
                        <listitem>
                            The parameter defines whether the debug window, as described in
                            <xref linkend="advanced.debug"/>, is enabled.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>standalone</parameter></term>
                        <listitem>
                            This parameter should be <parameter>false</parameter> when
                            embedding. <phrase condition="web">The parameter defines
                            whether the UI is rendered on its own in the browser window or
                            in some context. A standalone UI may do things that might
                            interfere with other parts of the page, such as change the
                            page title and request focus when it is loaded. When
                            embedding, the UI is not standalone.</phrase>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>authErrMsg</parameter>, <parameter>comErrMsg</parameter>, and <parameter>sessExpMsg</parameter></term>
                        <listitem>
                            These three parameters define the client-side error messages
                            for authentication error, communication error, and session
                            expiration, respectively. The parameters are associative maps
                            themselves and must contain two key-value pairs:
                            <parameter>message</parameter>, which should contain the error
                            text in HTML, and <parameter>caption</parameter>, which should
                            be the error caption.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?>  vaadin.initApplication("<replaceable>helloworldui</replaceable>", {
      "browserDetailsUrl": "<replaceable>helloworld</replaceable>/",
      "serviceUrl": "<replaceable>helloworld</replaceable>/",
      "widgetset": "<replaceable>com.example.MyWidgetSet</replaceable>",
      "theme": "<replaceable>mytheme</replaceable>",
      "versionInfo": {"vaadinVersion": "<replaceable>7.0.0</replaceable>"},
      "vaadinDir": "<replaceable>VAADIN/</replaceable>",
      "heartbeatInterval": <replaceable>300</replaceable>,
      "debug": <replaceable>true</replaceable>,
      "standalone": false,
      "authErrMsg": {
          "message": "<replaceable>Take note of any unsaved data, "+
                     "and &lt;u&gt;click here&lt;\/u&gt; to continue.</replaceable>",
          "caption": "Authentication problem"
      },
      "comErrMsg": {
          "message": "<replaceable>Take note of any unsaved data, "+
                     "and &lt;u&gt;click here&lt;\/u&gt; to continue.</replaceable>",
          "caption": "Communication problem"
      },
      "sessExpMsg": {
          "message": "<replaceable>Take note of any unsaved data, "+
                     "and &lt;u&gt;click here&lt;\/u&gt; to continue.</replaceable>",
          "caption": "Session Expired"
      }
  });//]]&gt;
&lt;/script&gt;</programlisting>

                <para>
                    Notice that many of the parameters are normally deployment parameters,
                    specified in the deployment descriptor, as described in <xref
                    linkend="application.environment.parameters"/>.
                </para>
            </section>

            <section xml:id="advanced.embedding.div.summary" condition="web">
                <title>Summary of Div Embedding</title>

                <para>
                    Below is a complete example of embedding an UI in a
                    <literal>&lt;div&gt;</literal> element.
                </para>

			<programlisting><?pocket-size 65% ?><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible"
        content="IE=9;chrome=1" />

  <title>Embedding a Vaadin Application in HTML Page</title>
  
  <!-- Set up the favicon from the Vaadin theme -->
  <link rel="shortcut icon" type="image/vnd.microsoft.icon"
        href="/VAADIN/themes/reindeer/favicon.ico" />
  <link rel="icon" type="image/vnd.microsoft.icon"
           href="/VAADIN/themes/reindeer/favicon.ico" /> 
</head>

<body>
  <!-- Loads the Vaadin widget set, etc. -->
  <script type="text/javascript"
          src="VAADIN/vaadinBootstrap.js"></script>

  <!-- GWT requires an invisible history frame. It is   -->
  <!-- needed for page/fragment history in the browser. -->
  <iframe tabindex="-1" id="__gwt_historyFrame"
          style="position: absolute; width: 0; height: 0;
                 border: 0; overflow: hidden"
          src="javascript:false"></iframe>  

  <h1>Embedding a Vaadin UI</h1>
    
  <p>This is a static web page that contains an embedded Vaadin
     application. It's here:</p>

  <!-- So here comes the div element in which the Vaadin -->
  <!-- application is embedded.                          -->
  <div style="width: 300px; border: 2px solid green;"
       id="helloworld" class="v-app">

    <!-- Optional placeholder for the loading indicator -->
    <div class=" v-app-loading"></div>

    <!-- Alternative fallback text -->
    <noscript>You have to enable javascript in your browser to
              use an application built with Vaadin.</noscript>
  </div>
  
  <script type="text/javascript">//<![CDATA[
    if (!window.vaadin)
        alert("Failed to load the bootstrap JavaScript: "+
              "VAADIN/vaadinBootstrap.js");

    /* The UI Configuration */
	vaadin.initApplication("helloworld", {
	    "browserDetailsUrl": "helloworld/",
	    "serviceUrl": "helloworld/",
	    "widgetset": "com.example.MyWidgetSet",
	    "theme": "mytheme",
	    "versionInfo": {"vaadinVersion": "7.0.0"},
	    "vaadinDir": "VAADIN/",
	    "heartbeatInterval": 300,
	    "debug": true,
	    "standalone": false,
	    "authErrMsg": {
	        "message": "Take note of any unsaved data, "+
	                   "and <u>click here<\/u> to continue.",
	        "caption": "Authentication problem"
	    },
	    "comErrMsg": {
	        "message": "Take note of any unsaved data, "+
	                   "and <u>click here<\/u> to continue.",
	        "caption": "Communication problem"
	    },
	    "sessExpMsg": {
	        "message": "Take note of any unsaved data, "+
	                   "and <u>click here<\/u> to continue.",
	        "caption": "Session Expired"
	    }
	});//]] >
  </script>
  
  <p>Please view the page source to see how embedding works.</p>
</body>
</html>]]></programlisting>
            </section>
        </section>

		<section xml:id="advanced.embedding.iframe">
			<title>Embedding Inside an <literal>iframe</literal> Element</title>

			<para>
				Embedding a Vaadin UI inside an <literal>&lt;iframe&gt;</literal> element
				is even easier than the method described above, as it does not require
				definition of any Vaadin specific definitions.
			</para>

			<para>
				You can embed an UI with an element such as the following:
			</para>

			<programlisting>&lt;iframe src="<replaceable>/myapp/myui</replaceable>"&gt;&lt;/iframe&gt;</programlisting>

			<para>
				The <literal>&lt;iframe&gt;</literal> elements have several downsides for
				embedding. One is that their size of is not flexible depending on the
				content of the frame, but the content must be flexible to accommodate in
				the frame. You can set the size of an <literal>&lt;iframe&gt;</literal>
				element with <literal>height</literal> and <literal>width</literal>
				attributes. Other issues arise from themeing and communication with the
				frame content and the rest of the page.
			</para>

			<para>
				Below is a complete example of using the <literal>&lt;iframe&gt;</literal>
				to embed two applications in a web page.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html>
<html>
  <head>
    <title>Embedding in IFrame</title>
  </head>

  <body style="background: #d0ffd0;">
    <h1>This is a HTML page</h1>
    <p>Below are two Vaadin applications embedded inside
       a table:</p>

    <table align="center" border="3">
      <tr>
        <th>The Calculator</th>
        <th>The Color Picker</th>
      </tr>
      <tr valign="top">
        <td>
          <iframe src="/vaadin-examples/Calc" height="200"
                  width="150" frameborder="0"></iframe>
        </td>
        <td>
          <iframe src="/vaadin-examples/colorpicker"
                  height="330" width="400"
                  frameborder="0"></iframe>
        </td>
      </tr>
    </table>
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.iframe"/>
				below.
			</para>

			<figure xml:id="figure.embedding.iframe">
				<title>Vaadin Applications Embedded Inside IFrames</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                You can embed almost anything in an iframe, which essentially acts as a
                browser window. However, this creates various problems. The iframe must
                have a fixed size, inheritance of CSS from the embedding page is not
                possible, and neither is interaction with JavaScript, which makes mashups
                impossible, and so on. Even bookmarking with URI fragments will not work.
            </para>

            <para>
                Note also that websites can forbid iframe embedding by specifying an
                <literal>X-Frame-Options: SAMEORIGIN</literal> header in the HTTP
                response.
            </para>
		</section>

		<section xml:id="advanced.embedding.xs" condition="web">
            <title>Cross-Site Embedding with the Vaadin XS Add-on</title>

            <!-- NOTE Once re-enabled, remember to enable refs earlier. -->

            <para>
                <emphasis>The XS add-on is currently not available for Vaadin 7.</emphasis>
            </para>

            <para>
                In the previous sections, we described the two basic methods for embedding
                Vaadin applications: in a <literal>&lt;div&gt;</literal> element and in an
                <literal>&lt;iframe&gt;</literal>. One problem with div embedding is that
                it does not work between different Internet domains, which is a problem if
                you want to have your website running in one server and your Vaadin
                application in another. The security model in browsers effectively
                prevents such cross-site embedding of Ajax applications by enforcing the
                <emphasis>same origin policy</emphasis> for XmlHttpRequest calls, even if
                the server is running in the same domain but different port. While iframe
                is more permissive, allowing embedding almost anything in anywhere, it has
                many disadvantanges, as described earlier.
            </para>

            <para>
                The Vaadin XS (Cross-Site) add-on works around the limitation in div
                embedding by using JSONP-style communication instead of the standard
                XmlHttpRequests.
            </para>

            <para>
                Embedding is done simply with:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[  <script src="http://demo.vaadin.com/xsembed/getEmbedJs"
          type="text/javascript"></script>]]></programlisting>

            <para>
                This includes an automatically generated embedding script in the page,
                thereby making embedding effortless.
            </para>

            <para>
                This assumes that the main layout of the application has undefined
                height. If the height is 100%, you have to wrap it inside an element with
                a defined height. For example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[ <div style="height: 500px;">
  <script src="http://demo.vaadin.com/xsembed/getEmbedJs"
          type="text/javascript"></script>
</div>]]></programlisting>

            <para>
                It is possible to restrict where the application can be embedded by using
                a whitelist. The add-on also encrypts the client-server communication,
                which is more important for embedded applications than usual.
            </para>

            <para>
                You can get the Vaadin XS add-on from Vaadin Directory. It is provided as
                a Zip package. Download and extract the installation package to a local
                folder. Instructions for installation and further information is given in
                the <filename>README.html</filename> file in the package.
            </para>

            <para>
                Some restrictions apply. You can have only one embedded application in one
                page. Also, some third-party libraries may interfere with the
                communication. Other notes are given in the README.
            </para>
        </section>

        <!-- TODO
		<section xml:id="advanced.embedding.jsp">
			<title>Embedding Into JSP and JSF Applications</title>

        </section>
         -->
	</section>

	<section xml:id="advanced.debug">
		<title>Debug Mode and Window</title>

		<para>
			Vaadin applications can be run in two modes: <emphasis>debug mode</emphasis>
			and <emphasis>production mode</emphasis>. The debug mode, which is on by
			default, enables a number of built-in debug features for Vaadin developers:
		</para>

		<itemizedlist>
			<listitem>Debug Window</listitem>
			<listitem>Display debug information in the Debug Window and server console</listitem>
            <listitem>On-the-fly compilation of Sass themes</listitem>
		</itemizedlist>

		<section xml:id="advanced.debug.mode">
			<title>Enabling the Debug Mode</title>

            <para>
                The debug mode is enabled and production mode disabled by default in the
                UI templates created with the Eclipse plugin or the Maven archetypes. The
                debug mode can be enabled by giving a
                <parameter>productionMode=false</parameter> parameter to the Vaadin servlet
                configuration:
            </para>

            <programlisting><?pocket-size 75% ?>@VaadinServletConfiguration(
            productionMode = <emphasis role="bold">false</emphasis>,
            ui = <emphasis role="bold">MyprojectUI.class</emphasis>)</programlisting>

            <para>
                Or with a context parameter in the <filename>web.xml</filename> deployment
                descriptor:
            </para>

            <programlisting><?pocket-size 75% ?>&lt;context-param&gt;
  &lt;description&gt;Vaadin production mode&lt;/description&gt;
  &lt;param-name&gt;productionMode&lt;/param-name&gt;
  &lt;param-value&gt;<emphasis role="bold">false</emphasis>&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
		
            <para>
                Enabling the production mode disables the debug features, thereby
                preventing users from easily inspecting the inner workings of the
                application from the browser.
            </para>
        </section>
		
		<section xml:id="advanced.debug.open">
			<title>Opening the Debug Window</title>

            <para>
                Running an application in the debug mode enables the client-side Debug
                Window in the browser. You can open the Debug Window by adding
                "<uri>?debug</uri>" parameter to the URL of the UI, for example,
                <uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window has
                buttons for controlling the debugging features and a scrollable log of
                debug messages.
            </para>

			<figure id="figure.debug.window">
 				<title>Debug Window</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/debug/debug-window-annotated-hi.png"/>
 					</imageobject>
                    <imageobject role="fo">
					 	<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window-annotated-hi.png"/>
 					</imageobject>
	 			</mediaobject>
			</figure>

            <para>
                The functionalities are described in detail in the subsequent sections.
                You can move the window by dragging it from the title bar and resize it
                from the corners. The <guibutton>Minimize</guibutton> button minimizes the
                debug window in the corner of the browser window, and the
                <guibutton>Close</guibutton> button closes it.
            </para>

			<para>
				If you use the Firebug plugin for Firefox or the Developer Tools console
				in Chrome, the log messages will also be printed to the Firebug
				console. In such a case, you may want to enable client-side debugging
				without showing the Debug Window with "<uri>?debug=quiet</uri>" in the
				URL. In the quiet debug mode, log messages will only be printed to the
				console of the browser debugger.
			</para>
		</section>

		<section xml:id="advanced.debug.log">
			<title>Debug Message Log</title>

            <para>
                The debug message log displays client-side debug messages, with time
                counter in milliseconds. The control buttons allow you to clear the log,
                reset the timer, and lock scrolling.
            </para>

			<figure id="figure.debug.window">
 				<title>Debug Message Log</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/debug/debug-log-hi.png"/>
 					</imageobject>
                    <imageobject role="fo">
					 	<imagedata smallscale="75%" align="center" fileref="img/debug/debug-log-hi.png"/>
 					</imageobject>
	 			</mediaobject>
			</figure>

            <section xml:id="advanced.debug.log.custom">
                <title>Logging to Debug Window</title>

                <para>
                    You can take advantage of the debug mode when developing client-side
                    components, by using the standard Java <classname>Logger</classname>
                    to write messages to the log. The messages will be written to the
                    debug window and Firebug console. No messages are written if the debug
                    window is not open or if the application is running in production
                    mode.
                </para>

            </section>
        </section>

		<section xml:id="advanced.debug.info">
			<title>General Information</title>

            <para>
                The <guilabel>General information about the application(s)</guilabel> tab
                displays various information about the UI, such as version numbers of the
                client and servlet engine, and the theme. If they do not match, you may
                need to compile the widget set or theme.
            </para>

			<figure id="figure.advanced.debug.info">
 				<title>General Information</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/debug/debug-info.png"/>
 					</imageobject>
                    <imageobject role="fo">
					 	<imagedata smallscale="75%" align="center" fileref="img/debug/debug-info.png"/>
 					</imageobject>
	 			</mediaobject>
			</figure>
        </section>

		<section xml:id="advanced.debug.hierarchy">
			<title>Inspecting Component Hierarchy</title>

            <para>
                The <guilabel>Component Hierarchy</guilabel> tab has several sub-modes
                that allow debugging the component tree in various ways.
            </para>

            <section xml:id="advanced.debug.hierarchy.tree">
                <title>Connector Hierarchy Tree</title>

                <para>
                    The <guibutton>Show the connector hierarchy tree</guibutton> button
                    displays the client-side connector hierarchy. As explained in <xref
                    linkend="gwt"/>, client-side widgets are managed by connectors that
                    handle communication with the server-side component counterparts. The
                    connector hierarchy therefore corresponds with the server-side
                    component tree, but the client-side widget tree and HTML DOM tree have
                    more complexity.
                </para>

                <figure id="figure.advanced.debug.hierarchy.tree">
                    <title>Connector Hierarchy Tree</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/debug/debug-hierarchy-tree.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata smallscale="60%" align="center" fileref="img/debug/debug-hierarchy-tree.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    Clicking on a connector highlights the widget in the UI.
                </para>
            </section>

            <section xml:id="advanced.debug.hierarchy.inspect">
                <title>Inspecting a Component</title>

                <para>
                    The <guibutton>Select a component in the page to inspect
                    it</guibutton> button lets you select a component in the UI by
                    clicking it and display its client-side properties.
                </para>

                <para>
                    To view the HTML structure and CSS styles in more detail, you can use
                    Firebug in Firefox, or the Developer Tools in Chrome, as described in
                    <xref linkend="getting-started.environment.firefox"/>. Firefox also
                    has a built-in feature for inspecting HTML and CSS.
                </para>
            </section>

            <section xml:id="advanced.debug.hierarchy.analyze">
                <title>Analyzing Layout Problems</title>

                <para>
                    The <guilabel>Check layouts for potential problems</guilabel> button
                    analyzes the currently visible UI and makes a report of possible
                    layout related problems. All detected layout problems are displayed in
                    the log and also printed to the console.
                </para>

                <figure id="figure.advanced.debug.hierarchy.analyze">
                    <title>Debug Window Showing the Result of Layout Analysis.</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata smallscale="100%" align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    Clicking on a reported problem highlights the component with the
                    problem in the UI.
                </para>

                <para>
                    The most common layout problem is caused by placing a component that
                    has a relative size inside a container (layout) that has undefined
                    size in the particular direction (height or width). For example,
                    adding a <classname>Button</classname> with 100% width inside a
                    <classname>VerticalLayout</classname> with undefined width. In such a
                    case, the error would look as shown in <xref
                    linkend="figure.advanced.debug.hierarchy.analyze"/>.
                </para>

                <para>
                    <classname>CustomLayout</classname> components can not be analyzed in
                    the same way as other layouts. For custom layouts, the button analyzes
                    all contained relative-sized components and checks if any relative
                    dimension is calculated to zero so that the component will be
                    invisible. The error log will display a warning for each of these
                    invisible components. It would not be meaningful to emphasize the
                    component itself as it is not visible, so when you select such an
                    error, the parent layout of the component is emphasized if possible.
                </para>
            </section>

            <section xml:id="advanced.debug.hierarchy.used">
                <title>Displaying Used Connectors</title>

                <para>
                    The last button, <guibutton>Show used connectors and how to optimize
                    widget set</guibutton>, displays a list of all currently visible
                    connectors. It also generates a connector bundle loader factory, which
                    you can use to optimize the widget set so that it only contains the
                    widgets actually used in the UI. Note, however, that it only lists the
                    connectors visible in the current UI state, and you usually have more
                    connectors than that.
                </para>
            </section>
		</section>

        <section xml:id="advanced.debug.communication">
            <title>Communication Log</title>

            <para>
                The <guilabel>Communication</guilabel> tab displays all server
                requests. You can unfold the requests to view defails, such as the
                connectors involved. Clicking on a connector highlights the corresponding
                element in the UI.
            </para>

            <para>
                You can use Firebug or Developer Tools in Firefox or Chrome, respectively,
                to get more detailed information about the requests and responses.
            </para>
        </section>

        <section xml:id="advanced.debug.devmodes">
            <title>Debug Modes</title>

            <para>
                The <guilabel>Menu</guilabel> tab in the window opens a sub-menu to select
                various settings. Here you can also launch the GWT SuperDevMode, as
                described in <xref linkend="clientside.debugging"/>.
            </para>
        </section>
	</section>

	<section xml:id="advanced.requesthandler">
		<title>Request Handlers</title>

        <para>
            Request handlers are useful for catching request parameters or generating
            dynamic content, such as HTML, images, PDF, or other content. You can provide
            HTTP content easily also with stream resources, as described in <xref
            linkend="application.resources.stream"/>. The stream resources, however, are
            only usable from within a Vaadin application, such as in an
            <classname>Image</classname> component. Request handlers allow responding to
            HTTP requests made with the application URL, including GET or POST
            parameters. You could also use a separate servlet to generate dynamic content,
            but a request handler is associated with the Vaadin session and it can easily
            access all the session data.
        </para>

        <para>
            To handle requests, you need to implement the
            <interfacename>RequestHandler</interfacename> interface. The
            <methodname>handleRequest()</methodname> method gets the session, request, and
            response objects as parameters.
		</para>

        <para>
            If the handler writes a response, it must return <literal>true</literal>. This
            stops running other possible request handlers. Otherwise, it should return
            <literal>false</literal> so that another handler could return a
            response. Eventually, if no other handler writes a response, a UI will be
            created and initialized.
        </para>

        <para>
            In the following example, we catch requests for a sub-path in the URL for the
            servlet and write a plain text response. The servlet path consists of the
            context path and the servlet (sub-)path. Any additional path is passed to the
            request handler in the <parameter>pathInfo</parameter> of the request. For
            example, if the full path is <filename>/myapp/myui/rhexample</filename>, the
            path info will be <filename>/rhexample</filename>. Also, request parameters
            are available.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[VaadinSession.getCurrent().addRequestHandler(
        new RequestHandler() {
    @Override
    public boolean handleRequest(VaadinSession session,
                                 VaadinRequest request,
                                 VaadinResponse response)
            throws IOException {
        if ("/rhexample".equals(request.getPathInfo())) {
            response.setContentType("text/plain");
            response.getWriter().append(
                "Here's some dynamically generated content.\n"+
                "Time: " + (new Date()).toString());
            return true; // We wrote a response
        } else
            return false; // No response was written
    }
});

// Find out the base bath for the servlet
String servletPath = VaadinServlet.getCurrent()
    .getServletContext().getContextPath() + VaadinServletService 
    .getCurrentServletRequest().getServletPath();
        
// Display the page in a popup window
Link open = new Link("Click to Show the Page",
    new ExternalResource(servletPath + "/rhexample"),
    "_blank", 500, 350, BorderStyle.DEFAULT);
layout.addComponent(open);]]></programlisting>
	</section>

	<section xml:id="advanced.shortcuts">
		<title>Shortcut Keys</title>

        <para>
            Vaadin provides simple ways for defining shortcut keys for field components
            and a default button, and a lower-level generic shortcut key binding API based
            on actions.
        </para>

        <section xml:id="advanced.shortcuts.defaultbutton">
            <title>Shortcut Keys for Default Buttons</title>

            <para>
                You can add or set a <emphasis>click shortcut</emphasis> to a button to
                set it as "default" button; pressing the defined key, typically
                <keycap>Enter</keycap>, in any component in the window causes a click
                event for the button.
            </para>

            <para>
                You can define a click shortcut with the
                <methodname>setClickShortcut()</methodname> shorthand method:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an OK button and set it as the default button
Button ok = new Button("OK");
ok.setClickShortcut(KeyCode.ENTER);
ok.addStyleName(Reindeer.BUTTON_DEFAULT);]]></programlisting>

            <para>
                The <literal>BUTTON_DEFAULT</literal> style name highlights a button to
                show the default button status; usually with a bolder font than usual,
                depending on the theme. The result can be seen in <xref
                linkend="figure.advanced.shortcuts.defaultbutton"/>.
            </para>

			<figure xml:id="figure.advanced.shortcuts.defaultbutton">
				<title>Default Button with Click Shortcut</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="advanced.shortcuts.focus">
            <title>Field Focus Shortcuts</title>

            <para>
                You can define a shortcut key that sets the focus to a field component
                (any component that inherits <classname>AbstractField</classname>) by
                adding a <classname>FocusShortcut</classname> as a shortcut listener to
                the field. .
            </para>

            <para>
                The constructor of the <classname>FocusShortcut</classname> takes the
                field component as its first parameter, followed by the key code, and an
                optional list of modifier keys, as listed in <xref
                    linkend="advanced.shortcuts.keycodes"/>.
            </para>

            <book-example eid="advanced.shortcut.focus" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// A field with Alt+N bound to it
TextField name = new TextField("Name (Alt+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.ALT));
layout.addComponent(name);]]></programlisting>

            <para>
                You can also specify the shortcut by a shorthand notation, where the
                shortcut key is indicated with an ampersand
                (<literal>&amp;</literal>).
            </para>

            <book-example eid="advanced.shortcut.focus" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// A field with Alt+A bound to it, using shorthand notation
TextField address = new TextField("Address (Alt+A)");
address.addShortcutListener(
        new AbstractField.FocusShortcut(address, "&Address"));]]></programlisting>

            <para>
                This is especially useful for internationalization, so that you can
                determine the shortcut key from the localized string.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.actions">
            <title>Generic Shortcut Actions</title>

            <para>
                Shortcut keys can be defined as <emphasis>actions</emphasis> using the
                <classname>ShortcutAction</classname> class. It extends the
                generic <classname>Action</classname> class that is used for example in
                <classname>Tree</classname> and <classname>Table</classname> for context
                menus.  Currently, the only classes that accept
                <classname>ShortcutAction</classname>s are <classname>Window</classname>
                and <classname>Panel</classname>.
            </para>
		
            <para>
                To handle key presses, you need to define an action handler by
                implementing the <classname>Handler</classname> interface. The interface
                has two methods that you need to implement:
                <methodname>getActions()</methodname> and
                <methodname>handleAction()</methodname>.
            </para>

            <para>
                The <methodname>getActions()</methodname> method must return an array of
                <classname>Action</classname> objects for the component, specified with the
                second parameter for the method, the <parameter>sender</parameter> of an
                action. For a keyboard shortcut, you use a
                <classname>ShortcutAction</classname>. The implementation of the method
                could be following:
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[// Have the unmodified Enter key cause an event
Action action_ok = new ShortcutAction("Default key",
        ShortcutAction.KeyCode.ENTER, null);

// Have the C key modified with Alt cause an event
Action action_cancel = new ShortcutAction("Alt+C",
        ShortcutAction.KeyCode.C,
        new int[] { ShortcutAction.ModifierKey.ALT });

Action[] actions = new Action[] {action_cancel, action_ok};

public Action[] getActions(Object target, Object sender) {
    if (sender == myPanel)
        return actions;

    return null;
}]]></programlisting>

            <para>
                The returned <classname>Action</classname> array may be static or you can
                create it dynamically for different senders according to your needs.
            </para>

            <para>
                The constructor of <classname>ShortcutAction</classname> takes a symbolic
                caption for the action; this is largely irrelevant for shortcut actions in
                their current implementation, but might be used later if implementors use
                them both in menus and as shortcut actions.  The second parameter is the
                key code and the third a list of modifier keys, which are listed in <xref
                linkend="advanced.shortcuts.keycodes"/>.
            </para>

            <para>
                The following example demonstrates the definition of a default button for a
                user interface, as well as a normal shortcut key,
                <keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the
                <guibutton>Cancel</guibutton> button.
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[public class DefaultButtonExample extends CustomComponent
                                  implements Handler {
    // Define and create user interface components
    Panel panel = new Panel("Login");
    FormLayout formlayout = new FormLayout();
    TextField username = new TextField("Username");
    TextField password = new TextField("Password");
    HorizontalLayout buttons = new HorizontalLayout();

    // Create buttons and define their listener methods.
    Button ok = new Button("OK", this, "okHandler");
    Button cancel = new Button("Cancel", this, "cancelHandler");

    // Have the unmodified Enter key cause an event
    Action action_ok = new ShortcutAction("Default key",
            ShortcutAction.KeyCode.ENTER, null);

    // Have the C key modified with Alt cause an event
    Action action_cancel = new ShortcutAction("Alt+C",
            ShortcutAction.KeyCode.C,
            new int[] { ShortcutAction.ModifierKey.ALT });

    public DefaultButtonExample() {
        // Set up the user interface
        setCompositionRoot(panel);
        panel.addComponent(formlayout);
        formlayout.addComponent(username);
        formlayout.addComponent(password);
        formlayout.addComponent(buttons);
        buttons.addComponent(ok);
        buttons.addComponent(cancel);

        // Set focus to username
        username.focus();

        // Set this object as the action handler
        panel.addActionHandler(this);
    }

    /**
     * Retrieve actions for a specific component. This method
     * will be called for each object that has a handler; in
     * this example just for login panel. The returned action
     * list might as well be static list.
     */
    public Action[] getActions(Object target, Object sender) {
        System.out.println("getActions()");
        return new Action[] { action_ok, action_cancel };
    }

    /**
     * Handle actions received from keyboard. This simply directs
     * the actions to the same listener methods that are called
     * with ButtonClick events.
     */
    public void handleAction(Action action, Object sender,
                             Object target) {
        if (action == action_ok) {
            okHandler();
        }
        if (action == action_cancel) {
            cancelHandler();
        }
    }

    public void okHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("OK clicked. "
                + "User=" + username.getValue() + ", password="
                + password.getValue()));
    }

    public void cancelHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("Cancel clicked. User="
                + username.getValue() + ", password="
                + password.getValue()));
    }
}]]></programlisting>

            <para>
                Notice that the keyboard actions can currently be attached only to
                <classname>Panel</classname>s and <classname>Window</classname>s. This can
                cause problems if you have components that require a certain key. For
                example, multi-line <classname>TextField</classname> requires the
                <keycap>Enter</keycap> key. There is currently no way to filter the
                shortcut actions out while the focus is inside some specific component, so
                you need to avoid such conflicts.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.keycodes">
            <title>Supported Key Codes and Modifier Keys</title>
            
            <para>
                The shortcut key definitions require a key code to identify the pressed
                key and modifier keys, such as Shift, Alt, or Ctrl, to specify a key
                combination.
            </para>

            <para>
                The key codes are defined in the
                <classname>ShortcutAction.KeyCode</classname> interface and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term>Keys <parameter>A</parameter> to <parameter>Z</parameter></term>
                    <listitem>Normal letter keys</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>F1</parameter> to <parameter>F12</parameter></term>
                    <listitem>
                        <para>Function keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, <parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, <parameter>INSERT</parameter>, <parameter>TAB</parameter></term>
                    <listitem>
                        <para>Control keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>NUM0</parameter> to <parameter>NUM9</parameter></term>
                    <listitem>
                        <para>Number pad keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, <parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter></term>
                    <listitem>
                        <para>Arrow keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</parameter>, <parameter>PAGE_DOWN</parameter></term>
                    <listitem>
                        <para>Other movement keys</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Modifier keys are defined in
                <classname>ShortcutAction.ModifierKey</classname> and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>ModifierKey.ALT</parameter></term>
                    <listitem>Alt key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.CTRL</parameter></term>
                    <listitem>Ctrl key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.SHIFT</parameter></term>
                    <listitem>Shift key</listitem>
                </varlistentry>
            </variablelist>

            <para>
                All constructors and methods accepting modifier keys take them as a
                variable argument list following the key code, separated with commas. For
                example, the following defines a
                <keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>N</keycap></keycombo>
                key combination for a shortcut.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField name = new TextField("Name (Ctrl+Shift+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.CTRL,
                                        ModifierKey.SHIFT));]]></programlisting>

            <section>
                <title>Supported Key Combinations</title>

                <para>
                    The actual possible key combinations vary greatly between browsers, as
                    most browsers have a number of built-in shortcut keys, which can not
                    be used in web applications. For example, Mozilla Firefox allows
                    binding almost any key combination, while Opera does not even allow
                    binding Alt shortcuts. Other browsers are generally in between these
                    two. Also, the operating system can reserve some key combinations and
                    some computer manufacturers define their own system key combinations.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="advanced.printing">
		<title>Printing</title>

        <indexterm xml:id="term.advanced.printing" class="startofrange">
            <primary>printing</primary>
        </indexterm>

		<para>
			Vaadin does not have any special support for printing. There are two basic
			ways to print - in a printer controlled by the application server or by the
			user from the web browser. Printing in the application server is largely
			independent of the UI, you just have to take care that printing commands do
			not block server requests, possibly by running the print commands in another
			thread.
		</para>

		<para>
            <indexterm xml:id="term.advanced.printing.print" class="startofrange">
                <primary><methodname>print()</methodname></primary>
            </indexterm>
            <indexterm xml:id="term.advanced.printing.JavaScript.print" class="startofrange">
                <primary>JavaScript</primary>
                <secondary><methodname>print()</methodname></secondary>
            </indexterm>
            
			For client-side printing, most browsers support printing the web page. You can
			either print the current or a special print page that you open. The page can
			be styled for printing with special CSS rules, and you can hide unwanted
			elements. You can also print other than Vaadin UI content, such as HTML or
			PDF.
        </para>

        <section xml:id="advanced.printing.browserwindow">
            <title>Printing the Browser Window</title>

            <para>
                Vaadin does not have special support for launching the printing in
                browser, but you can easily use the JavaScript
                <methodname>print()</methodname> method that opens the print window of the
                browser.
            </para>

            <indexterm><primary>JavaScript</primary><secondary><methodname>execute()</methodname></secondary></indexterm>

            <book-example eid="advanced.printing.this" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[Button print = new Button("Print This Page");
print.addClickListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        // Print the current page
        JavaScript.getCurrent().execute("print();");
    }
});]]></programlisting>

            <para>
                The button in the above example would print the current page, including
                the button itself. You can hide such elements in CSS, as well as otherwise
                style the page for printing. Style definitions for printing are defined
                inside a <literal>@media print {}</literal> block in CSS.
            </para>
        </section>

        <section xml:id="advanced.printing.opening">
            <title>Opening a Print Window</title>

            <para>
                You can open a browser window with a special UI for print content and
                automatically launch printing the content.
            </para>

            <book-example eid="advanced.printing.open" style="float: right"></book-example>
            <programlisting><?pocket-size 75% ?><![CDATA[public static class PrintUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        // Have some content to print
        setContent(new Label(
            "<h1>Here's some dynamic content</h1>\n" +
            "<p>This is to be printed.</p>",
            ContentMode.HTML));
        
        // Print automatically when the window opens
        JavaScript.getCurrent().execute(
            "setTimeout(function() {" +
            "  print(); self.close();}, 0);");
    }
}
...

// Create an opener extension
BrowserWindowOpener opener =
        new BrowserWindowOpener(PrintUI.class);
opener.setFeatures("height=200,width=400,resizable");
    
// A button to open the printer-friendly page.
Button print = new Button("Click to Print");
opener.extend(print);]]></programlisting>

            <para>
                How the browser opens the window, as an actual (popup) window or just a tab, depends
                on the browser.

                After printing, we automatically close the window with JavaScript
                <methodname>close()</methodname> call.
            </para>

            <indexterm startref="term.advanced.printing.print" class="endofrange"/>
            <indexterm startref="term.advanced.printing.JavaScript.print" class="endofrange"/>
        </section>

        <section xml:id="advanced.printing.pdf">
            <title>Printing PDF</title>

            <para>
                <indexterm><primary>PDF</primary></indexterm>

                To print content as PDF, you need to provide the downloadable content as a
                static or a dynamic resource, such as a
                <classname>StreamResource</classname>.
            </para>

            <para>
                You can let the user open the resource using a <classname>Link</classname>
                component, or some other component with a
                <classname>PopupWindowOpener</classname> extension. When such a link or
                opener is clicked, the browser opens the PDF in the browser, in an
                external viewer (such as Adobe Reader), or lets the user save the
                document.
            </para>

            <para>
                It is crucial to notice that clicking a <classname>Link</classname> or a
                <classname>PopupWindowOpener</classname> is a client-side operation. If
                you get the content of the dynamic PDF from the same UI state, you can not
                have the link or opener enabled, as then clicking it would not get the
                current UI content. Instead, you have to create the resource object before
                the link or opener are clicked. This usually requires a two-step
                operation, or having the print operation available in another view.
            </para>

            <book-example eid="advanced.printing.pdfgeneration" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// A user interface for a (trivial) data model from which
// the PDF is generated.
final TextField name = new TextField("Name");
name.setValue("Slartibartfast");

// This has to be clicked first to create the stream resource
final Button ok = new Button("OK");

// This actually opens the stream resource
final Button print = new Button("Open PDF");
print.setEnabled(false);

ok.addClickListener(new ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        // Create the PDF source and pass the data model to it
        StreamSource source =
            new MyPdfSource((String) name.getValue());
        
        // Create the stream resource and give it a file name
        String filename = "pdf_printing_example.pdf";
        StreamResource resource =
                new StreamResource(source, filename);
        
        // These settings are not usually necessary. MIME type
        // is detected automatically from the file name, but
        // setting it explicitly may be necessary if the file
        // suffix is not ".pdf".
        resource.setMIMEType("application/pdf");
        resource.getStream().setParameter(
                "Content-Disposition",
                "attachment; filename="+filename);

        // Extend the print button with an opener
        // for the PDF resource
        BrowserWindowOpener opener =
                new BrowserWindowOpener(resource);
        opener.extend(print);
      
        name.setEnabled(false);
        ok.setEnabled(false);
        print.setEnabled(true);
    }
});

layout.addComponent(name);
layout.addComponent(ok);
layout.addComponent(print);]]></programlisting>

        </section>

        <indexterm startref="term.advanced.printing" class="endofrange"/>
	</section>

	<section xml:id="advanced.gae" condition="web">
		<title>Google App Engine Integration</title>

        <para>
            <emphasis>This section is not yet fully updated to Vaadin 7.</emphasis>
        </para>

		<para>
			Vaadin includes support to run Vaadin applications in the Google App Engine
			(GAE). The most essential requirement for GAE is the ability to serialize the
			application state. Vaadin applications are serializable through the
			<classname>java.io.Serializable</classname> interface.
		</para>

		<para>
			To run as a GAE application, an application must use
			<classname>GAEVaadinServlet</classname> instead of
			<classname>VaadinServlet</classname>, and of course implement the
			<classname>java.io.Serializable</classname> interface for all persistent
			classes. You also need to enable session support in
			<filename>appengine-web.xml</filename> with:
		</para>
		
		<programlisting><![CDATA[<sessions-enabled>true</sessions-enabled>]]></programlisting>

		<para>
			The Vaadin Project wizard can create the configuration files needed for GAE
			deployment. See <xref linkend="getting-started.first-project.creation"/>. When
			the Google App Engine deployment configuration is selected, the wizard will
			create the project structure following the GAE Servlet convention instead of
			the regular Servlet convention. The main differences are:
		</para>

		<itemizedlist>
			<listitem>Source directory: <filename>src/main/java</filename></listitem>
			<listitem>Output directory: <filename>war/WEB-INF/classes</filename></listitem>
			<listitem>Content directory: <filename>war</filename></listitem>
		</itemizedlist>

		<simplesect>
			<title>Rules and Limitations</title>

			<para>
				Running Vaadin applications in Google App Engine has the following rules
				and limitations:
			</para>
			
			<itemizedlist>
				<listitem><para>Avoid using the session for storage, usual App Engine
				limitations apply (no synchronization, that is, it is
				unreliable).</para></listitem>

				<listitem><para>Vaadin uses memcache for mutex, the key is of the form
				<parameter>_vmutex&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para>The Vaadin <classname>WebApplicationContext</classname>
				class is serialized separately into memcache and datastore; the memcache
				key is <parameter>_vac&lt;sessionid&gt;</parameter> and the datastore
				entity kind is <parameter>_vac</parameter> with identifiers of the type
				<parameter>_vac&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para><emphasis>Do not</emphasis> update the application state when serving an
				<classname>ConnectorResource</classname> (such as
				<classname>ClassResource</classname>.<methodname>getStream()</methodname>).</para></listitem>

				<listitem><para><emphasis>Avoid</emphasis> (or be very careful when)
				updating application state in a <classname>TransactionListener</classname>
				- it is called even when the application is not locked and won't be
				serialized (such as with <classname>ConnectorResource</classname>), and
				changes can therefore be lost (it should be safe to update things that can
				be safely discarded later, that is, valid only for the current
				request).</para></listitem>

				<listitem><para>The application remains locked during uploads - a progress
				bar is not possible.</para></listitem>
			</itemizedlist>
		</simplesect>
	</section>

	<section xml:id="advanced.security">
		<title>Common Security Issues</title>

		<section xml:id="advanced.security.sanitizing">
			<title>Sanitizing User Input to Prevent Cross-Site Scripting</title>
			
			<para>
				You can put raw HTML content in many components, such as the
				<classname>Label</classname> and <classname>CustomLayout</classname>, as
				well as in tooltips and notifications. In such cases, you should make sure
				that if the content has any possibility to come from user input, you must
				make sure that the content is safe before displaying it. Otherwise, a
				malicious user can easily make a <link
				xlink:href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site
				scripting attack</link> by injecting offensive JavaScript code in such
				components. See other sources for more information about cross-site
				scripting.
			</para>

			<para>
				Offensive code can easily be injected with
				<literal>&lt;script&gt;</literal> markup or in tag attributes as events,
				such as <parameter>onLoad</parameter>. <!-- TODO Consider an example,
				Alice, Bob, etc. --> Cross-site scripting vulnerabilities are browser
				dependent, depending on the situations in which different browsers execute
				scripting markup.
			</para>

			<para>
				Therefore, if the content created by one user is shown to other users, the
				content must be sanitized. There is no generic way to sanitize user input,
				as different applications can allow different kinds of input. Pruning
				(X)HTML tags out is somewhat simple, but some applications may need to
				allow (X)HTML content. It is therefore the responsibility of the
				application to sanitize the input.
			</para>

			<para>
				Character encoding can make sanitization more difficult, as offensive tags
				can be encoded so that they are not recognized by a sanitizer. This can be
				done, for example, with HTML character entities and with variable-width
				encodings such as UTF-8 or various CJK encodings, by abusing multiple
				representations of a character. Most trivially, you could input
				<literal>&lt;</literal> and <literal>&gt;</literal> with
				<literal>&amp;lt;</literal> and <literal>&amp;gt;</literal>,
				respectively. The input could also be malformed and the sanitizer must be
				able to interpret it exactly as the browser would, and different browsers
				can interpret malformed HTML and variable-width character encodings
				differently.
			</para>

			<para>
				Notice that the problem applies also to user input from a
				<classname>RichTextArea</classname> is transmitted as HTML from the
				browser to server-side and is not sanitized. As the entire purpose of the
				<classname>RichTextArea</classname> component is to allow input of
				formatted text, you can not just remove all HTML tags. Also many
				attributes, such as <parameter>style</parameter>, should pass through the
				sanitization.
			</para>

			<!-- NOTE: Document the rude HTML sanitization method when #3382 is closed. -->
		</section>
	</section>

	<section xml:id="advanced.navigator">
		<title>Navigating in an Application</title>

        <para>
            Plain Vaadin applications do not have normal web page navigation as they
            usually run on a single page, as all Ajax applications do. Quite commonly,
            however, applications have different views between which the user should be
            able to navigate. The <classname>Navigator</classname> in Vaadin can be used
            for most cases of navigation. Views managed by the navigator automatically get
            a distinct URI fragment, which can be used to be able to bookmark the views
            and their states and to go back and forward in the browser history.
        </para>

        <section xml:id="advanced.navigator.navigating">
            <title>Setting Up for Navigation</title>

            <para>
                The <classname>Navigator</classname> class manages a collection of
                <emphasis>views</emphasis> that implement the
                <interfacename>View</interfacename> interface. The views can be either
                registered beforehand or acquired from a <emphasis>view
                provider</emphasis>.  When registering, the views must have a name
                identifier and be added to a navigator with
                <methodname>addView()</methodname>. You can register new views at any
                point. Once registered, you can navigate to them with
                <methodname>navigateTo()</methodname>.
            </para>

            <para>
                <classname>Navigator</classname> manages navigation in a component
                container, which can be either a
                <interfacename>ComponentContainer</interfacename> (most layouts) or a
                <interfacename>SingleComponentContainer</interfacename>
                (<classname>UI</classname>, <classname>Panel</classname>, or
                <classname>Window</classname>). The component container is managed through
                a <interfacename>ViewDisplay</interfacename>. Two view displays are
                defined: <classname>ComponentContainerViewDisplay</classname> and
                <classname>SingleComponentContainerViewDisplay</classname>, for the
                respective component container types. Normally, you can let the navigator
                create the view display internally, as we do in the example below, but you
                can also create it yourself to customize it.
            </para>

            <para>
                Let us consider the following UI with two views: start and main. Here, we
                define their names with enums to be typesafe. We manage the navigation
                with the UI class itself, which is a
                <interfacename>SingleComponentContainer</interfacename>.
            </para>

            <book-example eid="advanced.navigator.basic" style="float: right"/>
            <programlisting><![CDATA[public class NavigatorUI extends UI {
    Navigator navigator;
    protected static final String MAINVIEW = "main";

    @Override
    protected void init(VaadinRequest request) {
        getPage().setTitle("Navigation Example");
        
        // Create a navigator to control the views
        navigator = new Navigator(this, this);
        
        // Create and register the views
        navigator.addView("", new StartView());
        navigator.addView(MAINVIEW, new MainView());
    }
}]]></programlisting>

            <para>
                The <classname>Navigator</classname> automatically sets the URI fragment
                of the application URL.  It also registers a
                <interfacename>URIFragmentChangedListener</interfacename> in the page <phrase condition="web">(see
                <xref linkend="advanced.urifu"/>)</phrase> to show the view identified by the URI
                fragment if entered or navigated to in the browser. This also enables
                browser navigation history in the application.
            </para>

            <section xml:id="advanced.navigator.navigating.viewprovider">
                <title>View Providers</title>

                <para>
                    You can create new views dynamically using a <emphasis>view
                    provider</emphasis> that implements the
                    <interfacename>ViewProvider</interfacename> interface. A provider is
                    registered in <classname>Navigator</classname> with
                    <methodname>addProvider()</methodname>.
                </para>

                <para>
                    The <methodname>ClassBasedViewProvider</methodname> is a view provider
                    that can dynamically create new instances of a specified view class
                    based on the view name.
                </para>

                <para>
                    The <methodname>StaticViewProvider</methodname> returns an existing
                    view instance based on the view name. The
                    <methodname>addView()</methodname> in <classname>Navigator</classname>
                    is actually just a shorthand for creating a static view provider for
                    each registered view.
                </para>
           </section>

            <section xml:id="advanced.navigator.navigating.viewchangelistener">
                <title>View Change Listeners</title>

                <para>
                    You can handle view changes also by implementing a
                    <interfacename>ViewChangeListener</interfacename> and adding it to a
                    <classname>Navigator</classname>. When a view change occurs, a
                    listener receives a <classname>ViewChangeEvent</classname> object,
                    which has references to the old and the activated view, the name of
                    the activated view, as well as the fragment parameters.
                </para>
            </section>
        </section>

        <section xml:id="advanced.navigator.view">
            <title>Implementing a View</title>

            <para>
                Views can be any objects that implement the
                <interfacename>View</interfacename> interface. When the
                <methodname>navigateTo()</methodname> is called for the navigator, or the
                application is opened with the URI fragment associated with the view, the
                navigator switches to the view and calls its
                <methodname>enter()</methodname> method.
            </para>

            <para>
                To continue with the example, consider the following simple start view
                that just lets the user to navigate to the main view. It only pops up a
                notification when the user navigates to it and displays the navigation
                button.
            </para>

            <book-example eid="advanced.navigator.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[/** A start view for navigating to the main view */
public class StartView extends VerticalLayout implements View {
    public StartView() {
        setSizeFull();

        Button button = new Button("Go to Main View",
                new Button.ClickListener() {
            @Override
            public void buttonClick(ClickEvent event) {
                navigator.navigateTo(MAINVIEW);
            }
        });
        addComponent(button);
        setComponentAlignment(button, Alignment.MIDDLE_CENTER);
    }        
        
    @Override
    public void enter(ViewChangeEvent event) {
        Notification.show("Welcome to the Animal Farm");
    }
}]]></programlisting>

            <para>
                You can initialize the view content in the constructor, as was done in the
                example above, or in the <methodname>enter()</methodname> method. The
                advantage with the latter method is that the view is attached to the view
                container as well as to the UI at that time, which is not the case in the
                constructor.
            </para>
        </section>

        <section xml:id="advanced.navigator.urifragment">
            <title>Handling URI Fragment Path</title>

            <para>
                URI fragment part of a URL is the part after a hash <literal>#</literal>
                character. Is used for within-UI URLs, because it is the only part of the
                URL that can be changed with JavaScript from within a page without
                reloading the page. The URLs with URI fragments can be used for
                hyperlinking and bookmarking, as well as browser history, just like any
                other URLs. In addition, an exclamation mark <literal>#!</literal> after
                the hash marks that the page is a stateful AJAX page, which can be crawled
                by search engines. Crawling requires that the application also responds to
                special URLs to get the searchable content. URI fragments are managed by
                <classname>Page</classname>, which provides a low-level API.
            </para>

            <para>
                URI fragments can be used with <classname>Navigator</classname> in two
                ways: for navigating to a view and to a state within a view. The URI
                fragment accepted by <methodname>navigateTo()</methodname> can have the
                view name at the root, followed by fragment parameters after a slash
                ("<literal>/</literal>"). These parameters are passed to the
                <methodname>enter()</methodname> method in the
                <interfacename>View</interfacename>.
            </para>

            <para>
                In the following example, we implement within-view navigation.
            </para>

            <book-example eid="advanced.navigator.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[/** Main view with a menu */
public class MainView extends VerticalLayout implements View {
    Panel panel;

    // Menu navigation button listener
    class ButtonListener implements Button.ClickListener {

        String menuitem;
        public ButtonListener(String menuitem) {
            this.menuitem = menuitem;
        }

        @Override
        public void buttonClick(ClickEvent event) {
            // Navigate to a specific state
            navigator.navigateTo(MAINVIEW + "/" + menuitem);
        }
    }

    public MainView() {
        setSizeFull();
        
        // Layout with menu on left and view area on right
        HorizontalLayout hLayout = new HorizontalLayout();
        hLayout.setSizeFull();

        // Have a menu on the left side of the screen
        Panel menu = new Panel("List of Equals");
        menu.setHeight("100%");
        menu.setWidth(null);
        VerticalLayout menuContent = new VerticalLayout();
        menuContent.addComponent(new Button("Pig",
                  new ButtonListener("pig")));
        menuContent.addComponent(new Button("Cat",
                  new ButtonListener("cat")));
        menuContent.addComponent(new Button("Dog",      
                  new ButtonListener("dog")));
        menuContent.addComponent(new Button("Reindeer",
                  new ButtonListener("reindeer")));
        menuContent.addComponent(new Button("Penguin",
                  new ButtonListener("penguin")));
        menuContent.addComponent(new Button("Sheep",
                  new ButtonListener("sheep")));
        menuContent.setWidth(null);
        menuContent.setMargin(true);
        menu.setContent(menuContent);
        hLayout.addComponent(menu);

        // A panel that contains a content area on right
        panel = new Panel("An Equal");
        panel.setSizeFull();
        hLayout.addComponent(panel);
        hLayout.setExpandRatio(panel, 1.0f);

        addComponent(hLayout);
        setExpandRatio(hLayout, 1.0f);
        
        // Allow going back to the start
        Button logout = new Button("Logout",
                   new Button.ClickListener() {
            @Override
            public void buttonClick(ClickEvent event) {
                navigator.navigateTo("");
            }
        });
        addComponent(logout);
    }        
    
    @Override
    public void enter(ViewChangeEvent event) {
        VerticalLayout panelContent = new VerticalLayout();
        panelContent.setSizeFull();
        panelContent.setMargin(true);
        panel.setContent(panelContent); // Also clears

        if (event.getParameters() == null
            || event.getParameters().isEmpty()) {
            panelContent.addComponent(
                new Label("Nothing to see here, " +
                          "just pass along."));
            return;
        }

        // Display the fragment parameters
        Label watching = new Label(
            "You are currently watching a " +
            event.getParameters());
        watching.setSizeUndefined();
        panelContent.addComponent(watching);
        panelContent.setComponentAlignment(watching,
            Alignment.MIDDLE_CENTER);
        
        // Some other content
        Embedded pic = new Embedded(null,
            new ThemeResource("img/" + event.getParameters() +
                              "-128px.png"));
        panelContent.addComponent(pic);
        panelContent.setExpandRatio(pic, 1.0f);
        panelContent.setComponentAlignment(pic,
                Alignment.MIDDLE_CENTER);

        Label back = new Label("And the " +
            event.getParameters() + " is watching you");
        back.setSizeUndefined();
        panelContent.addComponent(back);
        panelContent.setComponentAlignment(back,
            Alignment.MIDDLE_CENTER);
    }
}]]></programlisting>

            <para>
                The main view is shown in <xref
                    linkend="figure.advanced.navigator.mainview"/>. At this point, the URL would
                be <literal>http://localhost:8080/myapp#!main/reindeer</literal>.
            </para>

            <figure xml:id="figure.advanced.navigator.mainview">
                <title>Navigator Main View</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/advanced/navigator-mainview.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
    </section>

    <section xml:id="advanced.architecture">
        <title>Advanced Application Architectures</title>
        
        <para>
            In this section, we continue from the basic application architectures
            described in <xref linkend="application.architecture"/> and discuss some of
            the more advanced patterns that are often used in Vaadin applications.
        </para>

        <section xml:id="advanced.architecture.layering">
            <title>Layered Architectures</title>

            <para>
                Layered architectures, where each layer has a clearly distinct
                responsibility, are probably the most common architectures. Typically,
                applications follow at least a three-layer architecture:
            </para>

            <itemizedlist>
                <listitem>User interface (or presentation) layer</listitem>
                <listitem>Domain layer</listitem>
                <listitem>Data store layer</listitem>
            </itemizedlist>

            <para>
                Such an architecture starts from a <emphasis>domain model</emphasis>,
                which defines the data model and the "business logic" of the application,
                typically as POJOs. A user interface is built on top of the domain model,
                in our context with the Vaadin Framework. The Vaadin user interface could
                be bound directly to the data model through the Vaadin Data Model,
                described in <xref linkend="datamodel"/>. Beneath the domain model lies a
                data store, such as a relational database. The dependencies between the
                layers are restricted so that a higher layer may depend on a lower one,
                but never the other way around.
            </para>

            <figure xml:id="figure.advanced.architecture.layering">
                <title>Three-Layer Architecture</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/jpacontainer/three-layer-architecture-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/three-layer-architecture-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            
            <para>
                An <emphasis>application layer</emphasis> (or <emphasis>service
                layer</emphasis>) is often distinguished from the domain layer, offering
                the domain logic as a service, which can be used by the user interface
                layer, as well as for other uses. In Java EE development, Enterprise
                JavaBeans (EJBs) are typically used for building this layer.
            </para>

            <para>
                An <emphasis>infrastructure layer</emphasis> (or <emphasis>data access
                layer</emphasis>) is often distinguished from the data store layer, with a
                purpose to abstract the data store. For example, it could involve a
                persistence solution such as JPA and an EJB container. This layer becomes
                relevant with Vaadin when binding Vaadin components to data with the
                JPAContainer, as described in <xref linkend="jpacontainer"/>.
            </para>
        </section>

        <section xml:id="advanced.architecture.mvp">
            <title>Model-View-Presenter Pattern</title>

            <para>
                The Model-View-Presenter (MVP) pattern is one of the most common patterns
                in developing large applications with Vaadin. It is similar to the older
                Model-View-Controller (MVC) pattern, which is not as meaningful in Vaadin
                development. Instead of an implementation-aware controller, there is an
                implementation-agnostic presenter that operates the view through an
                interface. The view does not interact directly with the model. This
                isolates the view implementation better than in MVC and allows easier unit
                testing of the presenter and model.
            </para>

            <figure xml:id="figure.advanced.architecture.mvp">
                <title>Model-View-Presenter Pattern</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/application/mvp-pattern-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/application/mvp-pattern-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                <xref linkend="figure.advanced.architecture.mvp"/> illustrates the MVP
                pattern with a simple calculator. The domain model is realized in the
                <classname>Calculator</classname> class, which includes a data model and
                some model logic operations. The <classname>CalculatorViewImpl</classname>
                is a Vaadin implementation of the view, defined in the
                <interfacename>CalculatorView</interfacename> interface. The
                <classname>CalculatorPresenter</classname> handles the user interface
                logic. User interaction events received in the view are translated into
                implementation-independent events for the presenter to handle (the view
                implementation could also just call the presenter).
            </para>

            <para>
                Let us first look how the model and view are bound together by the
                presenter in the following example:
            </para>
        
            <programlisting><?pocket-size 65% ?><![CDATA[
// Create the model and the Vaadin view implementation
CalculatorModel    model = new CalculatorModel();
CalculatorViewImpl view  = new CalculatorViewImpl();
    
// The presenter binds the model and view together
new CalculatorPresenter(model, view);
    
// The view implementation is a Vaadin component
layout.addComponent(view);]]></programlisting>

            <para>
                You could add the view anywhere in a Vaadin application, as it is a
                composite component.
            </para>

            <section xml:id="advanced.architecture.mvp.model">
                <title>The Model</title>

                <para>
                    Our business model is quite simple, with one value and a number of
                    operations for manipulating it.
                </para>
    
                <programlisting><?pocket-size 65% ?><![CDATA[/** The model **/
class CalculatorModel {
    private double value = 0.0;
    
    public void clear() {
        value = 0.0;
    }

    public void add(double arg) {
        value += arg;
    }

    public void multiply(double arg) {
        value *= arg;
    }

    public void divide(double arg) {
        if (arg != 0.0)
            value /= arg;
    }
    
    public double getValue() {
        return value;
    }
    
    public void setValue(double value) {
        this.value = value;
    }
}]]></programlisting>
            </section>

            <section xml:id="advanced.architecture.mvp.view">
                <title>The View</title>
                
                <para>
                    The purpose of the view in MVP is to display data and receive user
                    interaction. It relays the user interaction to the presenter in an
                    fashion that is independent of the view implementation, that is, no
                    Vaadin events.  It is defined as a UI framework interface that can
                    have multiple implementations.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[interface CalculatorView {
    public void setDisplay(double value);

    interface CalculatorViewListener {
        void buttonClick(char operation);
    }
    public void addListener(CalculatorViewListener listener);
}]]></programlisting>

                <para>
                    The are design alternatives for the view. It could receive the
                    listener in its constructor, or it could just know the
                    presenter. Here, we forward button clicks as an
                    implementation-independent event.
                </para>

                <para>
                    As we are using Vaadin, we make a Vaadin implementation of the
                    interface as follows:
                </para>
    
                <programlisting><?pocket-size 65% ?><![CDATA[class CalculatorViewImpl extends CustomComponent
        implements CalculatorView, ClickListener {
    private Label display = new Label("0.0");

    public CalculatorViewImpl() {
        GridLayout layout  = new GridLayout(4, 5);

        // Create a result label that spans over all
        // the 4 columns in the first row
        layout.addComponent(display, 0, 0, 3, 0);
    
        // The operations for the calculator in the order
        // they appear on the screen (left to right, top
        // to bottom)
        String[] operations = new String[] {
            "7", "8", "9", "/", "4", "5", "6",
            "*", "1", "2", "3", "-", "0", "=", "C", "+" };

        // Add buttons and have them send click events
        // to this class
        for (String caption: operations)
            layout.addComponent(new Button(caption, this));

        setCompositionRoot(layout);
    }
    
    public void setDisplay(double value) {
        display.setValue(Double.toString(value));
    }

    /* Only the presenter registers one listener... */
    List<CalculatorViewListener> listeners =
            new ArrayList<CalculatorViewListener>();

    public void addListener(CalculatorViewListener listener) {
        listeners.add(listener);
    }

    /** Relay button clicks to the presenter with an
     *  implementation-independent event */
    @Override
    public void buttonClick(ClickEvent event) {
        for (CalculatorViewListener listener: listeners)
            listener.buttonClick(event.getButton()
                                 .getCaption().charAt(0));
    }
}]]></programlisting>
            </section>

        <section xml:id="advanced.architecture.mvp.presenter">
                <title>The Presenter</title>

                <para>
                    The presenter in MVP is a middle-man that handles all user interaction
                    logic, but in an implementation-independent way, so that it doesn't
                    actually know anything about Vaadin. It shows data in the view and
                    receives user interaction back from it.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[class CalculatorPresenter
        implements CalculatorView.CalculatorViewListener {
    CalculatorModel model;
    CalculatorView  view;

    private double current = 0.0;
    private char   lastOperationRequested = 'C';
    
    public CalculatorPresenter(CalculatorModel model,
                               CalculatorView  view) {
        this.model = model;
        this.view  = view;
        
        view.setDisplay(current);            
        view.addListener(this);
    }

    @Override
    public void buttonClick(char operation) {
        // Handle digit input
        if ('0' <= operation && operation <= '9') {
            current = current * 10
                    + Double.parseDouble("" + operation);
            view.setDisplay(current);
            return;
        }

        // Execute the previously input operation
        switch (lastOperationRequested) {
        case '+':
            model.add(current);
            break;
        case '-':
            model.add(-current);
            break;
        case '/':
            model.divide(current);
            break;
        case '*':
            model.multiply(current);
            break;
        case 'C':
            model.setValue(current);
            break;
        } // '=' is implicit

        lastOperationRequested = operation;

        current = 0.0;
        if (operation == 'C')
            model.clear();
        view.setDisplay(model.getValue());
    }
}]]></programlisting>

                <para>
                    In the above example, we held some state information in the
                    presenter. Alternatively, we could have had an intermediate controller
                    between the presenter and the model to handle the low-level button
                    logic.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="advanced.urifu">
        <title>Managing URI Fragments</title>

        <para>
            A major issue in AJAX applications is that as they run in a single web page,
            bookmarking the application URL (or more generally the
            <emphasis>URI</emphasis>) can only bookmark the application, not an
            application state. This is a problem for many applications, such as product
            catalogs and discussion forums, in which it would be good to provide links to
            specific products or messages. Consequently, as browsers remember the browsing
            history by URI, the history and the <guibutton>Back</guibutton> button do not
            normally work. The solution is to use the <emphasis>fragment
            identifier</emphasis> part of the URI, which is separated from the primary
            part (address + path + optional query parameters) of the URI with the hash (#)
            character. For example:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[http://example.com/path#myfragment]]></programlisting>

        <para>
            The exact syntax of the fragment identifier part is defined in RFC 3986
            (Internet standard STD 66) that defines the URI syntax. A fragment may only
            contain the regular URI <emphasis>path characters</emphasis> (see the
            standard) and additionally the slash and the question mark.
        </para>

        <para>
            Vaadin offers two ways to enable the use of URI fragments: the high-level
            <classname>Navigator</classname> utility described in <xref
            linkend="advanced.navigator"/> and the low-level API described here.
        </para>

        <section xml:id="advanced.urifu.setting">
            <title>Setting the URI Fragment</title>

            <para>
                You can set the current fragment identifier with the
                <methodname>setUriFragment()</methodname> method in the
                <classname>Page</classname> object.
            </para>

            <programlisting><![CDATA[Page.getCurrent().setUriFragment("mars");]]></programlisting>

            <para>
                Setting the URI fragment causes an
                <interfacename>UriFragmentChangeEvent</interfacename>, which is processed
                in the same server request. As with UI rendering, the URI fragment is
                changed in the browser after the currently processed server request
                returns the response.
            </para>

            <para>
                Prefixing the fragment identifier with an exclamation mark enables the web
                crawler support described in <xref linkend="advanced.urifu.crawling"/>.
            </para>
        </section>

        <section xml:id="advanced.urifu.reading">
            <title>Reading the URI Fragment</title>

            <para>
                The current URI fragment can be acquired with the
                <methodname>getUriFragment()</methodname> method from the current
                <classname>Page</classname> object. The fragment is known when the
                <methodname>init()</methodname> method of the UI is called.
            </para>

            <book-example eid="advanced.urifragment.basic" style="float: right"></book-example>
            <programlisting><![CDATA[// Read initial URI fragment to create UI content
String fragment = getPage().getUriFragment();
enter(fragment);]]></programlisting>

            <para>
                To enable reusing the same code when the URI fragment is changed, as
                described next, it is usually best to build the relevant part of the UI in
                a separate method. In the above example, we called an
                <methodname>enter()</methodname> method, in a way that is similar to
                handling view changes with <classname>Navigator</classname>.
            </para>
        </section>

        <section xml:id="advanced.urifu.listening">
            <title>Listening for URI Fragment Changes</title>

            <para>
                After the UI has been initialized, changes in the URI fragment can be
                handled with a <interfacename>UriFragmentChangeListener</interfacename>.
                The listeners are called when the URI fragment changes, but not when the
                UI is initialized, where the current fragment is available from the page
                object as described earlier.
            </para>

            <para>
                For example, we could define the listener as follows in the
                <methodname>init()</methodname> method of a UI class:
            </para>

            <book-example eid="advanced.urifragment.basic" style="float: right"></book-example>
            <programlisting><![CDATA[public class MyUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        getPage().addUriFragmentChangedListener(
               new UriFragmentChangedListener() {
           public void uriFragmentChanged(
                   UriFragmentChangedEvent source) {
               enter(source.getUriFragment());
            }
        });

        // Read the initial URI fragment
        enter(getPage().getUriFragment());
    }

    void enter(String fragment) {
        ... initialize the UI ...
    }
}]]></programlisting>

            <para>
                <xref linkend="figure.advanced.urifu"/> shows an application that allows
                specifying the menu selection with a URI fragment and correspondingly sets
                the fragment when the user selects a menu item.
            </para>

            <figure xml:id="figure.advanced.urifu">
                <title>Application State Management with URI Fragment Utility</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/urifu-1.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/urifu-1.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="advanced.urifu.crawling">
            <title>Supporting Web Crawling</title>

            <para>
                Stateful AJAX applications can not normally be crawled by a search engine,
                as they run in a single page and a crawler can not navigate the states
                even if URI fragments are enabled. The Google search engine and crawler
                <link
                xlink:href="http://googlewebmastercentral.blogspot.fi/2009/10/proposal-for-making-ajax-crawlable.html">support
                a convention</link> where the fragment identifiers are prefixed with
                exclamation mark, such as <literal>#!myfragment</literal>. The servlet
                needs to have a separate searchable content page accessible with the same
                URL, but with a <literal>_escaped_fragment_</literal> parameter. For
                example, for <literal>/myapp/myui#!myfragment</literal> it would be
                <literal>/myapp/myui?_escaped_fragment_=myfragment</literal>.
            </para>

            <para>
                You can provide the crawl content by overriding the
                <methodname>service()</methodname> method in a custom servlet class. For
                regular requests, you should call the super implementation in the
                <classname>VaadinServlet</classname> class.
            </para>

            <book-example eid="advanced.urifragment.basic" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[public class MyCustomServlet extends VaadinServlet
    @Override
    protected void service(HttpServletRequest request,
                           HttpServletResponse response)
            throws ServletException, IOException {
        String fragment = request
            .getParameter("_escaped_fragment_");
        if (fragment != null) {
            response.setContentType("text/html");
            Writer writer = response.getWriter();
            writer.append("<html><body>"+
                "<p>Here is some crawlable "+
                "content about " + fragment + "</p>");
            
            // A list of all crawlable pages
            String items[] = {"mercury", "venus",
                              "earth", "mars"};
            writer.append("<p>Index of all content:</p><ul>");
            for (String item: items) {
                String url = request.getContextPath() +
                    request.getServletPath() +
                    request.getPathInfo() + "#!" + item;
                writer.append("<li><a href='" + url + "'>" +
                              item + "</a></li>");
            }
            writer.append("</ul></body>");
        } else
            super.service(request, response);
    }
}]]></programlisting>

            <para>
                The crawlable content does not need to be human readable. It can provide
                an index of links to other application states, as we did in the example
                above. The links should use the "<literal>#!</literal>" notation, but can
                not be relative to avoid having the <literal>_escaped_fragment_</literal>
                parameter.
            </para>

            <para>
                You need to use the custom servlet class in the
                <filename>web.xml</filename> deployment descriptor instead of the normal
                <classname>VaadinServlet</classname> class, as described in <xref
                linkend="application.environment.web-xml"/>.
            </para>
        </section>
    </section>

    <!-- TODO Vaadin 7: Rewrite 
    <section xml:id="advanced.httpservletrequestlistener">
        <title>Capturing HTTP Requests</title>

        <indexterm xml:id="term.advanced.httpservletrequestlistener" class="startofrange">
            <primary>HttpServletRequestListener</primary>
        </indexterm>

        <para>
            Behind the event-driven processing model of Vaadin lies the Java Servlet API,
            which is based on processing HTTP requests. These requests are normally
            hidden from Vaadin applications, but can be caught using the
            <classname>HttpServletRequestListener</classname> interface. You must
            implement the interface in your application class. The two methods defined in
            the interface, <methodname>onRequestStart()</methodname> and
            <methodname>onRequestEnd()</methodname>, allow processing the request before
            and after other processing.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.vaadin.Application;
import com.vaadin.terminal.gwt.server.HttpServletRequestListener;
import com.vaadin.ui.*;

public class HttpServletRequestApplication extends Application
       implements HttpServletRequestListener {

    @Override
    public void init() {
        System.out.println("  Application.init() called.");
        
        Window main = new Window("URI Fragment Example");
        setMainWindow(main);
                
        // Does nothing but causes a request
        Button button = new Button ("Make a request");
        main.addComponent(button);
    }

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        System.out.println("[Start of request");
        System.out.println(" Query string: " +
                           request.getQueryString());
        System.out.println(" Path: " +
                           request.getPathInfo());
    }

    public void onRequestEnd(HttpServletRequest request,
                             HttpServletResponse response) {
        System.out.println(" End of request]");
    }
}]]></programlisting>

        <para>
            The <methodname>onRequestStart()</methodname> is called for the first time
            when the application class is loaded but the <methodname>init()</methodname>
            is not yet called. This can be seen in the output of the above code example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[[Start of request
 Query string: null
 Path: null
  Application.init() called.
 End of request]
[Start of request
 Query string: repaintAll=1&sh=1050&sw=1680&cw=500&ch=300&vw=500
 Path: /UIDL/
 End of request]
[Start of request
 Query string: windowName=1071684214
 Path: /UIDL/
 End of request]]]></programlisting>

        <para>
            The first call is a regular HTML page load, so the URL path is simply the
            application path. The subsequent calls are AJAX calls made using the UIDL
            protocol, so the request path includes the <literal>/UIDL/</literal> part. This is
            important to know when using cookies, as explained later.
        </para>

        <section>
            <title>Using Request and Response Objects</title>

            <indexterm xml:id="term.advanced.httpservletrequestlistener.httpservletrequest" class="startofrange">
                <primary>HttpServletRequest</primary>
            </indexterm>
            <indexterm xml:id="term.advanced.httpservletrequestlistener.httpservletresponse" class="startofrange">
                <primary>HttpServletResponse</primary>
            </indexterm>
            
            <para>
                The <classname>HttpServletRequest</classname> object provides access to
                the request data, such as request headers, path info, and query string, as
                well as to some higher-level information such as cookies.
            </para>

            <para>
                The <classname>HttpServletResponse</classname> object is somewhat
                different, as most write operations write data directly to the output
                stream of the server request. It is therefore possible to add new headers
                and cookies in the <methodname>onRequestStart()</methodname>, and make
                other settings, but not later on, especially not in the
                <methodname>onRequestEnd()</methodname>, as all the UIDL response data has
                already been written to the output stream. The framework writes the UIDL
                response to the output stream of the response <emphasis>before</emphasis>
                calling <methodname>onRequestEnd()</methodname>. You therefore have to be
                careful when writing to the response object. You can usually write to it
                when handling component events in listeners, as is done in the cookie
                example later.
            </para>

            <para>
                While it is theoretically possible to redirect the output stream of the
                response object to write custom data to the response, you should never
                need to do that, as it would break the UIDL communication protocol.
            </para>
        
            <para>
                The servlet request and response objects are defined in the Java Servlet
                API. Please refer to its documentation for more detailed information.
            </para>

            <indexterm startref="term.advanced.httpservletrequestlistener.httpservletrequest" class="endofrange"/>
            <indexterm startref="term.advanced.httpservletrequestlistener.httpservletresponse" class="endofrange"/>
        </section>

        <section>
            <title>Managing Cookies</title>

            <indexterm xml:id="term.advanced.httpservletrequestlistener.cookies" class="startofrange">
                <primary>cookies</primary>
            </indexterm>

            <para>
                Setting and reading cookies is one of the typical uses of
                <classname>HttpServletRequestListener</classname>. The application gets
                the <classname>HttpServletRequest</classname> object containing the
                cookies in the <methodname>onRequestStart()</methodname> method.
            </para>

            <section>
                <title>Setting a Cookie</title>

                <para>
                    You normally set a cookie in an event listener. As the request object
                    is a transient object that exists only for the duration of the
                    request, it is not accessible from the
                    <classname>Application</classname> object. The only way to access it
                    is to store it in <methodname>onRequestStart()</methodname>, as done
                    in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    HttpServletResponse response;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        // Store the reference to the response object for
        // using it in event listeners
        this.response = response;
        ...
   }
   ...]]></programlisting>

                <para>
                    We can then use the reference to set or delete cookies in event
                    listeners. Notice that the <emphasis>cookie path</emphasis> property
                    is automatically set to the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent calls
                    (such as <filename>/book-examples/cookies/UIDL</filename>). As the
                    cookies are matched against this path, you may need to set the path
                    explicitly with <methodname>setPath()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[newuser = new TextField ("Give a user name");
login = new Button("Login");
login.addClickListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        Object value = newuser.getValue(); 
        if (value != null &&
            ! "".equals((String)value)) {
            username = (String) value;

            Cookie cookie = new Cookie("username",
                                       username);
            // Use a fixed path
            cookie.setPath("/book-examples");
            cookie.setMaxAge(3600); // One hour
            response.addCookie(cookie);
            System.out.println("Set cookie.");

            newuser.setEnabled(false);
            login.setEnabled(false);
            restart.setEnabled(true);
            logout.setEnabled(true);
        }
    }
});
loginrow.addComponent(newuser);
loginrow.addComponent(login);]]></programlisting>

                <para>
                    Removing cookie can be set in similar way by setting the
                    <emphasis>maxAge</emphasis> property to zero.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Delete the cookie
Cookie cookie = new Cookie("username", username);
cookie.setPath("/book-examples");
cookie.setMaxAge(0); // Delete
response.addCookie(cookie);]]></programlisting>
            </section>

            <section>
                <title>Reading a Cookie</title>

                <para>
                    Reading a cookie can be done in the
                    <methodname>onRequestStart()</methodname> event. As this method is
                    called also on the first client request before the application is
                    initialized, it is possible to read user identification cookies and
                    such on the first request.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    String username;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        if (username == null) {
            Cookie[] cookies = request.getCookies();
            for (int i=0; i<cookies.length; i++) {
                if ("username".equals(cookies[i].getName()))
                    // Log the user in automatically
                    username = cookies[i].getValue();
            }
        }
    }
    ...]]></programlisting>

                <para>
                    Notice that the request path is the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent AJAX
                    calls (such as <filename>/book-examples/cookies/UIDL</filename>). So,
                    if you have set the cookie in an AJAX request without setting the
                    cookie path explicitly to such that does not contain the
                    <filename>UIDL</filename> subpath, the cookie will be filtered out on
                    the initial <methodname>onRequestStart()</methodname> call.
                </para>
            </section>

            <indexterm startref="term.advanced.httpservletrequestlistener.cookies" class="endofrange"/>
        </section>

        <indexterm startref="term.advanced.httpservletrequestlistener" class="endofrange"/>
    </section>
    -->

    <section xml:id="advanced.dragndrop">
        <title>Drag and Drop</title>

        <indexterm xml:id="term.advanced.dragndrop" class="startofrange">
            <primary>Drag and Drop</primary>
        </indexterm>

        <para>
            Dragging an object from one location to another by grabbing it with mouse,
            holding the mouse button pressed, and then releasing the button to "drop" it
            to the other location is a common way to move, copy, or associate objects. For
            example, most operating systems allow dragging and dropping files between
            folders or dragging a document on a program to open it. In Vaadin, it is
            possible to drag and drop components and parts of certain components.
        </para>

        <para>
            Dragged objects, or <emphasis>transferables</emphasis>, are essentially data
            objects. You can drag and drop rows in <classname>Table</classname> and nodes
            in <classname>Tree</classname> components, either within or between the
            components. You can also drag entire components by wrapping them inside
            <classname>DragAndDropWrapper</classname>.
        </para>

        <para>
            Dragging starts from a <emphasis>drag source</emphasis>, which defines the
            transferable. Transferables implement the <classname>Transferable</classname>
            interfaces. For trees and tables, which are bound to
            <classname>Container</classname> data sources, a node or row transferable is a
            reference to an <classname>Item</classname> in the Vaadin Data Model. Dragged
            components are referenced with a
            <classname>WrapperTransferable</classname>. Starting dragging does not require
            any client-server communication, you only need to enable dragging. All drag
            and drop logic occurs in two operations: determining
            (<emphasis>accepting</emphasis>) where dropping is allowed and actually
            dropping. Drops can be done on a <emphasis>drop target</emphasis>, which
            implements the <classname>DropTarget</classname> interface. Three components
            implement the interface: <classname>Tree</classname>,
            <classname>Table</classname>, and
            <classname>DragAndDropWrapper</classname>. These accept and drop operations
            need to be provided in a <emphasis>drop handler</emphasis>. Essentially all
            you need to do to enable drag and drop is to enable dragging in the drag
            source and implement the <methodname>getAcceptCriterion()</methodname> and
            <methodname>drop()</methodname> methods in the
            <classname>DropHandler</classname> interface.
        </para>

        <para>
            The client-server architecture of Vaadin causes special requirements for the
            drag and drop functionality. The logic for determining where a dragged object
            can be dropped, that is, <emphasis>accepting</emphasis> a drop, should
            normally be done on the client-side, in the browser. Server communications are
            too slow to have much of such logic on the server-side. The drag and drop
            feature therefore offers a number of ways to avoid the server communications
            to ensure a good user experience.
        </para>

        <section xml:id="advanced.dragndrop.drophandler">
            <title>Handling Drops</title>

            <para>
                Most of the user-defined drag and drop logic occurs in a <emphasis>drop
                handler</emphasis>, which is provided by implementing the
                <methodname>drop()</methodname> method in the
                <classname>DropHandler</classname> interface. A closely related definition
                is the drop accept criterion, which is defined in the
                <methodname>getAcceptCriterion()</methodname> method in the same
                interface. It is described in <xref
                linkend="advanced.dragndrop.acceptcriteria"/> later.
            </para>

            <para>
                The <methodname>drop()</methodname> method gets a
                <classname>DragAndDropEvent</classname> as its parameters. The event
                object provides references to two important object:
                <classname>Transferable</classname> and
                <classname>TargetDetails</classname>.
            </para>

            <para>
                A <classname>Transferable</classname> contains a reference to the object
                (component or data item) that is being dragged. A tree or table item is
                represented as a <classname>TreeTransferable</classname> or
                <classname>TableTransferable</classname> object, which carries the item
                identifier of the dragged tree or table item. These special transferables,
                which are bound to some data in a container, are
                <classname>DataBoundTransferable</classname>. Dragged components are
                represented as <classname>WrapperTransferable</classname> objects, as the
                components are wrapped in a <classname>DragAndDropWrapper</classname>.
            </para>

            <para>
                The <classname>TargetDetails</classname> object provides information about
                the exact location where the transferable object is being dropped. The
                exact class of the details object depends on the drop target and you need
                to cast it to the proper subclass to get more detailed information. If the
                target is selection component, essentially a tree or a table, the
                <classname>AbstractSelectTargetDetails</classname> object tells the item
                on which the drop is being made. For trees, the
                <classname>TreeTargetDetails</classname> gives some more details. For
                wrapped components, the information is provided in a
                <classname>WrapperDropDetails</classname> object. In addition to the
                target item or component, the details objects provide a <emphasis>drop
                location</emphasis>. For selection components, the location can be
                obtained with the <methodname>getDropLocation()</methodname> and for
                wrapped components with <methodname>verticalDropLocation()</methodname>
                and <methodname>horizontalDropLocation()</methodname>. The locations are
                specified as either <classname>VerticalDropLocation</classname> or
                <classname>HorizontalDropLocation</classname> objects. The drop location
                objects specify whether the transferable is being dropped above, below, or
                directly on (at the middle of) a component or item.
            </para>

            <para>
                Dropping on a <classname>Tree</classname>, <classname>Table</classname>,
                and a wrapped component is explained further in the following sections.
            </para>
        </section>

        <section xml:id="advanced.dragndrop.treedrop">
            <title>Dropping Items On a <classname>Tree</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Tree</classname>. Making tree a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Tree</classname>
                currently supports only one drag mode,
                <literal>TreeDragMode.NODE</literal>, which allows dragging single tree
                nodes. While dragging, the dragged node is referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. The tree node is identified
                by the item ID of the container item.
            </para>

            <para>
                When a transferable is dropped on a tree, the drop location is stored in a
                <classname>TreeTargetDetails</classname> object, which identifies the
                target location by item ID of the tree node on which the drop is made. You
                can get the item ID with <methodname>getItemIdOver()</methodname> method
                in <classname>AbstractSelectTargetDetails</classname>, which the
                <classname>TreeTargetDetails</classname> inherits. A drop can occur
                directly on or above or below a node; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method.
            </para>

            <para>
                In the example below, we have a <classname>Tree</classname> and we allow
                reordering the tree items by drag and drop.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final Tree tree = new Tree("Inventory");
tree.setContainerDataSource(TreeExample.createTreeContent());
layout.addComponent(tree);
        
// Expand all items
for (Iterator<?> it = tree.rootItemIds().iterator(); it.hasNext();)
    tree.expandItemsRecursively(it.next());
        
// Set the tree in drag source mode
tree.setDragMode(TreeDragMode.NODE);
        
// Allow the tree to receive drag drops and handle them
tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }

    public void drop(DragAndDropEvent event) {
        // Wrapper for the object that is dragged
        Transferable t = event.getTransferable();
        
        // Make sure the drag source is the same tree
        if (t.getSourceComponent() != tree)
            return;
        
        TreeTargetDetails target = (TreeTargetDetails)
            event.getTargetDetails();

        // Get ids of the dragged item and the target item
        Object sourceItemId = t.getData("itemId");
        Object targetItemId = target.getItemIdOver();

        // On which side of the target the item was dropped 
        VerticalDropLocation location = target.getDropLocation();
        
        HierarchicalContainer container = (HierarchicalContainer)
        tree.getContainerDataSource();

        // Drop right on an item -> make it a child
        if (location == VerticalDropLocation.MIDDLE)
            tree.setParent(sourceItemId, targetItemId);

        // Drop at the top of a subtree -> make it previous
        else if (location == VerticalDropLocation.TOP) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
            container.moveAfterSibling(targetItemId, sourceItemId);
        }
        
        // Drop below another item -> make it next 
        else if (location == VerticalDropLocation.BOTTOM) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
        }
    }
});]]></programlisting>

            <section>
                <title>Accept Criteria for Trees</title>

                <para>
                    <classname>Tree</classname> defines some specialized accept
                    criteria for trees.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TargetInSubtree</classname> (client-side)</term>
                        <listitem>
                            Accepts if the target item is in the specified sub-tree. The
                            sub-tree is specified by the item ID of the root of the
                            sub-tree in the constructor. The second constructor includes a
                            depth parameter, which specifies how deep from the given root
                            node are drops accepted. Value <literal>-1</literal> means
                            infinite, that is, the entire sub-tree, and is therefore the
                            same as the simpler constructor.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemAllowsChildren</classname> (client-side)</term>
                        <listitem>
                            Accepts a drop if the tree has
                            <methodname>setChildrenAllowed()</methodname> enabled for the
                            target item. The criterion does not require parameters, so the
                            class is a singleton and can be acquired with
                            <methodname>Tree.TargetItemAllowsChildren.get()</methodname>. For
                            example, the following composite criterion accepts drops only
                            on nodes that allow children, but between all nodes:

                            <programlisting><?pocket-size 65% ?><![CDATA[return new Or (Tree.TargetItemAllowsChildren.get(), new Not(VerticalLocationIs.MIDDLE));]]></programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TreeDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops on only some items, which as specified by a set
                            of item IDs. You must extend the abstract class and implement
                            the <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target nodes is loaded only once
                            from the server for each drag operation. See <xref
                            linkend="advanced.dragndrop.acceptcriteria"/> for an example.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, the accept criteria defined in
                    <classname>AbstractSelect</classname> are available for a
                    <classname>Tree</classname>, as listed in <xref
                    linkend="advanced.dragndrop.acceptcriteria"/>.
                </para>
            </section>
            
        </section>

        <section xml:id="advanced.dragndrop.tabledrop">
            <title>Dropping Items On a <classname>Table</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Table</classname>. Making table a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Table</classname>
                supports dragging both single rows, with
                <literal>TableDragMode.ROW</literal>, and multiple rows, with
                <literal>TableDragMode.MULTIROW</literal>. While dragging, the dragged
                node or nodes are referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. Tree nodes are identified by
                the item IDs of the container items.
            </para>

            <para>
                When a transferable is dropped on a table, the drop location is stored in
                a <classname>AbstractSelectTargetDetails</classname> object, which
                identifies the target row by its item ID. You can get the item ID with
                <methodname>getItemIdOver()</methodname> method. A drop can occur directly
                on or above or below a row; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method from the details object.
            </para>

            <section>
                <title>Accept Criteria for Tables</title>

                <para>
                    <classname>Table</classname> defines one specialized accept
                    criterion for tables.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TableDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops only on (or above or below) items that are
                            specified by a set of item IDs. You must extend the abstract
                            class and implement the
                            <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target items is loaded only once
                            from the server for each drag operation.
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>

        <section xml:id="advanced.dragndrop.acceptcriteria">
            <title>Accepting Drops</title>

            <indexterm xml:id="term.advanced.dragndrop.acceptcriteria" class="startofrange">
                <primary>Drag and Drop</primary>
                <secondary>Accept Criteria</secondary>
            </indexterm>

            <para>
                You can not drop the objects you are dragging around just anywhere. Before
                a drop is possible, the specific drop location on which the mouse hovers
                must be <emphasis>accepted</emphasis>. Hovering a dragged object over an
                accepted location displays an <emphasis>accept indicator</emphasis>, which
                allows the user to position the drop properly. As such checks have to be
                done all the time when the mouse pointer moves around the drop targets, it
                is not feasible to send the accept requests to the server-side, so drops
                on a target are normally accepted by a client-side <emphasis>accept
                criterion</emphasis>.
            </para>

            <para>
                A drop handler must define the criterion on the objects which it accepts
                to be dropped on the target. The criterion needs to be provided in the
                <classname>getAcceptCriterion()</classname> method of the
                <classname>DropHandler</classname> interface. A criterion is represented
                in an <classname>AcceptCriterion</classname> object, which can be a
                composite of multiple criteria that are evaluated using logical
                operations. There are two basic types of criteria:
                <emphasis>client-side</emphasis> and <emphasis>server-side
                criteria</emphasis>. The various built-in criteria allow accepting drops
                based on the identity of the source and target components, and on the
                <emphasis>data flavor</emphasis> of the dragged objects.
            </para>

            <para>
                To allow dropping any transferable objects, you can return a universal
                accept criterion, which you can get with
                <methodname>AcceptAll.get()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    ...]]></programlisting>

            <section>
                <title>Client-Side Criteria</title>

                <para>
                    The <emphasis>client-side criteria</emphasis>, which inherit the
                    <classname>ClientSideCriterion</classname>, are verified on the
                    client-side, so server requests are not needed for verifying whether each
                    component on which the mouse pointer hovers would accept a certain object.
                </para>

                <para>
                    The following client-side criteria are define in
                    <package>com.vaadin.event.dd.acceptcriterion</package>:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptAll</classname></term>
                        <listitem>
                            Accepts all transferables and targets.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>And</classname></term>
                        <listitem>
                            Performs the logical AND operation on two or more client-side
                            criteria; accepts the transferable if all the given
                            sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>ContainsDataFlavour</classname></term>
                        <listitem>
                            The transferable must contain the defined data flavour.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Not</classname></term>
                        <listitem>
                            Performs the logical NOT operation on a client-side criterion;
                            accepts the transferable if and only if the sub-criterion does
                            not accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Or</classname></term>
                        <listitem>
                            Performs the logical OR operation on two or more client-side
                            criteria; accepts the transferable if any of the given
                            sub-criteria accepts it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIs</classname></term>
                        <listitem>
                            Accepts all transferables from any of the given source
                            components
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIsTarget</classname></term>
                        <listitem>
                            Accepts the transferable only if the source component is the
                            same as the target. This criterion is useful for ensuring that
                            items are dragged only within a tree or a table, and not from
                            outside it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetDetailIs</classname></term>
                        <listitem>
                            Accepts any transferable if the target detail, such as the
                            item of a tree node or table row, is of the given data flavor
                            and has the given value.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, target components such as <classname>Tree</classname> and
                    <classname>Table</classname> define some component-specific
                    client-side accept criteria. See <xref
                    linkend="advanced.dragndrop.treedrop"/> for more details.
                </para>

                <para>
                    <classname>AbstractSelect</classname> defines the following criteria
                    for all selection components, including <classname>Tree</classname>
                    and <classname>Table</classname>.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptItem</classname></term>
                        <listitem>
                            Accepts only specific items from a specific selection
                            component. The selection component, which must inherit
                            <classname>AbstractSelect</classname>, is given as the first
                            parameter for the constructor. It is followed by a list of
                            allowed item identifiers in the drag source.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>AcceptItem.ALL</classname></term>
                        <listitem>
                            Accepts all transferables as long as they are items.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemIs</classname></term>
                        <listitem>
                            Accepts all drops on the specified target items. The
                            constructor requires the target component
                            (<classname>AbstractSelect</classname>) followed by a list of
                            allowed item identifiers.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>VerticalLocationIs.MIDDLE</classname>,
                        <classname>TOP</classname>, and
                        <classname>BOTTOM</classname></term>
                        <listitem>
                            The three static criteria accepts drops on, above, or below an
                            item. For example, you could accept drops only in between
                            items with the following:

                            <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    return new Not(VerticalLocationIs.MIDDLE);
}]]></programlisting>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>

            <section>
                <title>Server-Side Criteria</title>

                <para>
                    The <emphasis>server-side criteria</emphasis> are verified on the
                    server-side with the <methodname>accept()</methodname> method of the
                    <classname>ServerSideCriterion</classname> class. This allows fully
                    programmable logic for accepting drops, but the negative side is that
                    it causes a very large amount of server requests. A request is made
                    for every target position on which the pointer hovers. This problem is
                    eased in many cases by the component-specific lazy loading criteria
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname>. They do the server visit
                    once for each drag and drop operation and return all accepted rows or 
                    nodes for current <classname>Transferable</classname> at once.
                </para>

                <para>
                    The <methodname>accept()</methodname> method gets the drag event as a
                    parameter so it can perform its logic much like in
                    <methodname>drop()</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any other
    // location except on nodes that may not have children
    ServerSideCriterion criterion = new ServerSideCriterion() {
        public boolean accept(DragAndDropEvent dragEvent) {
            TreeTargetDetails target = (TreeTargetDetails)
                dragEvent.getTargetDetails();

            // The tree item on which the load hovers
            Object targetItemId = target.getItemIdOver();

            // On which side of the target the item is hovered
            VerticalDropLocation location = target.getDropLocation();
            if (location == VerticalDropLocation.MIDDLE)
                if (! tree.areChildrenAllowed(targetItemId))
                    return false; // Not accepted

            return true; // Accept everything else
        }
    };
    return criterion;
}]]></programlisting>
                
                <para>
                    The server-side criteria base class
                    <classname>ServerSideCriterion</classname> provides a generic
                    <methodname>accept()</methodname> method. The more specific
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname> are conveniency extensions
                    that allow definiting allowed drop targets as a set of items. They
                    also provide some optimization by lazy loading, which reduces server
                    communications significantly.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any
    // other tree node except on node that may not have children
    TreeDropCriterion criterion = new TreeDropCriterion() {
        @Override
        protected Set<Object> getAllowedItemIds(
                DragAndDropEvent dragEvent, Tree tree) {
            HashSet<Object> allowed = new HashSet<Object>();
            for (Iterator<Object> i =
                   tree.getItemIds().iterator(); i.hasNext();) {
                Object itemId = i.next();
                if (tree.hasChildren(itemId))
                    allowed.add(itemId);
            }
            return allowed;
        }
    };
    return criterion;
}]]></programlisting>

            </section>

            <section>
                <title>Accept Indicators</title>

                <para>
                    When a dragged object hovers on a drop target, an <emphasis>accept
                    indicator</emphasis> is displayed to show whether or not the location
                    is accepted. For <parameter>MIDDLE</parameter> location, the indicator
                    is a box around the target (tree node, table row, or component). For
                    vertical drop locations, the accepted locations are shown as
                    horizontal lines, and for horizontal drop locations as vertical lines.
                </para>

                <para>
                    For <classname>DragAndDropWrapper</classname> drop targets, you can
                    disable the accept indicators or <emphasis>drag hints</emphasis> with
                    the <parameter>no-vertical-drag-hints</parameter>,
                    <parameter>no-horizontal-drag-hints</parameter>, and
                    <parameter>no-box-drag-hints</parameter> styles. You need to add the
                    styles to the <emphasis>layout that contains</emphasis> the wrapper,
                    not to the wrapper itself.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have a wrapper
DragAndDropWrapper wrapper = new DragAndDropWrapper(c);
layout.addComponent(wrapper);

// Disable the hints
layout.addStyleName("no-vertical-drag-hints");
layout.addStyleName("no-horizontal-drag-hints");
layout.addStyleName("no-box-drag-hints");]]></programlisting>

                <!-- TODO: Document also styles for the Tree and Table. -->
            </section>

            <indexterm startref="term.advanced.dragndrop.acceptcriteria" class="endofrange"/>
        </section>

        <section>
            <title>Dragging Components</title>

            <para>
                Dragging a component requires wrapping the source component within a
                <classname>DragAndDropWrapper</classname>. You can then allow dragging by
                putting the wrapper (and the component) in drag mode with
                <methodname>setDragStartMode()</methodname>. The method supports two drag
                modes: <parameter>DragStartMode.WRAPPER</parameter> and
                <parameter>DragStartMode.COMPONENT</parameter>, which defines whether the
                entire wrapper is shown as the drag image while dragging or just the
                wrapped component.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a component to drag
final Button button = new Button("An Absolute Button");

// Put the component in a D&D wrapper and allow dragging it
final DragAndDropWrapper buttonWrap = new DragAndDropWrapper(button);
buttonWrap.setDragStartMode(DragStartMode.COMPONENT);

// Set the wrapper to wrap tightly around the component
buttonWrap.setSizeUndefined();
        
// Add the wrapper, not the component, to the layout
layout.addComponent(buttonWrap, "left: 50px; top: 50px;");]]></programlisting>

            <para>
                The default height of <classname>DragAndDropWrapper</classname> is
                undefined, but the default width is 100%. If you want to ensure that the
                wrapper fits tightly around the wrapped component, you should call
                <methodname>setSizeUndefined()</methodname> for the wrapper. Doing so, you
                should make sure that the wrapped component does not have a relative size,
                which would cause a paradox.
            </para>

            <para>
                Dragged components are referenced in the
                <classname>WrapperTransferable</classname>. You can get the reference to
                the dragged component with
                <methodname>getDraggedComponent()</methodname>. The method will return
                <literal>null</literal> if the transferable is not a component. Also HTML
                5 drags (see later) are held in wrapper transferables.
            </para>

        </section>

        <section xml:id="advanced.dragndrop.drop-on-component">
            <title>Dropping on a Component</title>

            <para>
                Drops on a component are enabled by wrapping the component in a
                <classname>DragAndDropWrapper</classname>. The wrapper is an ordinary
                component; the constructor takes the wrapped component as a parameter. You
                just need to define the <classname>DropHandler</classname> for the wrapper
                with <methodname>setDropHandler()</methodname>.
            </para>

            <para>
                In the following example, we allow moving components in an absolute
                layout. Details on the drop handler are given later.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A layout that allows moving its contained components
// by dragging and dropping them
final AbsoluteLayout absLayout = new AbsoluteLayout();
absLayout.setWidth("100%");
absLayout.setHeight("400px");

... put some (wrapped) components in the layout ...

// Wrap the layout to allow handling drops
DragAndDropWrapper layoutWrapper =
        new DragAndDropWrapper(absLayout);

// Handle moving components within the AbsoluteLayout
layoutWrapper.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    
    public void drop(DragAndDropEvent event) {
        ...        
    }
});]]></programlisting>

            <section>
                <title>Target Details for Wrapped Components</title>

                <para>
                    The drop handler receives the drop target details in a
                    <classname>WrapperTargetDetails</classname> object, which implements
                    the <classname>TargetDetails</classname> interface.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public void drop(DragAndDropEvent event) {
    WrapperTransferable t =
        (WrapperTransferable) event.getTransferable();
    WrapperTargetDetails details =
        (WrapperTargetDetails) event.getTargetDetails();]]></programlisting>

                <para>
                    The wrapper target details include a
                    <classname>MouseEventDetails</classname> object, which you can get
                    with <methodname>getMouseEvent()</methodname>. You can use it to get
                    the mouse coordinates for the position where the mouse button was
                    released and the drag ended. Similarly, you can find out the drag
                    start position from the transferable object (if it is a
                    <classname>WrapperTransferable</classname>) with
                    <methodname>getMouseDownEvent()</methodname>.
                </para>
                
                <programlisting><?pocket-size 65% ?><![CDATA[// Calculate the drag coordinate difference
int xChange = details.getMouseEvent().getClientX()
              - t.getMouseDownEvent().getClientX();
int yChange = details.getMouseEvent().getClientY()
              - t.getMouseDownEvent().getClientY();

// Move the component in the absolute layout
ComponentPosition pos =
    absLayout.getPosition(t.getSourceComponent());
pos.setLeftValue(pos.getLeftValue() + xChange);
pos.setTopValue(pos.getTopValue() + yChange);]]></programlisting>

                <para>
                    You can get the absolute x and y coordinates of the target wrapper
                    with <methodname>getAbsoluteLeft()</methodname> and
                    <methodname>getAbsoluteTop()</methodname>, which allows you to
                    translate the absolute mouse coordinates to coordinates relative to
                    the wrapper. Notice that the coordinates are really the position of
                    the wrapper, not the wrapped component; the wrapper reserves some
                    space for the accept indicators.
                </para>

                <para>
                    The <methodname>verticalDropLocation()</methodname> and
                    <methodname>horizontalDropLocation()</methodname> return the more
                    detailed drop location in the target.
                </para>
            </section>
        </section>

        <section>
            <title>Dragging Files from Outside the Browser</title>
            
            <para>
                The <classname>DragAndDropWrapper</classname> allows dragging files from
                outside the browser and dropping them on a component wrapped in the
                wrapper. Dropped files are automatically uploaded to the application and
                can be acquired from the wrapper with
                <methodname>getFiles()</methodname>. The files are represented as
                <classname>Html5File</classname> objects as defined in the inner
                class. You can define an upload <classname>Receiver</classname> to receive
                the content of a file to an <classname>OutputStream</classname>.
            </para>

            <para>
                Dragging and dropping files to browser is supported in HTML 5 and
                requires a compatible browser, such as Mozilla Firefox 3.6 or newer.
            </para>
        </section>

        <indexterm startref="term.advanced.dragndrop" class="endofrange"/>
    </section>

    <section xml:id="advanced.logging">
        <title>Logging</title>

        <indexterm xml:id="term.advanced.logging" class="startofrange"/>

        <para>
            You can do logging in Vaadin application using the standard
            <package>java.util.logging</package> facilities. Configuring logging is as
            easy as putting a file named <filename>logging.properties</filename> in the
            default package of your Vaadin application (<filename>src</filename> in an
            Eclipse project or <filename>src/main/java</filename> or
            <filename>src/main/resources</filename> in a Maven project). This file is read
            by the <classname>Logger</classname> class when a new instance of it is
            initialize.
        </para>

        <simplesect xml:id="advanced.logging.tomcat">
            <title>Logging in Apache Tomcat</title>

            <para>
                For logging Vaadin applications deployed in Apache Tomcat, you do not need
                to do anything special to log to the same place as Tomcat itself. If you
                need to write the Vaadin application related messages elsewhere, just add
                a custom <filename>logging.properties</filename> file to the default
                package of your Vaadin application.
            </para>

            <para>
                If you would like to pipe the log messages through another logging
                solution, see <xref linkend="advanced.logging.slf4j"/> below.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.logging.liferay">
            <title>Logging in Liferay</title>

            <para>
                Liferay mutes logging through <package>java.util.logging</package> by
                default. In order to enable logging, you need to add a
                <filename>logging.properties</filename> file of your own to the default
                package of your Vaadin application. This file should define at least one
                destination where to save the log messages.
            </para>

            <para>
                You can also log through SLF4J, which is used in and bundled with
                Liferay. Follow the instructions in <xref
                linkend="advanced.logging.slf4j"/>.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.logging.slf4j">
            <title>Piping to Log4j using SLF4J</title>

            <indexterm><primary>Log4j</primary></indexterm>
            <indexterm><primary>SLF4J</primary></indexterm>

            <para>
                Piping output from <package>java.util.logging</package> to Log4j is easy
                with SLF4J (<link
                xlink:href="http://slf4j.org/">http://slf4j.org/</link>). The basic way to
                go about this is to add the SLF4J JAR file as well as the
                <filename>jul-to-slf4j.jar</filename> file, which implements the bridge
                from <package>java.util.logging</package>, to SLF4J. You will also need to
                add a third logging implementation JAR file, that is,
                <filename>slf4j-log4j12-x.x.x.jar</filename>, to log the actual messages
                using Log4j. For more info on this, please visit the SLF4J site.
            </para>

            <para>
                In order to get the <package>java.util.logging</package> to SLF4J
                bridge installed, you need to add the following snippet of code to your
                <classname>UI</classname> class at the very top:
                <!-- TODO: Sure it's UI class and not the servlet? -->
            </para>

            <programlisting><![CDATA[  static {
    SLF4JBridgeHandler.install();
  }]]></programlisting>

            <para>
                This will make sure that the bridge handler is installed and working
                before Vaadin starts to process any logging calls.
            </para>

            <warning>
                <title>Please note!</title>

                <para>
                    This can seriously impact on the cost of disabled logging statements
                    (60-fold increase) and a measurable impact on enabled log statements
                    (20% overall increase). However, Vaadin doesn't log very much, so the
                    effect on performance will be negligible.
                </para>
            </warning>
            </simplesect>

        <simplesect xml:id="advanced.logging.core">
            <title>Using Logger</title>

            <para>
                You can do logging with a simple pattern where you register a static
                logger instance in each class that needs logging, and use this logger
                wherever logging is needed in the class. For example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyClass {
  private final static Logger logger =
          Logger.getLogger(MyClass.class.getName());
  
  public void myMethod() {
    try {
      // do something that might fail
    } catch (Exception e) {
      logger.log(Level.SEVERE, "FAILED CATASTROPHICALLY!", e);
    } 
  }
}]]></programlisting>

            <para>
                <indexterm><primary>static</primary></indexterm>
                <indexterm><primary>memory leak</primary></indexterm>
                <indexterm><primary>PermGen</primary></indexterm>

                Having a <literal>static</literal> logger instance for each class needing
                logging saves a bit of memory and time compared to having a logger for
                every logging class instance. However, it could cause the application to
                leak PermGen memory with some application servers when redeploying the
                application. The problem is that the <classname>Logger</classname> may
                maintain hard references to its instances. As the
                <classname>Logger</classname> class is loaded with a classloader shared
                between different web applications, references to classes loaded with a
                per-application classloader would prevent garbage-collecting the classes
                after redeploying, hence leaking memory. As the size of the PermGen memory
                where class object are stored is fixed, the leakage will lead to a server
                crash after many redeployments. The issue depends on the way how the
                server manages classloaders, on the hardness of the back-references, and
                may also be different between Java 6 and 7. So, if you experience PermGen
                issues, or want to play it on the safe side, you should consider using
                non-static <classname>Logger</classname> instances.

                <!-- As discussed in Forum thread 1175841 (24.2.2012). -->
            </para>
        </simplesect>

        <indexterm startref="term.advanced.logging" class="endofrange"/>
    </section>

    <section xml:id="advanced.javascript">
        <title>JavaScript Interaction</title>
        
        <para>
            Vaadin supports two-direction JavaScript calls from and to the
            server-side. This allows interfacing with JavaScript code without writing
            client-side integration code.
        </para>

        <section xml:id="advanced.javascript.calling">
            <title>Calling JavaScript</title>

            <para>
                You can make JavaScript calls from the server-side with the
                <methodname>execute()</methodname> method in the
                <classname>JavaScript</classname> class. You can get a
                <classname>JavaScript</classname> instance from the current
                <classname>Page</classname> object with
                <methodname>getJavaScript()</methodname>.

                <!-- TODO Check that the API is so. -->
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Execute JavaScript in the currently processed page
Page.getCurrent().getJavaScript().execute("alert('Hello')");]]></programlisting>

            <para>
                The <classname>JavaScript</classname> class itself has a static shorthand
                method <methodname>getCurrent()</methodname> to get the instance for the
                currently processed page.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Shorthand
JavaScript.getCurrent().execute("alert('Hello')");]]></programlisting>

            <para>
                The JavaScript is executed after the server request that is currently
                processed returns. If multiple JavaScript calls are made during the
                processing of the request, they are all executed sequentially after the
                request is done. Hence, the JavaScript execution does not pause the
                execution of the server-side application and you can not return values
                from the JavaScript.
            </para>
        </section>

        <section xml:id="advanced.javascript.callback">
            <title>Handling JavaScript Function Callbacks</title>

            <para>
                You can make calls with JavaScript from the client-side to the
                server-side. This requires that you register JavaScript call-back methods
                from the server-side. You need to implement and register a
                <classname>JavaScriptFunction</classname> with
                <methodname>addFunction()</methodname> in the current
                <classname>JavaScript</classname> object. A function requires a
                name, with an optional package path, which are given to the
                <methodname>addFunction()</methodname>. You only need to implement the
                <methodname>call()</methodname> method to handle calls from the
                client-side JavaScript.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[
JavaScript.getCurrent().addFunction("com.example.foo.myfunc",
                                    new JavaScriptFunction() {
    @Override
    public void call(JSONArray arguments) throws JSONException {
        Notification.show("Received call");
    }
});

Link link = new Link("Send Message", new ExternalResource(
        "javascript:com.example.foo.myfunc()"));]]></programlisting>

            <para>
                Parameters passed to the JavaScript method on the client-side are provided
                in a <classname>JSONArray</classname> passed to the
                <methodname>call()</methodname> method. The parameter values can be
                acquired with the <methodname>get()</methodname> method by the index of
                the parameter, or any of the type-casting getters. The getter must match
                the type of the passed parameter, or a
                <classname>JSONException</classname> is thrown.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[JavaScript.getCurrent().addFunction("com.example.foo.myfunc",
                                    new JavaScriptFunction() {
    @Override
    public void call(JSONArray arguments) throws JSONException {
        try {
            String message = arguments.getString(0);
            int    value   = arguments.getInt(1);
            Notification.show("Message: " + message +
                              ", value: " + value);
        } catch (JSONException e) {
            Notification.show("Error: " + e.getMessage());
        }
    }
});
        
Link link = new Link("Send Message", new ExternalResource(
  "javascript:com.example.foo.myfunc(prompt('Message'), 42)"));]]></programlisting>

            <para>
                The function callback mechanism is the same as the RPC mechanism used with
                JavaScript component integration, as described in <xref
                linkend="gwt.javascript.rpc"/>.
            </para>
        </section>
    </section>

    <section xml:id="advanced.global" condition="web">
        <title>Accessing Session-Global Data</title>

        <para>
            <emphasis>This section is mostly up-to-date with Vaadin 7, but has some
            information which still needs to be updated.</emphasis>
        </para>

        <para>
            Applications typically need to access some objects from practically all user
            interface code, such as a user object, a business data model, or a database
            connection. This data is typically initialized and managed in the UI class of
            the application, or in the session or servlet.
        </para>

        <para>
            For example, you could hold it in the UI class as follows:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyUI extends UI {
    UserData userData;

    public void init() {
        userData = new UserData();
    }

    public UserData getUserData() {
        return userData;
    }
}]]></programlisting>

        <para>
            Vaadin offers two ways to access the UI object: with
            <methodname>getUI()</methodname> method from any component and the global
            <methodname>UI.getCurrent()</methodname> method.
        </para>

        <para>
            The <methodname>getUI()</methodname> works as follows:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[data = ((MyUI)component.getUI()).getUserData();]]></programlisting>

        <para>
            This does not, however work in many cases, because it requires that the
            components are attached to the UI. That is not the case most of the time when
            the UI is still being built, such as in constructors.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {
    public MyComponent() {
        // This fails with NullPointerException
        Label label = new Label("Country: " +
            getApplication().getLocale().getCountry());

        setCompositionRoot(label);
    }
}]]></programlisting>


        <para>
            The global access methods for the currently served servlet, session, and UI
            allow an easy way to access the data:
        </para>

        <programlisting><![CDATA[data = ((MyUI) UI.getCurrent()).getUserData();]]></programlisting>

        <simplesect xml:id="advanced.global.passing.problem">
            <title>The Problem</title>

            <para>
                The basic problem in accessing session-global data is that the
                <methodname>getUI()</methodname> method works only after the
                component has been attached to the application. Before that, it returns
                <parameter>null</parameter>. This is the case in constructors of
                components, such as a <classname>CustomComponent</classname>:
            </para>

            <para>
                Using a static variable or a singleton implemented with such to give a
                global access to user session data is not possible, because static
                variables are global in the entire web application, not just the user
                session. This can be handy for communicating data between the concurrent
                sessions, but creates a problem within a session.
            </para>

            <para>
                The data would be shared by all users and be reinitialized every time a
                new user opens the application.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.global.passing.solutions-overview">
            <title>Overview of Solutions</title>

            <para>
                To get the application object or any other global data, you have the
                following solutions:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Pass a reference to the global data as a parameter
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Initialize components in <methodname>attach()</methodname> method
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Initialize components in the <methodname>enter()</methodname> method of
                        the navigation view (if using navigation)
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Store a reference to global data using the <emphasis>ThreadLocal Pattern</emphasis>
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Each solution is described in the following sections.
            </para>
        </simplesect>

        <section xml:id="advanced.global.passing">
            <title>Passing References Around</title>

            <para>
                You can pass references to objects as parameters. This is the normal way
                in object-oriented programming.
            </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyApplication extends Application {
    UserData userData;

    public void init() {
        Window mainWindow = new Window("My Window");
        setMainWindow(mainWindow);

        userData = new UserData();
        
        mainWindow.addComponent(new MyComponent(this));
    }

    public UserData getUserData() {
        return userData;
    }
}

class MyComponent extends CustomComponent {
    public MyComponent(MyApplication app) {
        Label label = new Label("Name: " +
            app.getUserData().getName());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                If you need the reference in other methods, you either have to pass it
                again as a parameter or store it in a member variable.
            </para>

            <para>
                The problem with this solution is that practically all constructors in the
                application need to get a reference to the application object, and passing
                it further around in the classes is another hard task.
            </para>
        </section>
        
        <section xml:id="advanced.global.attach">
            <title>Overriding <methodname>attach()</methodname></title>

            <para>
                The <methodname>attach()</methodname> method is called when the component
                is attached to the application component through containment
                hierarchy. The <methodname>getApplication()</methodname> method always
                works.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {
    public MyComponent() {
        // Must set a dummy root in constructor
        setCompositionRoot(new Label(""));
    }

    @Override
    public void attach() {    
        Label label = new Label("Name: " +
            ((MyApplication)component.getApplication())
                .getUserData().getName());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                While this solution works, it is slightly messy. You may need to do some
                initialization in the constructor, but any construction requiring the
                global data must be done in the <methodname>attach()</methodname> method.
                Especially, <classname>CustomComponent</classname> requires that the
                <methodname>setCompositionRoot()</methodname> method is called in the
                constructor. If you can't create the actual composition root component in
                the constructor, you need to use a temporary dummy root, as is done in the
                example above.
            </para>
            
            <para>
                Using <methodname>getApplication()</methodname> also needs casting if you
                want to use methods defined in your application class.
            </para>
        </section>

        <section xml:id="advanced.global.threadlocal">
            <title>ThreadLocal Pattern</title>

            <indexterm xml:id="term.advanced.global.threadlocal" class="startofrange"><primary>ThreadLocal pattern</primary></indexterm>

            <para>
                Vaadin uses the ThreadLocal pattern for allowing global access to the
                <classname>&uiclass;</classname>, and <classname>Page</classname> objects
                of the currently processed server request with a static
                <methodname>getCurrent()</methodname> method in all the respective
                classes. This section explains why the pattern is used in Vaadin and how
                it works. You may also need to reimplement the pattern for some purpose.
            </para>

            <!-- TODO Vaadin 7: Clean up what is no longer necessary -->

            <para>
                The ThreadLocal pattern gives a solution to the global access problem by
                solving two sub-problems of static variables.
            </para>

            <para>
                As the first problem, assume that the servlet container processes requests
                for many users (sessions) sequentially. If a static variable is set in a
                request belonging one user, it could be read or re-set by the next
                incoming request belonging to another user. This can be solved by setting
                the global reference at the beginning of each HTTP request to point to
                data of the current user, as illustrated in Figure <xref
                linkend="figure.advanced.global.threadlocal.sequentiality"
                xrefstyle="select:labelnumber"/>.
            </para>

            <figure xml:id="figure.advanced.global.threadlocal.sequentiality">
                <title>Switching a static (or ThreadLocal) reference during sequential
                processing of requests</title>

                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/threadlocal-sequentiality-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/threadlocal-sequentiality-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <!-- TODO Vaadin 7 reimplement
            <para>
                It is possible to implement such switching either with the
                <classname>TransactionListener</classname> or
                <classname>HttpServletRequestListener</classname> interface by setting the
                reference in <methodname>transactionStart()</methodname> or
                <methodname>onRequestStart()</methodname>, respectively. We use the former
                interface in the example code in this section, as the latter interface has
                to be implemented in the application class.
            </para>-->

            <para>
                The second problem is that servlet containers typically do thread pooling
                with multiple worker threads that process requests. Therefore, setting a
                static reference would change it in all threads running concurrently,
                possibly just when another thread is processing a request for another
                user. The solution is to store the reference in a thread-local variable
                instead of a static. You can do so by using the
                <classname>ThreadLocal</classname> class in Java for the switch reference.
            </para>

            <figure xml:id="figure.advanced.global.threadlocal.concurrency">
                <title>Switching <classname>ThreadLocal</classname> references during
                concurrent processing of requests</title>

                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/threadlocal-concurrency-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/threadlocal-concurrency-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

<!--
            <para>
                Notice that if you use a <classname>TransactionListener</classname>, the
                listeners are attached to the web application context (in practice a user
                session), not the application instance. The problem is that an application
                context can have multiple different Vaadin applications that share the
                same user session. If two of these applications add a transaction listener
                to the context to listen for requests, both are called and without any
                checks they would both set the reference to themselves. Therefore, the
                application data object needs to know which application it belongs to and
                check that when the transaction begins and ends. Using the
                <classname>HttpServletRequestListener</classname> frees you from these
                checks.
            </para>

            <para>
                While you may not absolutely need to clear the reference in
                <methodname>transactionEnd()</methodname>, you are probably on the safer
                side if you do. Setting such unneeded references to
                <literal>null</literal> can help avoid memory leaks and it could also be a
                good security precaution not to leave a reference to session data so that
                it could be seen by another user session in the next request.
            </para>

            <para>
                We end up with the following code. As we put the application data to a
                class separate from the application class, we have to make it a
                <classname>TransactionListener</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[/** Holds data for one user session. */
public class AppData
       implements TransactionListener, Serializable {
    private ResourceBundle bundle;
    private Locale locale;   // Current locale
    private String userData; // Trivial data model for the user
    
    private Application app; // For distinguishing between apps

    private static ThreadLocal<AppData> instance =
        new ThreadLocal<AppData>();
    
    public AppData(Application app) {
        this.app = app;

        // It's usable from now on in the current request
        instance.set(this);
    }

    @Override
    public void transactionStart(Application application,
                                 Object transactionData) {
        // Set this data instance of this application
        // as the one active in the current thread. 
        if (this.app == application)
            instance.set(this);
    }

    @Override
    public void transactionEnd(Application application,
                               Object transactionData) {
        // Clear the reference to avoid potential problems
        if (this.app == application)
            instance.set(null);
    }

    public static void initLocale(Locale locale,
                                  String bundleName) {
        instance.get().locale = locale;
        instance.get().bundle =
            ResourceBundle.getBundle(bundleName, locale);
    }
    
    public static Locale getLocale() {
        return instance.get().locale;
    }

    public static String getMessage(String msgId) {
        return instance.get().bundle.getString(msgId);
    }

    public static String getUserData() {
        return instance.get().userData;
    }

    public static void setUserData(String userData) {
        instance.get().userData = userData;
    }
}]]></programlisting>

            <para>
                We can then use it in the application as follows. Observe that we do not
                have a reference to the application object in the constructor of the
                <classname>MyComponent</classname> class.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[/** 
 * We can now nicely access the session-global data
 * in the constuctor of this class.
 */
class MyComponent extends CustomComponent {
    public MyComponent() {
        VerticalLayout layout = new VerticalLayout();
        
        // Get stuff from the application data object            
        layout.addComponent(new Label("Hello, " +
            AppData.getUserData()));

        layout.addComponent(new Label("Your locale is " +
            AppData.getLocale().getDisplayLanguage()));
        
        layout.addComponent(new Button(
            AppData.getMessage(MyAppCaptions.CancelKey)));
        
        setCompositionRoot(layout);
    }
}

/** The application class. */
public class ThreadLocalApplication extends Application {
    public void init() { 
        Window main = new Window("Hello window"); 
        setMainWindow(main);
        
        // Create the application data instance
        AppData sessionData = new AppData(this);
        
        // Register it as a listener in the application context
        getContext().addTransactionListener(sessionData);
        
        // Initialize the session-global data
        AppData.initLocale(getLocale(),
                           MyAppCaptions.class.getName());
        
        // Also set the user data model
        AppData.setUserData("Billy");
        
        // Now, we do not pass this application object
        // in the constructor, so it couldn't access the
        // app data otherwise.
        main.addComponent(new MyComponent());
    }
}]]></programlisting>
-->
            <indexterm startref="term.advanced.global.threadlocal" class="endofrange"/>
        </section>
    </section>

    <section xml:id="advanced.push">
        <title>Server Push</title>

        <para>
            When you need to update a UI from another UI, possibly of another user, or
            from a background thread running in the server, you usually want to have the
            update show immediately, not when the browser happens to make the next server
            request. For this purpose, you can use <emphasis>server push</emphasis> that
            sends the data to the browser immediately. Push is based on a client-server
            connection, usually a WebSocket connection, that the client establishes and
            the server can then use to send updates to the client.
        </para>

        <para>
            The server-client communication is done by default with a WebSocket connection
            if the browser and the server support it. If not, Vaadin will fall back to a
            method supported by the browser. Vaadin Push uses a custom build of the <link
            xlink:href="https://github.com/Atmosphere/atmosphere">Atmosphere
            framework</link> for client-server communication.
        </para>

        <section xml:id="advanced.push.installation">
            <title>Installing the Push Support</title>

            <para>
                The server push support in Vaadin requires the separate Vaadin Push
                library. It is included in the installation package as
                <filename>vaadin-push.jar</filename>.
            </para>

            <section xml:id="advanced.push.installation.ivy">
                <title>Retrieving with Ivy</title>

                <para>
                    With Ivy, you can get it with the following declaration in the
                    <filename>ivy.xml</filename>:
                </para>

                <programlisting><?pocket-size 70% ?><![CDATA[<dependency org="com.vaadin" name="vaadin-push"
            rev="&vaadin.version;" conf="default->default"/>]]></programlisting>

                <para>
                    In some servers, you may need to exlude a <literal>sl4j</literal>
                    dependency as follows:
                </para>

                <programlisting><?pocket-size 70% ?><![CDATA[<dependency org="com.vaadin" name="vaadin-push"
            rev="&vaadin.version;" conf="default->default">
    <exclude org="org.slf4j" name="slf4j-api"/>
</dependency>]]></programlisting>

                <para>
                    Pay note that the Atmosphere library is a bundle, so if you retrieve
                    the libraries with Ant, for example, you need to retrieve
                    <literal>type="jar,bundle"</literal>.
                </para>
            </section>

            <section xml:id="advanced.push.installation.maven">
                <title>Retrieving with Maven</title>

                <para>
                    In Maven, you can get the push library with the following dependency
                    in the POM:
                </para>

                <programlisting><![CDATA[<dependency>
    <groupId>com.vaadin</groupId>
    <artifactId>vaadin-push</artifactId>
    <version>${vaadin.version}</version>
</dependency>]]></programlisting>
            </section>
        </section>

        <section xml:id="advanced.push.enabling">
            <title>Enabling Push for a UI</title>

            <para>
                To enable server push, you need to define the push mode either in the
                deployment descriptor or with the <classname>@Push</classname> annotation
                for the UI.
            </para>

            <section xml:id="advanced.push.enabling.pushmode">
                <title>Push Modes</title>

                <para>
                    You can use server push in two modes: <literal>automatic</literal> and
                    <literal>manual</literal>. The automatic mode pushes changes to the
                    browser automatically after access() finishes. With the manual mode,
                    you can do the push explicitly with <methodname>push()</methodname>,
                    which allows more flexibility.
                </para>
            </section>

            <section xml:id="advanced.push.enabling.pushmode">
                <title>The <classname>@Push</classname> annotation</title>

                <para>
                    You can enable server push for a UI with the
                    <classname>@Push</classname> annotation as follows. It defaults to
                    automatic mode (<parameter>PushMode.AUTOMATIC</parameter>).
                </para>

                <programlisting><![CDATA[@Push
public class PushyUI extends UI {]]></programlisting>

                <para>
                    To enable manual mode, you need to give the
                    <parameter>PushMode.MANUAL</parameter> parameter as follows:
                </para>

                <programlisting><![CDATA[@Push(PushMode.MANUAL)
public class PushyUI extends UI {]]></programlisting>
            </section>

            <section xml:id="advanced.push.enabling.servlet">
                <title>Servlet Configuration</title>

                <para>
                    You can enable the server push and define the push mode also in the
                    servlet configuration with the <parameter>pushmode</parameter>
                    parameter for the servlet in the <filename>web.xml</filename>
                    deployment descriptor. If you use a Servlet 3.0 compatible server, you
                    also want to enable asynchronous processing with the
                    <literal>async-supported</literal> parameter. Note the use of Servlet
                    3.0 schema in the deployment descriptor.
                </para>
            </section>

            <programlisting><?pocket-size 70% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
  id="WebApp_ID" version="<emphasis role="bold">3.0</emphasis>"
  xmlns="<emphasis role="bold">http://java.sun.com/xml/ns/javaee</emphasis>"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="<emphasis role="bold">http://java.sun.com/xml/ns/javaee
      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd</emphasis>"&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Pushy UI&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
        com.vaadin.server.VaadinServlet&lt;/servlet-class&gt;

    &lt;init-param&gt;
        &lt;param-name&gt;UI&lt;/param-name&gt;
        &lt;param-value&gt;<emphasis role="bold">com.example.my.PushyUI</emphasis>&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;!-- Enable server push --&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;pushmode&lt;/param-name&gt;
      &lt;param-value&gt;<emphasis role="bold">automatic</emphasis>&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;async-supported&gt;<emphasis role="bold">true</emphasis>&lt;/async-supported&gt;
  &lt;/servlet&gt;
&lt;/web-app&gt;</programlisting>
        </section>

        <section xml:id="advanced.push.running">
            <title>Accessing UI from Another Thread</title>

            <para>
                Making changes to a <classname>UI</classname> object from another thread
                and pushing them to the browser requires locking the user session when
                accessing the UI. Otherwise, the UI update done from another thread could
                conflict with a regular event-driven update and cause either data
                corruption or deadlocks. Because of this, you may only access an UI using
                the <methodname>access()</methodname> method, which locks the session to
                prevent conflicts. It takes a <interfacename>Runnable</interfacename>
                which it executes as its parameter.
            </para>

            <para>
                For example:
            </para>

            <programlisting><![CDATA[ui.access(new Runnable() {
    @Override
    public void run() {
        series.add(new DataSeriesItem(x, y));
    }
});]]></programlisting>

            <para>
                In Java 8, where a parameterless lambda expression creates a runnable, you
                could simply write:
            </para>

            <programlisting><![CDATA[ui.access(() ->
        series.add(new DataSeriesItem(x, y)));]]></programlisting>

            <para>
                If the push mode is <literal>manual</literal>, you need to push the
                pending UI changes to the browser explicitly with the
                <methodname>push()</methodname> method.
            </para>

            <programlisting><![CDATA[ui.access(new Runnable() {
    @Override
    public void run() {
        series.add(new DataSeriesItem(x, y));
        ui.push();
    }
});]]></programlisting>


            <para>
                Below is a complete example of a case where we make UI changes from
                another thread.
            </para>

            <book-example eid="advanced.push.simple" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[public class PushyUI extends UI {
    Chart chart = new Chart(ChartType.AREASPLINE);
    DataSeries series = new DataSeries();
    
    @Override
    protected void init(VaadinRequest request) {
        chart.setSizeFull();
        setContent(chart);
        
        // Prepare the data display
        Configuration conf = chart.getConfiguration();
        conf.setTitle("Hot New Data");
        conf.setSeries(series);
        
        // Start the data feed thread
        new FeederThread().start();
    }
    
    class FeederThread extends Thread {
        int count = 0;
        
        @Override
        public void run() {
            try {
                // Update the data for a while
                while (count < 100) {
                    Thread.sleep(1000);
                
                    access(new Runnable() {
                        @Override
                        public void run() {
                            double y = Math.random();
                            series.add(
                                new DataSeriesItem(count++, y),
                                true, count > 10);
                        }
                    });
                }

                // Inform that we have stopped running
                access(new Runnable() {
                    @Override
                    public void run() {
                        setContent(new Label("Done!"));
                    }
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}]]></programlisting>

            <para>
                When sharing data between UIs or user sessions, you need to consider the
                message-passing mechanism more carefully, as explained next.
            </para>
        </section>

        <section xml:id="advanced.push.pusharound">
            <title>Broadcasting to Other Users</title>

            <para>
                Broadcasting messages to be pushed to UIs in other user sessions requires
                having some sort of message-passing mechanism that sends the messages to
                all UIs that register as recipients. As processing server requests for
                different UIs is done concurrently in different threads of the application
                server, locking the threads properly is very important to avoid deadlock
                situations.
            </para>

            <section xml:id="advanced.push.pusharound.broadcaster">
                <title>The Broadcaster</title>

                <para>
                    The standard pattern for sending messages to other users is to use a
                    <emphasis>broadcaster</emphasis> singleton that registers the UIs and
                    broadcasts messages to them safely. To avoid deadlocks, it is
                    recommended that the messages should be sent through a message queue
                    in a separate thread. Using a Java
                    <classname>ExecutorService</classname> running in a single thread is
                    usually the easiest and safest way.
                </para>

                <book-example eid="advanced.push.pusharound" style="float: right"></book-example>
                <programlisting><?pocket-size 65% ?><![CDATA[public class Broadcaster implements Serializable {
    static ExecutorService executorService =
        Executors.newSingleThreadExecutor();

    public interface BroadcastListener {
        void receiveBroadcast(String message);
    }
    
    private static LinkedList<BroadcastListener> listeners =
        new LinkedList<BroadcastListener>();
    
    public static synchronized void register(
            BroadcastListener listener) {
        listeners.add(listener);
    }
    
    public static synchronized void unregister(
            BroadcastListener listener) {
        listeners.remove(listener);
    }
    
    public static synchronized void broadcast(
            final String message) {
        for (final BroadcastListener listener: listeners)
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    listener.receiveBroadcast(message);
                }
            });
    }
}]]></programlisting>

                <para>
                    In Java 8, you could use lambda expressions for the listeners instead
                    of the interface, and a parameterless expression to create the
                    runnable:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[for (final Consumer<String> listener: listeners)
    executorService.execute(() ->
            listener.accept(message));]]></programlisting>
            </section>

            <section xml:id="advanced.push.pusharound.receiving">
                <title>Receiving Broadcasts</title>

                <para>
                    The receivers need to implement the receiver interface and register to
                    the broadcaster to receive the broadcasts. A listener should be
                    unregistered when the UI expires. When updating the UI in a receiver,
                    it should be done safely as described earlier, by executing the update
                    through the <methodname>access()</methodname> method of the UI.
                </para>

                <book-example eid="advanced.push.pusharound" style="float: right"></book-example>
                <programlisting><?pocket-size 70% ?><![CDATA[@Push
public class PushAroundUI extends UI
       implements Broadcaster.BroadcastListener {
    
    VerticalLayout messages = new VerticalLayout();

    @Override
    protected void init(VaadinRequest request) {
        ... build the UI ...
        
        // Register to receive broadcasts
        Broadcaster.register(this);
    }

    // Must also unregister when the UI expires    
    @Override
    public void detach() {
        Broadcaster.unregister(this);
        super.detach();
    }

    @Override
    public void receiveBroadcast(final String message) {
        // Must lock the session to execute logic safely
        access(new Runnable() {
            @Override
            public void run() {
                // Show it somehow
                messages.addComponent(new Label(message));
            }
        });
    }
}]]></programlisting>
            </section>

            <section xml:id="advanced.push.pusharound.sending">
                <title>Sending Broadcasts</title>

                <para>
                    To send broadcasts with a broadcaster singleton, such as the one
                    described above, you would only need to call the
                    <methodname>broadcast()</methodname> method as follows.
                </para>

                <book-example eid="advanced.push.pusharound" style="float: right"></book-example>
                <programlisting><?pocket-size 75% ?><![CDATA[final TextField input = new TextField();
sendBar.addComponent(input);

Button send = new Button("Send");
send.addClickListener(new ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        // Broadcast the message
        Broadcaster.broadcast(input.getValue());
        
        input.setValue("");
    }
});]]></programlisting>
            </section>
        </section>
    </section>

    <section xml:id="advanced.cdi">
        <title>Vaadin CDI Add-on</title>

        <indexterm xml:id="term.advanced.cdi.cdilong" class="startofrange">
            <primary>Contexts and Dependency Injection</primary>
        </indexterm>
        <indexterm xml:id="term.advanced.cdi.cdi" class="startofrange">
            <primary>CDI</primary>
        </indexterm>
        <indexterm xml:id="term.advanced.cdi.cdiaddon" class="startofrange">
            <primary>Vaadin CDI Add-on</primary>
        </indexterm>

        <para>
            Vaadin CDI add-on makes it easier to use contexts and dependency injection
            (CDI) in Vaadin applications. CDI is a Java EE feature especially targeted for
            web applications, which have well-defined contextual scopes, such as sessions,
            views, requests, and so forth. The lifecycle of objects, such as beans, can be
            managed by binding their lifecycles to such contexts. Vaadin CDI enables these
            features with two additional kinds of Vaadin-specific contextual scopes: UIs
            and navigation views.
        </para>

        <para>
            To learn more about Vaadin CDI, the <link xlink:href="">Vaadin CDI
            Tutorial</link> gives a hands-on introduction. The source code of the CDI
            Tutorial demo is available for browsing or cloning at <link
            xlink:href="https://github.com/vaadin-samples/cdi-tutorial">https://github.com/vaadin-samples/cdi-tutorial</link>.
        </para>

        <section xml:id="advanced.cdi.cdi">
            <title>CDI Overview</title>

            <para>
                Contexts and dependency injection, defined in the JSR-299 standard, is a
                Java EE feature that, through a set of services, helps in improving
                application architecture by decoupling the management of service object
                lifecycles from client objects using them. The lifecycle of objects stored
                in a CDI container is defined by a context. The managed objects or beans
                are accessed using dependency injection.
            </para>

            <para>
                CDI builds on the Java concept of beans, but with somewhat different
                definition and requirements.
            </para>

            <para>
                Regarding general CDI topics, such as use of qualifiers, interceptors,
                decorators, event notifications, and other CDI features, we refer you to
                CDI documentation.
            </para>

            <itemizedlist condition="web">
                <listitem>
                    <para>
                        <link xlink:href="http://jaxenter.com/tutorial-introduction-to-cdi-contexts-and-dependency-injection-for-java-ee-jsr-299-104536.html">Introduction to CDI</link>. Pete Muir and Mark Struberg, JAXenter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <link xlink:href="http://docs.jboss.org/weld/reference/latest/en-US/html_single/">Weld - CDI Reference Implementation</link>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <link xlink:href="http://cdi-spec.org/">CDI Specification</link>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <link xlink:href="https://vaadin.com/wiki?p_p_id=36&amp;p_p_lifecycle=0&amp;p_p_state=normal&amp;p_p_mode=view&amp;p_p_col_id=row-1&amp;p_p_col_pos=1&amp;p_p_col_count=3&amp;p_r_p_185834411_title=Vaadin+CDI&amp;p_r_p_185834411_nodeName=vaadin.com+wiki&amp;_36_struts_action=%2Fwiki%2Fview">Vaadin CDI Tutorial</link>
                    </para>
                        </listitem>
            </itemizedlist>

<!-- TODO
            <section xml:id="advanced.cdi.cdi.beans">
                <title>CDI Beans</title>

                <para>
                    CDI allows almost any bean or POJO to be injected.
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            Methods may not be final.
                        </para>
                    </listitem>
                </itemizedlist>
                
                <para>
                    CDI beans are managed by and stored in a CDI container, which provides
                    services to query for them and produce them on demand.
                </para>
            </section>
-->

            <section xml:id="advanced.cdi.cdi.injection">
                <title>Dependency Injection</title>

                <para>
                    <emphasis>Dependency injection</emphasis> is a way to pass
                    dependencies (service objects) to dependent objects (clients) by
                    injecting them in member variables or initializer parameters, instead
                    of managing the lifecycle in the clients or passing them explicitly as
                    parameters. In CDI, injection of a service object to a client is
                    specified by the <classname>@Inject</classname> annotation.
                </para>

                <para>
                    For example, if we have a UI view that depends on user data, we could
                    inject the data in the client as follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class MainView extends CustomComponent implements View {
    @Inject
    User user;

    ...
    @Override
    public void enter(ViewChangeEvent event) {
        greeting.setValue("Hello, " + user.getName());
    }
}]]></programlisting>

                <para>
                    In addition to injecting managed beans with the annotation, you can
                    query for them from the bean manager.
                </para>
            </section>

            <section xml:id="advanced.cdi.cdi.contexts">
                <title>Contexts and Scopes</title>

                <para>
                    <emphasis>Contexts</emphasis> in CDI are services that manage the
                    lifecycle of objects and handle their injection. Generally speaking, a
                    context is a situation in which an instance is used with a unique
                    identity. Such objects are essentially "singletons" in the
                    context. While conventional singletons are application-wide, objects
                    managed by a CDI container can be "singletons" in a more narrow
                    <emphasis>scope</emphasis>: a user session, a particular UI instance
                    associated with the session, a view within the UI, or even just a
                    single request. Such a context defines the lifecycle of the object:
                    its creation, use, and finally its destruction.
                </para>

                <para>
                    As a very typical example in a web application, you would have a user data
                    object associated with a user session.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@SessionScoped
public class User {
    private String name;

    public void setName(String name) {this.name = name;}
    public String getName() {return name;}
}]]></programlisting>

                <para>
                    Now, when you need to refer to the user, you can use CDI injection to
                    inject the session-scoped "singleton" to a member variable or a
                    constructor parameter.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class MainView extends CustomComponent implements View {
    @Inject
    User user;

    ...

    @Override
    public void enter(ViewChangeEvent event) {
        greeting.setValue("Hello, " + user.getName());
    }
}]]></programlisting>
            </section>

        </section>

        <section xml:id="advanced.cdi.installation">
            <title>Installing Vaadin CDI Add-on</title>

            <para>
                Vaadin CDI requires a Java EE 7 compatible servlet container, such as
                Glassfish or Apache TomEE Web Profile, as mentioned for the reference
                toolchain in <xref linkend="getting-started.environment"/>.
            </para>

            <para>
                To install the Vaadin CDI add-on, either define it as an Ivy or Maven
                dependency or download it from the Vaadin Directory add-on page at <link
                xlink="https://vaadin.com/directory#addon/vaadin-cdi:vaadin">vaadin.com/directory#addon/vaadin-cdi</link>. See
                <xref linkend="addons"/> for general instructions for installing and using
                Vaadin add-ons.
            </para>

            <para>
                The Ivy dependency is as follows:
            </para>

            <programlisting>    &lt;dependency org="com.vaadin" name="vaadin-cdi"
                rev="<replaceable>latest.release</replaceable>"/&gt;</programlisting>

            <para>
                The Maven dependency is as follows:
            </para>

            <programlisting>    &lt;dependency&gt;
        &lt;groupId&gt;com.vaadin&lt;/groupId&gt;
        &lt;artifactId&gt;vaadin-cdi&lt;/artifactId&gt;
        &lt;version&gt;<replaceable>LATEST</replaceable>&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>
        </section>

        <section xml:id="advanced.cdi.peparing">
            <title>Preparing Application for CDI</title>

            <para>
                A Vaadin application that uses CDI must have a file named
                <filename>beans.xml</filename> in the <filename>WEB-INF</filename>
                directory. The file can be completely empty (it has content only in
                certain limited situations), but it must be present.
            </para>

            <para>
                The application should not have a servlet extending
                <classname>VaadinServlet</classname>, as Vaadin servlet has its own
                <classname>VaadinCDIServlet</classname> that is deployed automatically.
                If you need multiple servlets or need to customize the Vaadin CDI servlet,
                see <xref linkend="advanced.cdi.deployment"/>.
            </para>
        </section>

        <section xml:id="advanced.cdi.cdiui">
            <title>Injecting a UI with <classname>@CDIUI</classname></title>

            <indexterm xml:id="term.advanced.cdi.cdiui" class="startofrange">
                <primary><classname>@CDIUI</classname></primary>
            </indexterm>

            <para>
                Vaadin CDI offers an easier way to instantiate UIs and to define the URL
                mapping for them than the usual ways described in <xref
                linkend="application.environment"/>. To define a UI class that should be
                instantiated for a given URL, you simply need to annotate the class with
                <classname>@CDIUI</classname>. It takes an optional URL path as parameter.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[@CDIUI("myniceui")
@Theme("valo")
public class MyNiceUI extends UI {
    ...]]></programlisting>

            <para>
                Giving empty UI path maps the UI to the root of the application context.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[@CDIUI("")]]></programlisting>

            <para>
                If the optional UI path is not given, the path is determined automatically
                from the class name by removing a possible "-UI" suffix in the class name,
                making it lower-case, and for capitalized letters, a hyphen is added. For
                example, a UI with class name <classname>MyNiceUI</classname> would have
                path <literal>my-nice</literal>. The URL consists of the server address,
                application context, and the UI path. For example, when running a Vaadin
                application in a development workstation, you would have URL such as
                <uri>http://localhost:8080/myproject/my-nice</uri>.
            </para>

            <para>
                UI path mappings are reported in the server log during deployment.
            </para>

            <para>
                See <xref linkend="advanced.cdi.deployment"/> for how to handle servlet
                URL mapping of CDI UIs when working with multiple servlets in the same web
                application.
            </para>

            <indexterm startref="term.advanced.cdi.cdiui" class="endofrange"/>
        </section>

        <section xml:id="advanced.cdi.scopes">
            <title>Scopes</title>

            <indexterm xml:id="term.advanced.cdi.scopes" class="startofrange">
                <primary>CDI</primary>
                <secondary>scopes</secondary>
            </indexterm>

            <para>
                As in programming languages, where a variable name refers to a unique
                object within the scope of the variable, a CDI scope is a context in which
                an object has unique identity. In CDI, objects to be injected are
                identified by their type and any qualifiers they may have. The scope can
                be defined as an annotation to the service class as follows:
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[@SessionScoped
public class User {
    ...]]></programlisting>

            <para>
                CDI defines a number of scopes. Note that the standard CDI scopes are
                defined under the <package>javax.enterprise.context</package> package and
                Vaadin CDI scopes under <package>com.vaadin.cdi</package>, while JSF
                scopes are defined in <package>javax.faces.bean</package>.
            </para>

            <section xml:id="advanced.cdi.scopes.ui">
                <title>UI Scope</title>

                <para>
                    UI-scoped beans are uniquely identified within a UI instance, that is,
                    a browser window or tab.
                </para>

                <para>
                    Vaadin CDI provides two annotations for the UI scope, differing in how
                    they enable proxies, as explained later.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>@UIScoped</classname> (<package>com.vaadin.cdi</package>)</term>
                        <listitem>
                            <indexterm xml:id="term.advanced.cdi.scopes.uiscoped" class="startofrange">
                                <primary><classname>@UIScoped</classname></primary>
                            </indexterm>

                            <para>
                                Injection with this annotation will create a direct
                                reference to the bean rather than a proxy. There are some
                                limitations when not using proxies. Circular references
                                (injecting A to B and B to A) will not work, and neither
                                do CDI interceptors and decorators.
                            </para>

                            <indexterm startref="term.advanced.cdi.scopes.uiscoped" class="endofrange"/>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term><classname>@NormalUIScoped</classname> (<package>com.vaadin.cdi</package>)</term>

                        <listitem>
                            <para>
                                As <classname>@UIScoped</classname>, but injecting with this
                                annotation creates a proxy for the contextual instance rather
                                than provides the contextual instance itself.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    Defining a CDI view (annotated with <classname>@CDIView</classname> as
                    described later) as <classname>@UIScoped</classname> makes the view
                    retain the same instance when the user navigates away and back to the
                    view.
                </para>
            </section>

            <section xml:id="advanced.cdi.scopes.view">
                <title>View Scopes</title>

                <para>
                    The lifecycle of a view-scoped bean starts when the user navigates to
                    a view referring to the object and ends when the user navigates out of
                    the view (or when the UI is closed or expires).
                </para>

                <para>
                    Vaadin CDI provides two annotations for the view scope, differing in
                    how they enable proxies, as explained later.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>@ViewScoped</classname> (<package>com.vaadin.cdi</package>)</term>

                        <listitem>
                            <para>
                                Injection with this annotation will create a direct
                                reference to the bean rather than a proxy. There are some
                                limitations when not using proxies. Circular references
                                (injecting A to B and B to A) will not work, and neither
                                do CDI interceptors and decorators.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term><classname>@NormalViewScoped</classname> (<package>com.vaadin.cdi</package>)</term>
                        <listitem>
                            <para>
                                As <classname>@NormalScoped</classname>, except that
                                injecting with this annotation will create a proxy for the
                                contextual instance rather than provide the contextual
                                instance itself. See the explanation of proxies below.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>

            <section xml:id="advanced.cdi.scopes.cdi">
                <title>Standard CDI Scopes</title>

                <variablelist>
                    <varlistentry>
                        <term><classname>@ApplicationScoped</classname></term>
                        <listitem>
                            <indexterm xml:id="term.advanced.cdi.scopes.applicationscoped" class="startofrange">
                                <primary><classname>@ApplicationScoped</classname></primary>
                            </indexterm>

                            <para>
                                Application-scoped beans are shared by all servlets in the web
                                application, and are essentially equal to singletons.
                                
                                <!-- TODO This is just a guess - is it true? -->

                                Note that referencing application-scoped beans is not
                                thread-safe and access must be synchronized.
                            </para>

                            <indexterm startref="term.advanced.cdi.scopes.applicationscoped" class="endofrange"/>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term><classname>@SessionScoped</classname></term>
                        <listitem>
                            <indexterm xml:id="term.advanced.cdi.scopes.sessionscoped" class="startofrange">
                                <primary><classname>@SessionScoped</classname></primary>
                            </indexterm>

                            <para>
                                The lifecycle and visibility of session-scoped beans is
                                bound to a HTTP or user session, which in Vaadin
                                applications is associated with the
                                <classname>VaadinSession</classname> (see <xref
                                linkend="application.lifecycle.session"/>). This is a very
                                typical scope to store user data, as is done in many
                                examples in this section, or database connections. The
                                lifecycle of session-scoped beans starts when a user opens
                                the page for a UI in the browser, and ends when the
                                session expires after the last UI in the session is
                                closed.
                            </para>

                            <indexterm startref="term.advanced.cdi.scopes.sessionscoped" class="endofrange"/>
                        </listitem>
                    </varlistentry>

                    <!--
                    <varlistentry>
                        <term><classname>@RequestScoped</classname></term>
                        <listitem>
                            <para>
                            </para>
                        </listitem>
                    </varlistentry>
                    -->
                </variablelist>
            </section>

            <section xml:id="advanced.cdi.scopes.proxies">
                <title>Proxies vs Direct References</title>

                <para>
                    CDI uses proxy objects to enable many of the CDI features, by hooking
                    into message-passing from client to service beans. Under the hood, a
                    proxy is an instance of an automatically generated class that extends
                    the proxied bean type, so communicating through a proxy occurs
                    transparently, as it has the same polymorphic type as the actual
                    bean. Whether proxying is enabled or not is defined in the scope: CDI
                    scopes are either <emphasis>normal scopes</emphasis>, which can be
                    proxied, or <emphasis>pseudoscopes</emphasis>, which use direct
                    references to injected beans.
                </para>

                <para>
                    The proxying mechanism creates some requirements for injecting objects
                    in normal scope:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            The objects may not be primitive types or arrays
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The bean class must not be final
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The bean class must not have final methods
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    Beans annotated with <classname>@UIScoped</classname> or
                    <classname>@ViewScoped</classname> use a pseudoscope, and are
                    therefore injected with direct references to the bean instances, while
                    <classname>@NormalUIScoped</classname> and
                    <classname>@NormalViewScoped</classname> beans will use a proxy for
                    communicating with the beans.
                </para>

                <para>
                    When using proxies, be aware that it is not guaranteed that the
                    <methodname>hashCode()</methodname> or
                    <methodname>equals()</methodname> will match when comparing a proxy to
                    its underlying instance. It is imperative to be aware of this when,
                    for example, adding proxies to a
                    <interfacename>Collection</interfacename>.
                </para>

                <para>
                    You should avoid using normal scopes with Vaadin components, as
                    proxies may not work correctly within the Vaadin framework. If Vaadin
                    CDI plugin detects such use, it displays a warning such as the
                    following:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[INFO: The following Vaadin components are injected
into normal scoped contexts:
   @NormalUIScoped       org.example.User
This approach uses proxy objects and has not been
extensively tested with the framework. Please report
any unexpected behavior. Switching to a pseudo-scoped
context may also resolve potential issues.]]></programlisting>

                <para>
                    Both proxied and direct scopes have the same underlying scope, so it
                    is possible to get both a proxy and a direct reference to the same
                    object by using the two annotations.
                </para>
            </section>

            <indexterm startref="term.advanced.cdi.scopes" class="endofrange"/>
        </section>

        <section xml:id="advanced.cdi.deployment">
            <title>Deploying CDI UIs and Servlets</title>

            <para>
                Vaadin CDI hooks into Vaadin framework by using a special
                <classname>VaadinCDIServlet</classname>. As described earlier, you do not
                need to map an URL path to a UI, as it is handled by Vaadin CDI. However,
                in the following, we go through some cases where you need to customize the
                servlet or use CDI with non-CDI servlets and UIs in a web application.
            </para>


            <section xml:id="advanced.cdi.deployment.urlmapping">
                <title>Defining Servlet Root with <classname>@URLMapping</classname></title>

                <para>
                    CDI UIs are managed by a CDI servlet
                    (<classname>VaadinCDIServlet</classname>), which is by default mapped
                    to the root of the application context. For example, if the name of a
                    CDI UI is "<literal>my-cdi</literal>" and application context is
                    <literal>/myproject</literal>, the UI would by default have URL
                    "<literal>/myproject/my-cdi</literal>". If you do not want to have the
                    servlet mapped to context root, you can use the
                    <classname>@URLMapping</classname> annotation to map all CDI UIs to a
                    sub-path. The annotation must be given to only one CDI UI, usually the
                    one with the default ("") path.
                </para>

                <para>
                    For example, if we have a root UI and another:
                </para>

            <programlisting><?pocket-size 75% ?><![CDATA[@CDIUI("") // At CDI servlet root
@URLMapping("mycdiuis") // Define CDI Servlet root
public class MyCDIRootUI extends UI {...}

@CDIUI("another")
public class AnotherUI extends UI {...}]]></programlisting>

                <para>
                    These two UIs would have URLs <uri>/myproject/mycdiuis</uri> and
                    <uri>/myproject/mycdiuis/another</uri>, respectively.
                </para>

                <para>
                    You can also map the CDI servlet to another URL in servlet definition
                    in <filename>web.xml</filename>, as described the following.
                </para>
            </section>

            <section xml:id="advanced.cdi.servlets.mixing">
                <title>Mixing With Other Servlets</title>

                <para>
                    The <classname>VaadinCDIServlet</classname> is normally used as the
                    default servlet, but if you have other servlets in the application,
                    such as for non-CDI UIs, you need to define the CDI servlet explicitly
                    in the <filename>web.xml</filename>. You can map the servlet to any
                    URL path, but perhaps typically, you define it as the default servlet
                    as follows, and map the other servlets to other URL paths:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<web-app>
  ...

  <servlet>
    <servlet-name>Default</servlet-name>
    <servlet-class>
      com.vaadin.cdi.internal.VaadinCDIServlet
    </servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>Default</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>

  <servlet-mapping>
    <servlet-name>Default</servlet-name>
    <url-pattern>/VAADIN/*</url-pattern>
  </servlet-mapping>
</web-app>]]></programlisting>

            </section>

            <section xml:id="advanced.cdi.servlets.custom">
                <title>Custom Servlets</title>

                <para>
                    When customizing the Vaadin servlet, as outlined in <xref
                    linkend="application.lifecycle.servlet-service"/>, you simply need to
                    extend <classname>com.vaadin.cdi.internal.VaadinCDIServlet</classname>
                    instead of <classname>com.vaadin.servlet.VaadinServlet</classname>.
                </para>

                <para>
                    The custom servlet must not have <classname>@WebServlet</classname>
                    annotation or <classname>@VaadinServletConfiguration</classname>, as
                    you would normally with a Vaadin servlet, as described in <xref
                    linkend="application.environment"/>.
                </para>
            </section>
        </section>

        <section xml:id="advanced.cdi.navigation" condition="web">
            <title>View Navigation</title>

            <para>
                Vaadin CDI extends the navigation framework in Vaadin, described in <xref
                linkend="advanced.navigator"/>. It manages CDI views with a special view
                provider and enables view scoping.
            </para>

            <section xml:id="advanced.cdi.navigation.ui">
                <title>Preparing the UI</title>

                <para>
                    You can define navigation for any single-component container, as
                    described in <xref linkend="advanced.navigator.navigating"/>, but
                    typically you set up navigation for the entire UI content. To use
                    Vaadin CDI views, you need to inject a
                    <classname>CDIViewProvider</classname> in the UI and add it as a
                    provider for the navigator.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@CDIUI("mycdiui")
public class MyCDIUI extends UI {
    @Inject
    CDIViewProvider viewProvider;
    
    @Override
    protected void init(VaadinRequest request) {
        Navigator navigator = new Navigator(this, this);
        navigator.addProvider(viewProvider);

        // Navigate to start view
        navigator.navigateTo("");
    }
}]]></programlisting>

            </section>

            <section xml:id="advanced.cdi.navigation.view">
                <title>The View</title>

                <para>
                    A view managed by Vaadin CDI only needs to have the
                    <classname>@CDIView</classname> annotation.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[@CDIView("main")
public class MainView extends CustomComponent implements View {
    ...]]></programlisting>


                <para>
                    The annotation can have the following optional paramers:
                </para>

                <variablelist>
                    <varlistentry>
                        <term>value (optional)</term>
                        <listitem>
                            <para>
                                Specifies the view name by which it can be accessed
                                programmatically and by the URI fragment.
                            </para>

                            <programlisting><?pocket-size 75% ?><![CDATA[@CDIView("main")]]></programlisting>

                            <para>
                                If other optional parameters are given, the value must be
                                given by the named <parameter>value</parameter> parameter.
                            </para>

                            <para>
                                If the view name is not given, it is derived from the
                                class name by removing a possible "View" suffix, making it
                                lower case, and using a dash ("-") to separate words
                                originally denoted by capital letters. Thereby, a view
                                class such as <classname>MyFunnyView</classname> would
                                have name "<literal>my-funny</literal>".
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>supportsParameters</term>
                        <listitem>
                            <para>
                                Specifies whether view parameters can be passed to the
                                view as a suffix to the name in the navigation state, that
                                is, in the form of
                                <literal>viewname+viewparameters</literal>. The view name
                                is merely a prefix and there is no separator nor format
                                for the parameters, but those are left for the view to
                                handle. The parameter support mode is disabled by default.
                            </para>

                            <programlisting><?pocket-size 75% ?><![CDATA[@CDIView(value="myview", supportsParameters=true)]]></programlisting>

                            <para>
                                You could then navigate to the state with a URI fragment
                                such as <literal>#!myview/someparameter</literal> or programmatically with:
                            </para>

                            <programlisting><?pocket-size 70% ?><![CDATA[getUI().getNavigator().navigateTo("myview/someparameter");]]></programlisting>

                            <para>
                                The <methodname>enter()</methodname> method of the view
                                gets the URI fragment as parameter as is and can interpret
                                it in any application-defined way.
                            </para>
                            
                            <para>
                                Note that in this mode, matching a navigation state to a
                                view is done by the prefix of the fragment! Thereby, no
                                other views may start with the name of the view as
                                prefix. For example, if the view name is
                                "<literal>main</literal>", you must not have a view named
                                "<literal>maintenance</literal>".
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>uis</term>
                        <listitem>
                            <para>
                                If the application has multiple UIs that use
                                <classname>CDIViewProvider</classname>, you can use this
                                parameter to specify which UIs can show the view.
                            </para>

                            <programlisting><?pocket-size 75% ?><![CDATA[@CDIView(value="myview", uis={MyCDIUI.class})]]></programlisting>

                            <para>
                                If the list contains <parameter>UI.class</parameter>, the
                                view is available to all UIs.
                            </para>

                            <programlisting><?pocket-size 75% ?><![CDATA[@CDIView(value="myview", uis={UI.class})]]></programlisting>
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In the following, we have a login view that accesses a session-scoped
                    user object. Here, we use a constant to define the view name, so that
                    we can use the constant when navigating to it.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@CDIView(LoginView.VIEWNAME)
public class LoginView extends CustomComponent
                       implements View {
    public final static String VIEWNAME = "";
    
    // Here we inject to the constructor and actually do
    // not store the injected object to use it later
    @Inject
    public LoginView(User user) {
        VerticalLayout layout = new VerticalLayout();
        
        // An input field for editing injected data
        BeanItem<User> item = new BeanItem<User>(user);
        TextField username = new TextField("User name",
                item.getItemProperty("name"));
        username.setNullRepresentation("");
        layout.addComponent(username);

        // Login button (authentication omitted) / Java 8
        layout.addComponent(new Button("Login", e ->
            getUI().getNavigator().
                navigateTo(MainView.VIEWNAME)));
        
        setCompositionRoot(layout);
    }
    
    @Override
    public void enter(ViewChangeEvent event) {}
}]]></programlisting>

                <para>
                    You could now navigate to the view from any other view in the UI with:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[getUI().getNavigator().navigateTo(LoginView.VIEWNAME);]]></programlisting>
            </section>
        </section>

        <section xml:id="advanced.cdi.events" condition="web">
            <title>CDI Events</title>

            <indexterm xml:id="term.advanced.cdi.events" class="startofrange">
                <primary>CDI</primary>
                <secondary>events</secondary>
            </indexterm>

            <para>
                CDI events can be used for many purposes in Vaadin applications, such as
                passing messages between different parts of a view, between views, between
                UIs, or between users. Some cases require special consideration, such as
                when communicating between UIs and how injected components should be
                scoped.
            </para>

            <section xml:id="advanced.cdi.events.intro">
                <title>Observing Events</title>

                <para>
                    Let us consider a case where changes in one part of the UI (or view)
                    require updating other parts of the UI. This is typical in
                    master-detail views, for updating the master view after editing
                    details, or when handling input from a sub-window. While you can
                    handle such a situation with a custom call-back listener, CDI event
                    mechanism simplifies the task.
                </para>

                <para>
                    Let us consider the following simple UI containing two panels. The
                    input panel will send events, which are received by other parts of the
                    UI, in this case a display panel. The panels need to be injected to
                    enable CDI event passing in them.
                </para>

                <programlisting><?pocket-size 70% ?><![CDATA[@CDIUI("cdievents")
@Theme("valo")
public class CDIEventUI extends UI {
    @Inject
    InputPanel inputPanel;

    @Inject
    DisplayPanel displayPanel;

    @Override
    protected void init(VaadinRequest request) {
        Layout content =
            new HorizontalLayout(inputPanel, displayPanel);
        setContent(content);
    }
}]]></programlisting>

                <para>
                    Now, let us look closer at the sending panel. To send messages, it
                    needs to inject a <classname>javax.enterprise.event.Event</classname>
                    object. As we are injecting the event to a component class, we need to
                    specify the full package name to avoid confusion with Vaadin
                    <classname>Component.Event</classname>.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[class InputPanel extends Panel {
    @Inject
    private javax.enterprise.event.Event<MyEvent> event;

    public InputPanel() {
        super("Input");

        TextField editor = new TextField();
        Button save = new Button("Save", e -> // Java 8
            event.fire(new MyEvent(editor.getValue())));

        setContent(new VerticalLayout(editor, save));
    }
}]]></programlisting>

                <para>
                    Firing an event is done with the <methodname>fire()</methodname>
                    method on the injected event object. In our example, the event is as
                    follows:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[public class MyEvent implements Serializable {
    private String text;
    
    public MyEvent(String text) {
        this.text = text;
    }
    
    public String getName() {
        return text;
    }
}]]></programlisting>

                <para>
                    The event is received by any method (in an injected object) marked by
                    <classname>@Observes</classname> annotation for the event parameter to
                    observe the event type.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@UIScoped
class DisplayPanel extends Panel {
    Label display = new Label("-nothing to display-");

    public DisplayPanel() {
        super("Display");
        setContent(display);
    }
    
    void myEventObserver(@Observes MyEvent event) {
        display.setValue("Observed: " + event.getName());
    }
}]]></programlisting>

                <para>
                    Such a component that observes events from other components must be
                    scoped to the UI or view, as otherwise it will be request-scoped and a
                    new instance is created for receiving each event.
                </para>

                <para>
                    The UI with interaction is shown in <xref linkend="figure.advanced.cdi.events.intro"/>.
                </para>
                
                <figure xml:id="figure.advanced.cdi.events.intro">
                    <title>Observing CDI Events</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/cdi-events-observing.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>


                <para>
                    Any injection qualifiers defined for the event object in the sender
                    are matched in the observers, which feature we will use later to avoid
                    receiving unwanted events.
                </para>
            </section>

            <section xml:id="advanced.cdi.events.broadcasting">
                <title>Communicating Between UIs</title>

                <indexterm xml:id="term.advanced.cdi.events.broadcasting" class="startofrange">
                    <primary>broadcasting</primary>
                </indexterm>

                <para>
                    CDI events are not propagated to inactive contexts, and only the
                    context of the currently processed UI is active. Further, as explained
                    in <xref linkend="advanced.push.running"/>, other Vaadin UIs may not
                    be accessed without proper synchronization, as their requests are
                    processed concurrently in different server threads. Therefore, you
                    need to pass the events through an application-scoped messaging
                    service and synchronize the access to other UIs by using the
                    <methodname>access()</methodname> method.
                </para>

                <para>
                    In <xref linkend="advanced.push.pusharound"/> we looked into how to
                    pass messages to all other UIs using a broadcasting service. In that
                    example, we used static variables and methods to store references and
                    to access the service. With CDI, we can let the context manage its
                    lifecycle, access it by injection, and pass messages by CDI events. By
                    scoping the messaging service to application, we essentially make it a
                    singleton.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@ApplicationScoped
public class CDIBroadcaster implements Serializable {]]></programlisting>

                <para>
                    As we can not let CDI deliver the messages, the messaging service
                    needs to keep book of the messaging clients (UIs) waiting to receive
                    messages.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[    private Collection<UI> uis = new HashSet<UI>();
    
    public synchronized void register(UI listener) {
        uis.add(listener);
    }
    
    public synchronized void unregister(UI listener) {
        uis.remove(listener);
    }]]></programlisting>

                <para>
                    The main logic of the messaging service is to observe messages and
                    fire them in the recipient UIs. As we are broadcasting to all UIs
                    here, we again use an executor service to execute the code. To lock on
                    the session when accessing the UIs, we use the
                    <methodname>access()</methodname> method.
                </para>

                <programlisting><?pocket-size 70% ?><![CDATA[    // Inject event to be fired
    @Inject
    private javax.enterprise.event.Event<BroadcastMessage>
            messageEvent;

    ExecutorService executorService =
        Executors.newSingleThreadExecutor();

    // Observe messages (only from clients)
    @SuppressWarnings("unused")
    private synchronized void observeMessage(
            @Observes @OriginalSender
            final BroadcastMessage message) {
        for (final UI listener: uis)
            executorService.execute(() ->
                listener.access(()->
                    messageEvent.fire(message)));
    }
}]]></programlisting>

                <para>
                    Here we use a <classname>@OriginalSender</classname> qualifier to
                    receive events only from a client (original sender), not from the
                    messaging service itself, which would cause an infinite event
                    loop. The qualifier is defined as follows:
                </para>

                <indexterm><primary>CDI</primary><secondary>qualifiers</secondary></indexterm>
                <programlisting><?pocket-size 75% ?><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({PARAMETER, FIELD})
public @interface OriginalSender {}]]></programlisting>

                <para>
                    The message type is a simple POJO as follows:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[public class BroadcastMessage {
    private String text;
    private Object sender; // For checking if sent by self

    ... constructor, getters, and setters ...
}]]></programlisting>

                <para>
                    Let us take a look at the UI class, which manages both the messaging
                    service and the client components. The UI just needs to register
                    itself in the messaging service and build the UI, including the UI
                    components doing messaging. We could, of course, do that also at view
                    level.
                </para>

                <indexterm><primary><classname>@Push</classname></primary></indexterm>
                <programlisting><?pocket-size 75% ?><![CDATA[@CDIUI("cdichat")
@Push
public class CDIChatUI extends UI {
    @Inject
    CDIBroadcaster broadcaster;
    
    @Inject
    ChatBox chatbox;

    @Override
    protected void init(VaadinRequest request) {
        setContent(chatbox);
        
        // Register to receive broadcasts
        broadcaster.register(this);
    }

    // Must also unregister when the UI expires or is closed    
    @Override
    public void detach() {
        broadcaster.unregister(this);
        super.detach();
    }
}]]></programlisting>

                <para>
                    Now for an actual messaging client, we look at the chat box
                    component. Most of the UI code is omitted from the example. As noted
                    earlier, the component receiving events must be scoped to the UI, to
                    avoid creation of invalid instances.
                </para>

                <indexterm><primary><classname>@UIScoped</classname></primary></indexterm>
                <programlisting><?pocket-size 65% ?><![CDATA[@UIScoped
class ChatBox extends CustomComponent {
    VerticalLayout messages = new VerticalLayout();
    
    public ChatBox(CDIChatUI cdiChatUI) {
        ... build the composite ...

        TextField input = new TextField();

        Button send = new Button("Send", e -> { // Java 8
            // Broadcast the input
            broadcast(input.getValue());
            addMessage(input.getValue()); // Add to self
        });
        ...
    }
    
    @Inject
    @OriginalSender
    private javax.enterprise.event.Event<BroadcastMessage>
        messageEvent;
    
    // Sends a message
    private void broadcast(String msg) {
        messageEvent.fire(new BroadcastMessage(msg, this));
    }

    // Receives messages
    @SuppressWarnings("unused")
    private void observeMessage(
            @Observes BroadcastMessage event) {
        if (event.getSender() != this)
            addMessage(event.getText());
    }

    private void addMessage(String msg) {
        messages.addComponent(new Label(msg));
    }
}]]></programlisting>

                <indexterm><primary>CDI</primary><secondary>qualifiers</secondary></indexterm>

                <para>
                    Note that the client object is completely unaware of the fact that the
                    messages are delivered through a messaging service; we have
                    successfully decoupled the messaging logic required by Vaadin UIs from
                    the component. Only the requirement for using the event qualifier
                    remains (notice that its use is not checked at compile time).
                </para>

                <indexterm startref="term.advanced.cdi.events.broadcasting" class="endofrange"/>
            </section>

            <indexterm startref="term.advanced.cdi.events" class="endofrange"/>
        </section>

        <indexterm startref="term.advanced.cdi.cdilong" class="endofrange"/>
        <indexterm startref="term.advanced.cdi.cdi" class="endofrange"/>
        <indexterm startref="term.advanced.cdi.cdiaddon" class="endofrange"/>
    </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

