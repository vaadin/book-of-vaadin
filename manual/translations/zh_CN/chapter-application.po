# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-10-31 15:46+0000\n"
"PO-Revision-Date: 2014-11-01 02:39+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-application.xml:11
#, no-c-format
msgid "Writing a Server-Side Web Application"
msgstr "编写服务器端 Web 应用程序"

#. Tag: para
#: chapter-application.xml:13
#, no-c-format
msgid ""
"This chapter provides the fundamentals of server-side web application "
"development with Vaadin, concentrating on the basic elements of an "
"application from a practical point-of-view."
msgstr ""
"本章概要介绍如何进行 Vaadin 服务器端 Web 应用程序开发, 主要从实践角度介绍应用"
"程序的基本元素."

#. Tag: title
#: chapter-application.xml:20
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-application.xml:22
#, no-c-format
msgid ""
"A server-side Vaadin application runs as a Java Servlet in a servlet "
"container. The Java Servlet API is, however, hidden behind the framework. "
"The user interface of the application is implemented as a <emphasis>&ui;</"
"emphasis> class, which needs to create and manage the user interface "
"components that make up the user interface. User input is handled with event "
"listeners, although it is also possible to bind the user interface "
"components directly to data. The visual style of the application is defined "
"in themes as CSS and SCSS files. Icons, other images, and downloadable files "
"are handled as <emphasis>resources</emphasis>, which can be external or "
"served by the application server or the application itself."
msgstr ""
"服务器端 Vaadin 应用程序以 Java Servlet 形式运行在 Servlet 容器内. 但 Java "
"Servlet API 已被隐藏在开发框架之后. 应用程序的 UI 由 <emphasis>&ui;</"
"emphasis> 类实现, 它需要创建并管理构成用户界面的那些 UI 组件. 用户输入由事件"
"监听器负责处理, 当然也可以将 UI 组件直接绑定到数据上. 应用程序的外观风格由 "
"CSS 和 SCSS 形式的 theme 来定义. 图标, 其他图像, 以及可被下载的文件以 "
"<emphasis>资源</emphasis> 的形式管理起来, 资源可以是外部资源, 也可以由应用程"
"序服务器或应用程序本身向外提供."

#. Tag: title
#: chapter-application.xml:36
#, no-c-format
msgid "Server-Side Application Architecture"
msgstr "服务器端应用程序架构"

#. Tag: para
#: chapter-application.xml:47
#, no-c-format
msgid ""
"illustrates the basic architecture of an application made with the Vaadin "
"Framework, with all the major elements, which are introduced below and "
"discussed in detail in this chapter."
msgstr ""
"展示了用 Vaadin 框架开发的应用程序的基本架构, 其中包含所有的主要元素, 详情将"
"在本章后续部分中进行介绍."

#. Tag: para
#: chapter-application.xml:54
#, no-c-format
msgid ""
"First of all, a Vaadin application must have one or more &ui; classes that "
"extend the abstract <classname>com.vaadin.ui.&uiclass;</classname> class and "
"implement the <methodname>init()</methodname> method. A custom theme can be "
"defined as an annotation for the &ui;."
msgstr ""
"首先, Vaadin 应用程序必须包含一个或多个 &ui; 类, &ui; 类继承自抽象类 "
"<classname>com.vaadin.ui.&uiclass;</classname>, 并实现 <methodname>init()</"
"methodname> 方法. 可以用 Java 注解的方式为  &ui; 指定自定义的 theme."

#. Tag: programlisting
#: chapter-application.xml:61
#, no-c-format
msgid ""
"<![CDATA[@Theme(\"hellotheme\")\n"
"public class HelloWorld extends UI {\n"
"    protected void init(VaadinRequest request) {\n"
"        ... initialization code goes here ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:63
#, no-c-format
msgid ""
"A &ui; is a viewport to a Vaadin application running in a web page. A web "
"page can actually have multiple such &ui;s within it. Such situation is "
"typical especially with portlets in a portal. An application can run in "
"multiple browser windows, each having a distinct <classname>UI</classname> "
"instance. The UIs of an application can be the same UI class or different."
msgstr ""
"&ui; 是Vaadin 应用程序运行在 Web 页面内时展现给用户的可见部分. Web 页面内可以"
"包含多个这样的 &ui;. 对于 portal 中的 portlet, 这样的情况是很典型的. 应用程序"
"可以在浏览器的多个窗口中运行, 每个窗口都拥有一个单独的 <classname>UI</"
"classname> 实例. 应用程序的 UI 实例可以是相同的 UI 类, 也可以是不同的 UI 类."

#. Tag: para
#: chapter-application.xml:71
#, no-c-format
msgid ""
"Vaadin framework handles servlet requests internally and associates the "
"requests with user sessions and a UI state. Because of this, you can develop "
"Vaadin applications much like you would develop desktop applications."
msgstr ""
"Vaadin 框架内部会处理 Servlet 请求, 并将请求与相应的用户 Session 和 UI 状态关"
"联起来. 因此, 你可以用类似于桌面应用程序的方式来开发 Vaadin 应用程序."

#. Tag: para
#: chapter-application.xml:77
#, no-c-format
msgid ""
"The most important task in the initialization is the creation of the initial "
"user interface. This, and the deployment of a UI as a Java Servlet in the "
"Servlet container, as described in <xref linkend=\"application.environment\"/"
">, are the minimal requirements for an application."
msgstr ""
"应用程序的初始化部分最重要的任务是创建初期 UI. UI 的创建, 以及将 UI 以 Java "
"Servlet 的形式发布到 Servlet 容器中, 是开发一个应用程序所需要的最低要求. 关"
"于 UI 的发布, 详情参见 <xref linkend=\"application.environment\"/>"

#. Tag: para
#: chapter-application.xml:84
#, no-c-format
msgid ""
"Below is a short overview of the other basic elements of an application "
"besides &ui;:"
msgstr "除 &ui; 外, 应用程序还包括以下基本一些元素:"

#. Tag: term
#: chapter-application.xml:91
#, no-c-format
msgid "&uiclass;"
msgstr ""

#. Tag: para
#: chapter-application.xml:93
#, no-c-format
msgid ""
"A <emphasis>&ui;</emphasis> represents an HTML fragment in which a Vaadin "
"application runs in a web page. It typically fills the entire page, but can "
"also be just a part of a page. You normally develop a Vaadin application by "
"extending the <classname>&uiclass;</classname> class and adding content to "
"it. A &ui; is essentially a viewport connected to a user session of an "
"application, and you can have many such views, especially in a multi-window "
"application. Normally, when the user opens a new page with the URL of the "
"Vaadin UI, a new <classname>UI</classname> (and the associated "
"<classname>Page</classname> object) is automatically created for it. All of "
"them share the same user session."
msgstr ""
"一个 <emphasis>&ui;</emphasis> 表现为 Web 页面内的一个 HTML 片段, Vaadin 应用"
"程序运行就运行在这个片段内. UI 通常占满整个页面, 但也可以只是页面的一部分. 开"
"发一个 Vaadin 应用程序的方法, 通常是扩展 <classname>&uiclass;</classname> "
"类, 并向其中添加内容. &ui; 本质上来说是一个可视区域, 与应用程序的用户 "
"Session 相关联, 在应用程序中你可以拥有很多这样的可视区域, 尤其是多窗口应用程"
"序的情况. 一般来说, 当用户使用 Vaadin UI 的 URL 打开一个新页面时, 一个新的 "
"<classname>UI</classname> 实例(以及与它关联的 <classname>Page</classname> 对"
"象) 将会自动创建. 对同一个客户端来说, 所有的 UI 实例都共享同一个用户 Session."

#. Tag: para
#: chapter-application.xml:108
#, no-c-format
msgid ""
"The current &ui; object can be accessed globally with <methodname>UI."
"getCurrent()</methodname>. The static method returns the thread-local &ui; "
"instance for the currently processed request<phrase condition=\"web\"> (see "
"<xref linkend=\"advanced.global.threadlocal\"/>)</phrase>."
msgstr ""
"当前的 &ui; 对象, 在任何地方都可以通过 <methodname>UI.getCurrent()</"
"methodname> 方法得到. 这个静态方法针对当前处理中的请求, 返回一个 &ui; 的 "
"thread-local 实例, <phrase condition=\"web\"> (详情参见 <xref linkend="
"\"advanced.global.threadlocal\"/>)</phrase>."

#. Tag: term
#: chapter-application.xml:119
#, no-c-format
msgid "Page"
msgstr ""

#. Tag: para
#: chapter-application.xml:121
#, no-c-format
msgid ""
"A <classname>&uiclass;</classname> is associated with a <classname>Page</"
"classname> object that represents the web page as well as the browser window "
"in which the &ui; runs."
msgstr ""
"一个 <classname>&uiclass;</classname> 对象总是关联到一个 <classname>Page</"
"classname> 对象上,  <classname>Page</classname> 对象表示 &ui; 运行时所属的 "
"Web 页面和浏览器窗口."

#. Tag: para
#: chapter-application.xml:127
#, no-c-format
msgid ""
"The <classname>Page</classname> object for the currently processed request "
"can be accessed globally from a Vaadin application with <methodname>Page."
"getCurrent()</methodname>. This is equivalent to calling "
"<methodname>&uiclass;.getCurrent().getPage()</methodname>."
msgstr ""
"在 Vaadin 应用程序内, 当前处理中的请求所关联的 <classname>Page</classname> 对"
"象, 在任何地方都可以通过 <methodname>Page.getCurrent()</methodname> 方法取"
"得. 这个方法等价于调用 <methodname>&uiclass;.getCurrent().getPage()</"
"methodname> 方法."

#. Tag: term
#: chapter-application.xml:138
#, no-c-format
msgid "Vaadin Session"
msgstr ""

#. Tag: para
#: chapter-application.xml:140
#, no-c-format
msgid ""
"A <classname>VaadinSession</classname> object represents a user session with "
"one or more UIs open in the application. A session starts when a user first "
"opens a UI of a Vaadin application, and closes when the session expires in "
"the server or when it is closed explicitly."
msgstr ""
"一个 <classname>VaadinSession</classname> 对象代表应用程序中的一个用户 "
"Session, 其中有一个或多个 UI 正在使用中. 当用户初次打开 Vaadin 应用程序的 UI "
"时 Session 开始, 当服务器端 Session 超期时, Session 关闭, Session 也可以显式"
"关闭."

#. Tag: term
#: chapter-application.xml:151
#, no-c-format
msgid "User Interface Components"
msgstr "UI 组件"

#. Tag: para
#: chapter-application.xml:153
#, no-c-format
msgid ""
"The user interface consists of components that are created by the "
"application. They are laid out hierarchically using special <emphasis>layout "
"components</emphasis>, with a content root layout at the top of the "
"hierarchy. User interaction with the components causes <emphasis>events</"
"emphasis> related to the component, which the application can handle. "
"<emphasis>Field components</emphasis> are intended for inputting values and "
"can be directly bound to data using the Vaadin Data Model. You can make your "
"own user interface components through either inheritance or composition. For "
"a thorough reference of user interface components, see <xref linkend="
"\"components\"/>, for layout components, see <xref linkend=\"layout\"/>, and "
"for compositing components, see <xref linkend=\"components.customcomponent\"/"
">."
msgstr ""
"UI 由应用程序创建的组件构成. 组件的层级布局由特别的 <emphasis>布局组件</"
"emphasis> 管理, 层级的最高层是内容的根(content root ). 用户对组件的操作会激发"
"与这个组件相关的 <emphasis>事件</emphasis>, 事件由应用程序处理. "
"<emphasis>Field 组件</emphasis> 用于输入数据, 它可以通过 Vaadin 数据模型直接"
"绑定到数据上. 你可以用继承或组合的方式编写你自己的 UI 组件. 关于各种 UI 组件"
"的详细介绍, 请参见 <xref linkend=\"components\"/>, 关于布局组件, 请参见 "
"<xref linkend=\"layout\"/>, 关于组件的组合, 请参见 <xref linkend="
"\"components.customcomponent\"/>."

#. Tag: term
#: chapter-application.xml:172
#, no-c-format
msgid "Events and Listeners"
msgstr "事件与监听器"

#. Tag: para
#: chapter-application.xml:174
#, no-c-format
msgid ""
"Vaadin follows an event-driven programming paradigm, in which events, and "
"listeners that handle the events, are the basis of handling user interaction "
"in an application (although also server push is possible as described in "
"<xref linkend=\"advanced.push\"/>). <xref linkend=\"architecture.events\"/> "
"gave an introduction to events and listeners from an architectural point-of-"
"view, while <xref linkend=\"application.events\"/> later in this chapter "
"takes a more practical view."
msgstr ""
"Vaadin 遵循事件驱动编程范式, 在这种编程范式中, 事件和负责处理事件的监听器, 是"
"用来处理应用程序中用户操作的基本方法. (当然, 服务器端 PUSH 也是另一种可能的手"
"段, 详情参见 <xref linkend=\"advanced.push\"/>) <xref linkend=\"architecture."
"events\"/> 从技术层面介绍事件和监听器, 本章后续部分的 <xref linkend="
"\"application.events\"/> 则从更侧重实践的角度进行介绍."

#. Tag: term
#: chapter-application.xml:188
#, no-c-format
msgid "Resources"
msgstr "资源"

#. Tag: para
#: chapter-application.xml:190
#, no-c-format
msgid ""
"A user interface can display images or have links to web pages or "
"downloadable documents. These are handled as <emphasis>resources</emphasis>, "
"which can be external or provided by the web server or the application "
"itself. <xref linkend=\"application.resources\"/> gives a practical overview "
"of the different types of resources."
msgstr ""
"UI 可以显示图片, 也可以包含 Web 页面链接, 或可供下载的文档链接. 这些都以 "
"<emphasis>resource</emphasis> 的形式进行处理, 资源可以是外部的, 也可以由 Web "
"服务器或应用程序本身提供. <xref linkend=\"application.resources\"/> 概要介绍"
"各种不同类型的资源."

#. Tag: term
#: chapter-application.xml:202
#, no-c-format
msgid "Themes"
msgstr "Theme"

#. Tag: para
#: chapter-application.xml:204
#, no-c-format
msgid ""
"The presentation and logic of the user interface are separated. While the UI "
"logic is handled as Java code, the presentation is defined in "
"<emphasis>themes</emphasis> as CSS or SCSS. Vaadin includes some built-in "
"themes. User-defined themes can, in addition to style sheets, include HTML "
"templates that define custom layouts and other theme resources, such as "
"images. Themes are discussed in detail in <xref linkend=\"themes\"/>, custom "
"layouts in <xref linkend=\"layout.customlayout\"/>, and theme resources in "
"<xref linkend=\"application.resources.theme\"/>."
msgstr ""
"UI 的外观表现与它的控制逻辑是分离的. UI 的逻辑由 Java 代码控制, 外观表现则由 "
"CSS 或 SCSS 形式的 <emphasis>theme</emphasis> 来定义. Vaadin 包含了一些内建"
"的 theme. 用户自定义的 theme, 除样式表外, 还可以包含用于定义 HTML 元素布局的 "
"HTML 模板, 以及其他 theme 资源, 比如图片. Theme 的详细介绍参见 <xref linkend="
"\"themes\"/>, HTML 元素布局参见 <xref linkend=\"layout.customlayout\"/>, "
"theme 资源参见 <xref linkend=\"application.resources.theme\"/>."

#. Tag: term
#: chapter-application.xml:220
#, no-c-format
msgid "Data Binding"
msgstr "数据绑定"

#. Tag: para
#: chapter-application.xml:222
#, no-c-format
msgid ""
"Field components are essentially views to data, represented in the "
"<emphasis>Vaadin Data Model</emphasis>. Using the data model, the components "
"can get their values from and update user input to the data model directly, "
"without the need for any control code. A field component is always bound to "
"a <emphasis>property</emphasis> and a group of fields to an <emphasis>item</"
"emphasis> that holds the properties. Items can be collected in a "
"<emphasis>container</emphasis>, which can act as a data source for some "
"components such as tables or lists. While all the components have a default "
"data model, they can be bound to a user-defined data source. For example, "
"you can bind a <classname>Table</classname> component to an SQL query "
"response. For a complete overview of data binding in Vaadin, please refer to "
"<xref linkend=\"datamodel\"/>."
msgstr ""
"Field 组件本质上来说就是数据的外部展现, 数据是通过 <emphasis>Vaadin 数据模型"
"</emphasis> 表达的. 使用这个数据模型, 组件可以从模型直接得到数据值, 也可以将"
"用户输入直接更新到模型中, 而不必编写任何控制代码. 单个 Field 组件总是绑定到 "
"<emphasis>property</emphasis> 上, 一组 Field 总是绑定到一个管理 property 的 "
"<emphasis>item</emphasis> 上. Item 由 <emphasis>container</emphasis> 管理, 对"
"某些组件来说, 比如 table 或 list, container可以看作一个数据源. 所有的组件都有"
"一个默认的数据模型, 它们也可以绑定到用户定义的数据源. 比如, 你可以绑定一个 "
"<classname>Table</classname> 组件到一个 SQL 查询结果上. 关于 Vaadin 中数据绑"
"定的完整介绍, 请参见 <xref linkend=\"datamodel\"/>."

#. Tag: title
#: chapter-application.xml:244
#, no-c-format
msgid "Building the UI"
msgstr "构建 UI"

#. Tag: para
#: chapter-application.xml:246
#, no-c-format
msgid ""
"Vaadin user interfaces are built hierarchically from components, so that the "
"leaf components are contained within layout components and other component "
"containers. Building the hierarchy starts from the top (or bottom - "
"whichever way you like to think about it), from the <classname>UI</"
"classname> class of the application. You normally set a layout component as "
"the content of the UI and fill it with other components."
msgstr ""
"Vaadin UI 是由多个组件的层级构成的, 因此下层组件被包含在布局组件或其他某种组"
"件容器之内. 构建组件层级结构首先从最顶层开始(从最底层开始也可以 - 取决于你考"
"虑这个问题的方式), 最顶层就是应用程序的 <classname>UI</classname> 类. 通常我"
"们将一个布局组件设置为 UI 的内容, 并将其他组件填充到布局组件内."

#. Tag: programlisting
#: chapter-application.xml:255
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyHierarchicalUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        // The root of the component hierarchy\n"
"        VerticalLayout content = new VerticalLayout();\n"
"        content.setSizeFull(); // Use entire window\n"
"        setContent(content);   // Attach to the UI\n"
"        \n"
"        // Add some component\n"
"        content.addComponent(new Label(\"Hello!\"));\n"
"        \n"
"        // Layout inside layout\n"
"        HorizontalLayout hor = new HorizontalLayout();\n"
"        hor.setSizeFull(); // Use all available space\n"
"\n"
"        // Couple of horizontally laid out components\n"
"        Tree tree = new Tree(\"My Tree\",\n"
"                TreeExample.createTreeContent());\n"
"        hor.addComponent(tree);\n"
"\n"
"        Table table = new Table(\"My Table\",\n"
"                TableExample.generateContent());\n"
"        table.setSizeFull();\n"
"        hor.addComponent(table);\n"
"        hor.setExpandRatio(table, 1); // Expand to fill\n"
"\n"
"        content.addComponent(hor);\n"
"        content.setExpandRatio(hor, 1); // Expand to fill\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:257
#, no-c-format
msgid "The component hierarchy could be illustrated with a tree as follows:"
msgstr "组件层级结构类似于树的形式, 如下:"

#. Tag: programlisting
#: chapter-application.xml:261
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[UI\n"
" `-- VerticalLayout\n"
"   |-- Label\n"
"   `-- HorizontalLayout\n"
"     |-- Tree\n"
"     `-- Table]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:263
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.application.architecture."
"example\"/>."
msgstr ""
"以上代码的运行结果见 <xref linkend=\"figure.application.architecture.example"
"\"/>."

#. Tag: title
#: chapter-application.xml:268
#, no-c-format
msgid "Simple Hierarchical UI"
msgstr "简单的层级式 UI"

#. Tag: para
#: chapter-application.xml:276
#, no-c-format
msgid ""
"The built-in components are described in <xref linkend=\"components\"/> and "
"the layout components in <xref linkend=\"layout\"/>."
msgstr ""
"Vaadin 的内建组件参见 <xref linkend=\"components\"/>, 布局组件参见 <xref "
"linkend=\"layout\"/>."

#. Tag: para
#: chapter-application.xml:282
#, no-c-format
msgid ""
"The example application described above just is, it does not do anything. "
"User interaction is handled with event listeners, as described a bit later "
"in <xref linkend=\"application.events\"/>."
msgstr ""
"上面给出的示例程序还是都做不了. 用户操作由事件监听器处理, 详情参见 <xref "
"linkend=\"application.events\"/>."

#. Tag: title
#: chapter-application.xml:289
#, no-c-format
msgid "Application Architecture"
msgstr "应用程序架构"

#. Tag: para
#: chapter-application.xml:291
#, no-c-format
msgid ""
"Once your application grows beyond a dozen or so lines, which is usually "
"quite soon, you need to start considering the application architecture more "
"closely. You are free to use any object-oriented techniques available in "
"Java to organize your code in methods, classes, packages, and libraries. An "
"architecture defines how these modules communicate together and what sort of "
"dependencies they have between them. It also defines the scope of the "
"application. The scope of this book, however, only gives a possibility to "
"mention some of the most common architectural patterns in Vaadin "
"applications."
msgstr ""
"一旦你的应用程序增长到数十行的程度(通常很快就会如此), 你就需要更仔细地考虑应"
"用程序架构的问题了. 你可以自由地使用 Java 中的任何面向对象技术, 将你的代码组"
"织为方法, 类, 包, 以及库的形式. 应用程序架构定义了模块之间如何通信以及各模块"
"间的相互依赖关系. 还定义了应用程序关注的范围. 在本书中, 我们只略微提及 "
"Vaadin 应用程序中常见的一些架构模式."

#. Tag: para
#: chapter-application.xml:303
#, no-c-format
msgid ""
"The subsequent sections describe some basic application patterns. For more "
"information about common architectures, see <xref linkend=\"advanced."
"architecture\"/>, which discusses layered architectures, the Model-View-"
"Presenter (MVP) pattern, and so forth. <phrase condition=\"web\">The <xref "
"linkend=\"advanced.global\"/> discusses the problem of passing essentially "
"global references around, a common problem which is also visited in <xref "
"linkend=\"application.architecture.accessing\"/>.</phrase>"
msgstr ""
"后续的各节将介绍一个基本的应用程序模式. 关于常见的应用程序架构, 详情请参见"
"<xref linkend=\"advanced.architecture\"/>, 其中将介绍多层架构, Model-View-"
"Presenter (MVP) 模式, 等等. <phrase condition=\"web\"><xref linkend="
"\"advanced.global\"/> 讨论如何传递全局数据的问题, 这个问题在 <xref linkend="
"\"application.architecture.accessing\"/> 中也有部分讨论.</phrase>"

#. Tag: title
#: chapter-application.xml:316
#, no-c-format
msgid "Compositing Components"
msgstr "组合组件"

#. Tag: para
#: chapter-application.xml:318
#, no-c-format
msgid ""
"User interfaces typically contain many user interface components in a layout "
"hierarchy. Vaadin provides many layout components for laying contained "
"components vertically, horizontally, in a grid, and in many other ways. You "
"can extend layout components to create composite components."
msgstr ""
"UI 通常包含多个 UI 组件, 这些组件以某种布局层级结构组织起来. Vaadin 提供了很"
"多布局组件来管理组件, 包括垂直布局, 水平布局, 网格布局, 以及其他各种方式的布"
"局. 你可以扩展布局组件来创建组合组件."

#. Tag: programlisting
#: chapter-application.xml:326
#, no-c-format
msgid ""
"<![CDATA[class MyView extends VerticalLayout {\n"
"    TextField entry   = new TextField(\"Enter this\");\n"
"    Label     display = new Label(\"See this\");\n"
"    Button    click   = new Button(\"Click This\");\n"
"\n"
"    public MyView() {\n"
"        addComponent(entry);\n"
"        addComponent(display);\n"
"        addComponent(click);\n"
"        \n"
"        // Configure it a bit\n"
"        setSizeFull();\n"
"        addStyleName(\"myview\");\n"
"    }\n"
"}\n"
"\n"
"// Use it\n"
"Layout myview = new MyView();]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:328
#, no-c-format
msgid ""
"This composition pattern is especially supported for creating forms, as "
"described in <xref linkend=\"datamodel.itembinding.formclass\"/>."
msgstr ""
"这种组合模式尤其适合于创建 Form, 详情参见 <xref linkend=\"datamodel."
"itembinding.formclass\"/>."

#. Tag: para
#: chapter-application.xml:333
#, no-c-format
msgid ""
"While extending layouts is an easy way to make component composition, it is "
"a good practice to encapsulate implementation details, such as the exact "
"layout component used. Otherwise, the users of such a composite could begin "
"to rely on such implementation details, which would make changes harder. For "
"this purpose, Vaadin has a special <classname>CustomComponent</classname> "
"wrapper, which hides the content representation."
msgstr ""
"为实现组件的组合, 象上面的例子那样, 直接从布局组件继承是一种很简单的方式. 但"
"是, 在实践中我们可能期望将具体的实现细节隐藏起来, 比如, 具体使用了什么样的布"
"局组件可能是我们不希望使用者知道的细节. 上例中使用的组合方式实际上已经依赖到"
"具体的实现细节, 这就使得将来的代码变更变得比较困难. 为了隐藏组合组件的内部实"
"现细节, Vaadin 提供了一个专门的 <classname>CustomComponent</classname> 封装"
"类, 它隐藏了其内容的具体表达方式."

#. Tag: programlisting
#: chapter-application.xml:343
#, no-c-format
msgid ""
"<![CDATA[class MyView extends CustomComponent {\n"
"    TextField entry   = new TextField(\"Enter this\");\n"
"    Label     display = new Label(\"See this\");\n"
"    Button    click   = new Button(\"Click This\");\n"
"\n"
"    public MyView() {\n"
"        Layout layout = new VerticalLayout();\n"
"        \n"
"        layout.addComponent(entry);\n"
"        layout.addComponent(display);\n"
"        layout.addComponent(click);\n"
"        \n"
"        setCompositionRoot(layout);\n"
"        \n"
"        setSizeFull();\n"
"    }\n"
"}\n"
"\n"
"// Use it\n"
"MyView myview = new MyView();]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:345
#, no-c-format
msgid ""
"For a more detailed description of the <classname>CustomComponent</"
"classname>, see <xref linkend=\"components.customcomponent\"/>. The Vaadin "
"Plugin for Eclipse also includes a visual editor for composite components, "
"as described in <xref linkend=\"eclipse\"/>."
msgstr ""
"<classname>CustomComponent</classname> 的更详细介绍, 请参见 <xref linkend="
"\"components.customcomponent\"/>. Vaadin Plugin for Eclipse 中包含了一个可视"
"化编辑器, 可用来设计组合组件, 详情参见 <xref linkend=\"eclipse\"/>."

#. Tag: title
#: chapter-application.xml:355
#, no-c-format
msgid "View Navigation"
msgstr "视图导航"

#. Tag: para
#: chapter-application.xml:357
#, no-c-format
msgid ""
"While the most simple applications have just a single <emphasis>view</"
"emphasis> (or <emphasis>screen</emphasis>), perhaps most have many. Even in "
"a single view, you often want to have sub-views, for example to display "
"different content. <xref linkend=\"figure.application.architecture.navigation"
"\"/> illustrates a typical navigation between different top-level views of "
"an application, and a main view with sub-views."
msgstr ""
"简单应用程序大多只有单个 <emphasis>视图</emphasis> (或者叫 <emphasis>画面</"
"emphasis>), 但一般的应用程序通常会有很多个视图. 即使在单个视图呢, 你也可能希"
"望拥有多个子视图, 比如, 为不同的场景显示不同的内容. <xref linkend=\"figure."
"application.architecture.navigation\"/> 展示了在应用程序的多个顶级视图之间跳"
"转, 以及在主视图内包含多个子视图的情况."

#. Tag: title
#: chapter-application.xml:368
#, no-c-format
msgid "Navigation Between Views"
msgstr "在多个视图之间跳转"

#. Tag: para
#: chapter-application.xml:379
#, no-c-format
msgid ""
"The <classname>Navigator</classname> described in <xref linkend=\"advanced."
"navigator\"/> is a view manager that provides a flexible way to navigate "
"between views and sub-views, while managing the URI fragment in the page URL "
"to allow bookmarking, linking, and going back in browser history."
msgstr ""
"<xref linkend=\"advanced.navigator\"/> 中介绍的 <classname>Navigator</"
"classname> 类,  是视图的管理器, 提供了灵活的手段实现在多个视图和子视图之间跳"
"转, 还可以管理页面 URL 内的 URI 片段, 利用这些 URI 片段, 可以将视图添加为浏览"
"器书签, 链接, 或在浏览器访问历史中回退."

#. Tag: para
#: chapter-application.xml:387
#, no-c-format
msgid ""
"Often Vaadin application views are part of something bigger. In such cases, "
"you may need to integrate the Vaadin applications with the other website. "
"You can use the embedding techniques described in <xref linkend=\"advanced."
"embedding\"/>."
msgstr ""
"Vaadin 应用程序的视图通常不是独立存在的, 而是某个更大更复杂页面的一部分. 这种"
"情况下, 你可能需要将 Vaadin 应用程序集成到别的网站中. 你可以使用嵌入技术, 详"
"情参见 <xref linkend=\"advanced.embedding\"/>."

#. Tag: title
#: chapter-application.xml:396
#, no-c-format
msgid "Accessing &uiclass;, Page, Session, and Service"
msgstr "访问 &uiclass;, Page, Session, 以及 Service"

#. Tag: para
#: chapter-application.xml:398
#, no-c-format
msgid ""
"You can get the UI and the page to which a component is attached to with "
"<methodname>getUI()</methodname> and <methodname>getPage()</methodname>."
msgstr ""
"你可以通过 <methodname>getUI()</methodname> 和 <methodname>getPage()</"
"methodname> 方法, 得到某个组件所关联的 UI 和 page."

#. Tag: para
#: chapter-application.xml:403
#, no-c-format
msgid ""
"However, the values are <literal>null</literal> until the component is "
"attached to the UI, and typically, when you need it in constructors, it is "
"not. It is therefore preferable to access the current &ui;, page, session, "
"and service objects from anywhere in the application using the static "
"<methodname>getCurrent()</methodname> methods in the respective "
"<classname>&uiclass;</classname>, <classname>Page</classname>, "
"<classname>VaadinSession</classname>, and <classname>VaadinService</"
"classname> classes."
msgstr ""
"但是, 在组件关联到 UI 之前, 上述方法的返回值将是 <literal>null</literal>, 通"
"常当你在类的构造方法中需要访问以上方式时, 组件是未关联到 UI 的. 因此, 更好的"
"方法是在应用程序的任何地方, 在 <classname>&uiclass;</classname>, "
"<classname>Page</classname>, <classname>VaadinSession</classname>, 以及 "
"<classname>VaadinService</classname> 类上使用静态方法 "
"<methodname>getCurrent()</methodname>,  得到当前的 &ui;, page, session, 以及 "
"service 对象."

#. Tag: programlisting
#: chapter-application.xml:414
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Set the default locale of the UI\n"
"UI.getCurrent().setLocale(new Locale(\"en\"));\n"
"\n"
"// Set the page title (window or tab caption)\n"
"Page.getCurrent().setTitle(\"My Page\");\n"
"        \n"
"// Set a session attribute\n"
"VaadinSession.getCurrent().setAttribute(\"myattrib\", \"hello\");\n"
"\n"
"// Access the HTTP service parameters\n"
"File baseDir = VaadinService.getCurrent().getBaseDirectory();]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:416
#, no-c-format
msgid ""
"You can get the page and the session also from a <classname>UI</classname> "
"with <methodname>getPage()</methodname> and <methodname>getSession()</"
"methodname> and the service from <classname>VaadinSession</classname> with "
"<methodname>getService()</methodname>."
msgstr ""
"page 和 session 对象也可以通过 <classname>UI</classname> 的 "
"<methodname>getPage()</methodname> 和 <methodname>getSession()</methodname> "
"方法得到, service 对象可通过 <classname>VaadinSession</classname> 的 "
"<methodname>getService()</methodname> 方法得到."

#. Tag: para
#: chapter-application.xml:424
#, no-c-format
msgid ""
"The static methods use the built-in ThreadLocal support in the classes."
"<phrase condition=\"web\"> The pattern is described in <xref linkend="
"\"advanced.global.threadlocal\"/>.</phrase>"
msgstr ""
"上述静态方法使用这些类内建的 ThreadLocal 支持.<phrase condition=\"web\"> "
"ThreadLocal 模式的详细介绍请参见 <xref linkend=\"advanced.global.threadlocal"
"\"/>.</phrase>"

#. Tag: title
#: chapter-application.xml:433
#, no-c-format
msgid "Handling Events with Listeners"
msgstr "使用监听器来处理事件"

#. Tag: para
#: chapter-application.xml:435
#, no-c-format
msgid ""
"Let us put into practice what we learned of event handling in <xref linkend="
"\"architecture.events\"/>. You can implement listener interfaces in a "
"regular class, but it brings the problem with differentiating between "
"different event sources. Using anonymous class for listeners is recommended "
"in most cases."
msgstr ""
"我们在 <xref linkend=\"architecture.events\"/> 中已经学习了事件处理的基本原"
"理, 下面来进行一点实战. 监听器可以在常规类中实现, 但这种方式带来一个问题, 就"
"是在监听器中难以区分事件来源于哪个组件. 大多数情况下我们推荐使用匿名类来实现"
"监听器."

#. Tag: title
#: chapter-application.xml:444
#, no-c-format
msgid "Using Anonymous Classes"
msgstr "使用匿名类"

#. Tag: para
#: chapter-application.xml:446
#, no-c-format
msgid ""
"By far the easiest and the most common way to handle events in Java 6 and 7 "
"is to use anonymous local classes. It encapsulates the handling of events to "
"where the component is defined and does not require cumbering the managing "
"class with interface implementations. The following example defines an "
"anonymous class that inherits the <classname>Button.ClickListener</"
"classname> interface."
msgstr ""
"在 Java 6 和 7 中, 最简单最常用的事件处理方法是使用匿名的局部类. 这种方法将事"
"件的处理封装在组件定义的相同位置, 而且可以省去管理类, 实现接口之类的麻烦. 下"
"面的例子定义了一个匿名类, 它继承自 <classname>Button.ClickListener</"
"classname> 接口."

#. Tag: programlisting
#: chapter-application.xml:456
#, no-c-format
msgid ""
"<![CDATA[// Have a component that fires click events\n"
"final Button button = new Button(\"Click Me!\");\n"
"        \n"
"// Handle the events with an anonymous class\n"
"button.addClickListener(new Button.ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        button.setCaption(\"You made me click!\");\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:458
#, no-c-format
msgid ""
"Local objects referenced from within an anonymous class, such as the "
"<classname>Button</classname> object in the above example, must be declared "
"<literal>final</literal>."
msgstr ""
"被匿名类访问的局部对象, 比如上例中的 <classname>Button</classname>, 必须声明"
"为 <literal>final</literal>."

#. Tag: para
#: chapter-application.xml:464
#, no-c-format
msgid ""
"Most components allow passing a listener to the constructor, thereby losing "
"a line or two. However, notice that if accessing the component that is "
"constructed from an anonymous class, you must use a reference that is "
"declared before the constructor is executed, for example as a member "
"variable in the outer class. If it is declared in the same expression where "
"the constructor is called, it doesn't yet exist. In such cases, you need to "
"get a reference to the component from the event object."
msgstr ""
"大多数组件都可以在构造函数中以参数的形式传入事件监听器, 因此可以减少1、2行代"
"码. 但要注意, 如果在匿名类内部访问当前正在创建中的组件, 你必须在构造函数执行"
"之前就声明好这个组件的引用, 比如, 可以使用外部类中的成员变量. 如果组件的声明"
"语句与构造函数的执行语句是在同一个表达式之内, 那么构造函数执行时, 组件的声明"
"其实还并不存在. 这时, 在匿名类内, 你就需要通过 event 参数得到组件的引用."

#. Tag: programlisting
#: chapter-application.xml:476
#, no-c-format
msgid ""
"<![CDATA[final Button button = new Button(\"Click It!\",\n"
"  new Button.ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        event.getButton().setCaption(\"Done!\");\n"
"    }\n"
"  });]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:481
#, no-c-format
msgid "Handling Events in Java 8"
msgstr "Java 8 中的事件处理"

#. Tag: para
#: chapter-application.xml:483
#, no-c-format
msgid ""
"Java 8 introduced lambda expressions, which offer a replacement for "
"listeners. You can directly use lambda expressions in place of listeners "
"that have only one method to implement."
msgstr ""
"Java 8 引入了一个新特性: lambda 表达式, 它可以用来替代事件监听器. 如果监听器"
"内只有一个方法需要时间, 那么你可以直接使用 lambda 表达式来替代监听器."

#. Tag: para
#: chapter-application.xml:489
#, no-c-format
msgid ""
"For example, in the following, we use a lambda expression to handle button "
"click events in the constructor:"
msgstr "比如下例中, 我们在构造函数中使用  lambda 表达式, 来处理按钮的点击事件:"

#. Tag: programlisting
#: chapter-application.xml:495
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[layout.addComponent(new Button(\"Click Me!\",\n"
"    event -> event.getButton().setCaption(\"You made click!\")));]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:497
#, no-c-format
msgid ""
"Java 8 is the future that is already here, and as Vaadin API uses event "
"listeners extensively, using lambda expressions makes UI code much more "
"readable."
msgstr ""
"Java 8 代表了 Java 的最新发展方向, 而且, 由于 Vaadin API 中广泛使用了事件监听"
"器, 因此, 使用 lambda 表达式将使得 UI 代码更加易读."

#. Tag: para
#: chapter-application.xml:503
#, no-c-format
msgid "Directing events to handler methods is easy with method references:"
msgstr "使用方法引用(method reference), 可以很便利地将事件转发给监听器方法:"

#. Tag: programlisting
#: chapter-application.xml:508
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class Java8Buttons extends "
"CustomComponent {\n"
"    public Java8Buttons() {\n"
"        setCompositionRoot(new HorizontalLayout( \n"
"            new Button(\"OK\", this::ok),\n"
"            new Button(\"Cancel\", this::cancel)));\n"
"    }\n"
"    \n"
"    public void ok(ClickEvent event) {\n"
"        event.getButton().setCaption (\"OK!\");\n"
"    }\n"
"\n"
"    public void cancel(ClickEvent event) {\n"
"        event.getButton().setCaption (\"Not OK!\");\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:513
#, no-c-format
msgid "Implementing a Listener in a Regular Class"
msgstr "使用常规类来实现监听器"

#. Tag: para
#: chapter-application.xml:515
#, no-c-format
msgid ""
"The following example follows a typical pattern where you have a "
"<classname>Button</classname> component and a listener that handles user "
"interaction (clicks) communicated to the application as events. Here we "
"define a class that listens to click events."
msgstr ""
"下面的例子遵循经典开发模式, 你有一个 <classname>Button</classname> 组件, 还有"
"一个监听器负责处理用户操作(也就是点击), 用户操作以事件的形式发送给应用程序. "
"这里我们定义一个类来监听点击事件."

#. Tag: programlisting
#: chapter-application.xml:523
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyComposite extends "
"CustomComponent\n"
"             implements Button.ClickListener {\n"
"    Button button; // Defined here for access\n"
"\n"
"    public MyComposite() {\n"
"        Layout layout = new HorizontalLayout();\n"
"        \n"
"        // Just a single component in this composition\n"
"        button = new Button(\"Do not push this\");\n"
"        button.addClickListener(this);\n"
"        layout.addComponent(button);\n"
"        \n"
"        setCompositionRoot(layout);\n"
"    }\n"
"    \n"
"    // The listener method implementation\n"
"    public void buttonClick(ClickEvent event) {\n"
"        button.setCaption(\"Do not push this again\");\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:527
#, no-c-format
msgid "Differentiating Between Event Sources"
msgstr "区分事件的发生源"

#. Tag: para
#: chapter-application.xml:529
#, no-c-format
msgid ""
"If an application receives events of the same type from multiple sources, "
"such as multiple buttons, it has to be able to distinguish between the "
"sources. If using a regular class listener, distinguishing between the "
"components can be done by comparing the source of the event with each of the "
"components. The method for identifying the source depends on the event type."
msgstr ""
"如果应用程序从多个事件源接收到相同类型的多个事件, 比如有存在按钮的情况, 应用"
"程序必须能够区分各个事件来源于哪个组件. 如果使用常规类来实现监听器, 可以将事"
"件来源与所有组件逐个比较, 以此来区分事件来源组件. 判断事件源的方法根据事件类"
"型而不同."

#. Tag: programlisting
#: chapter-application.xml:539
#, no-c-format
msgid ""
"<![CDATA[public class TheButtons extends CustomComponent\n"
"       implements Button.ClickListener {\n"
"    Button onebutton;\n"
"    Button toobutton;\n"
"\n"
"    public TheButtons() {\n"
"        onebutton = new Button(\"Button One\", this);\n"
"        toobutton = new Button(\"A Button Too\", this);\n"
"\n"
"        // Put them in some layout\n"
"        Layout root = new HorizontalLayout(); \n"
"        root.addComponent(onebutton);\n"
"        root.addComponent(toobutton);\n"
"        setCompositionRoot(root);\n"
"    }\n"
"    \n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        // Differentiate targets by event source\n"
"        if (event.getButton() == onebutton)\n"
"            onebutton.setCaption (\"Pushed one\");\n"
"        else if (event.getButton() == toobutton)\n"
"            toobutton.setCaption (\"Pushed too\");\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:541
#, no-c-format
msgid ""
"Other techniques exist for separating between event sources, such as using "
"object properties, names, or captions to separate between them. Using "
"captions or any other visible text is generally discouraged, as it may "
"create problems for internationalization. Using other symbolic strings can "
"also be dangerous, because the syntax of such strings is checked only at "
"runtime."
msgstr ""
"区分不同的事件源还有其他方法, 比如使用对象的属性, 名称, 或标签文字来区分组"
"件. 使用标签文字或者其他可见文字的方式通常来说是不好的, 因为这种方法在应用程"
"序国际化时会发生问题. 使用其他符号化字符串也是危险的, 因为这些字符串内容只有"
"在实际运行时才会被检查."

#. Tag: title
#: chapter-application.xml:554
#, no-c-format
msgid "Images and Other Resources"
msgstr "图片及其他资源"

#. Tag: para
#: chapter-application.xml:556
#, no-c-format
msgid ""
"Web applications can display various <emphasis>resources</emphasis>, such as "
"images, other embedded content, or downloadable files, that the browser has "
"to load from the server. Image resources are typically displayed with the "
"<classname>Image</classname> component or as component icons. Flash "
"animations can be displayed with <classname>Flash</classname>, embedded "
"browser frames with <classname>BrowserFrame</classname>, and other content "
"with the <classname>Embedded</classname> component, as described in <xref "
"linkend=\"components.embedded\"/>. Downloadable files are usually provided "
"by clicking a <classname>Link</classname>."
msgstr ""
"Web 应用程序可以显示各种 <emphasis>资源</emphasis>, 比如图片, 其他嵌入式内"
"容, 或可下载的文档, 这些资源都由浏览器从服务器端取得. 图片资源一般使用 "
"<classname>Image</classname> 组件来显示, 或者显示为某个组件的图标. Flash 动画"
"可以使用 <classname>Flash</classname> 组件显示, 内嵌的浏览器 frame 可以用 "
"<classname>BrowserFrame</classname> 组件显示, 其他内容可以用 "
"<classname>Embedded</classname> 组件显示, 详情参见 <xref linkend="
"\"components.embedded\"/>. 可下载的文件通常以 <classname>Link</classname> 的"
"方式提供, 点击链接即可下载文件."

#. Tag: para
#: chapter-application.xml:568
#, no-c-format
msgid ""
"There are several ways to how such resources can be provided by the web "
"server. Static resources can be provided without having to ask for them from "
"the application. For dynamic resources, the user application must be able to "
"create them dynamically. The resource request interfaces in Vaadin allow "
"applications to both refer to static resources as well as dynamically create "
"them. The dynamic creation includes the <classname>StreamResource</"
"classname> class and the <interfacename>RequestHandler</interfacename> "
"described in <xref linkend=\"advanced.requesthandler\"/>."
msgstr ""
"Web 服务器向外提供资源的方式有很多种. 静态资源可以直接向外提供, 不必通过应用"
"程序. 对于动态资源的情况, 应用程序必须动态地创建其内容. Vaadin 的资源请求接口"
"既允许应用程序访问静态资源, 也允许应用程序动态创建资源. 动态创建资源需要用到 "
"<classname>StreamResource</classname> 和 <interfacename>RequestHandler</"
"interfacename> 类, 详情请参见 <xref linkend=\"advanced.requesthandler\"/>."

#. Tag: para
#: chapter-application.xml:579
#, no-c-format
msgid ""
"Vaadin also provides low-level facilities for retrieving the URI and other "
"parameters of a HTTP request. We will first look into how applications can "
"provide various kinds of resources and then look into low-level interfaces "
"for handling URIs and parameters to provide resources and functionalities."
msgstr ""
"Vaadin 还提供了低级工具来取得 HTTP 请求的 URI 和其他参数. 我们首先看看应用程"
"序如何提供各种类型的资源, 然后再介绍用于对外提供资源和其他功能, 与 URI 和 "
"HTTP 参数处理相关的低级接口."

#. Tag: para
#: chapter-application.xml:587
#, no-c-format
msgid ""
"Notice that using request handlers to create \"pages\" is not normally "
"meaningful in Vaadin or in AJAX applications generally. Please see <xref "
"linkend=\"architecture.technology.ajax\"/> for a detailed explanation."
msgstr ""
"注意, 对于 Vaadin 或一般的 AJAX 应用程序来说, 使用请求处理器来创建 \"页面\" "
"通常是没什么意义的. 关于这个问题的详细解释, 请参见 <xref linkend="
"\"architecture.technology.ajax\"/>."

#. Tag: title
#: chapter-application.xml:594
#, no-c-format
msgid "Resource Interfaces and Classes"
msgstr "资源接口和类"

#. Tag: para
#: chapter-application.xml:596
#, no-c-format
msgid ""
"The resource classes in Vaadin are grouped under two interfaces: a generic "
"<classname>Resource</classname> interface and a more specific "
"<classname>ConnectorResource</classname> interface for resources provided by "
"the servlet."
msgstr ""
"Vaadin 中的资源类属于两类接口: 一个是较为通用的 <classname>Resource</"
"classname> 接口, 另一个是较为特殊化的 <classname>ConnectorResource</"
"classname> 接口, ConnectorResource 用于通过 Servlet 向外提供的资源."

#. Tag: title
#: chapter-application.xml:604
#, no-c-format
msgid "Resource Interface and Class Diagram"
msgstr "资源接口和类的关系图"

#. Tag: title
#: chapter-application.xml:617
#, no-c-format
msgid "File Resources"
msgstr "文件资源"

#. Tag: para
#: chapter-application.xml:619
#, no-c-format
msgid ""
"File resources are files stored anywhere in the file system. As such, they "
"can not be retrieved by a regular URL from the server, but need to be "
"requested through the Vaadin servlet. The use of file resources is typically "
"necessary for persistent user data that is not packaged in the web "
"application, which would not be persistent over redeployments."
msgstr ""
"文件资源是指存储在文件系统中任意位置的文件. 因此, 文件资源不能直接通过服务器"
"上某个特定的 URL 来访问, 而必须经过 Vaadin Servlet 来请求. 对于没有打包进 Web"
"应用程序的用户持久化数据, 通常就需要使用文件资源来存取."

#. Tag: para
#: chapter-application.xml:627
#, no-c-format
msgid ""
"A file object that can be accessed as a file resource is defined with the "
"standard <classname>java.io.File</classname> class. You can create the file "
"either with an absolute or relative path, but the base path of the relative "
"path depends on the installation of the web server. For example, with Apache "
"Tomcat, the default current directory would be the installation path of "
"Tomcat."
msgstr ""
"文件对象使用标准的 <classname>java.io.File</classname> 类来定义, 它可以作为文"
"件资源来访问. 创建文件时, 你可以使用绝对路径, 也可以使用相对路径, 但相对路径"
"所使用的起始路径将根据 Web 服务器的安装状况而不同. 比如, 对于 Apache Tomcat, "
"默认的当前目录将是 Tomcat 的安装路径."

#. Tag: para
#: chapter-application.xml:636
#, no-c-format
msgid ""
"In the following example, we provide an image resource from a file stored in "
"the web application. Notice that the image is stored under the <filename>WEB-"
"INF</filename> folder, which is a special folder that is never accessible "
"using an URL, unlike the other folders of a web application. This is a "
"security solution - another would be to store the resource elsewhere in the "
"file system."
msgstr ""
"下面的例子中, 我们通过存储在 Web 应用程序中的文件来向外提供一个图片资源. 注"
"意, 图片存储在 <filename>WEB-INF</filename> 文件夹之下, 这个目录是一个特殊目"
"录, 它与 Web 应用程序中的其他目录不同, 不可以使用 URL 来访问其中的内容. 这是"
"保证系统安全性的一种方案, 另一种方案是将资源存储在文件系统的其他位置, 而不是"
"Web 应用程序之内."

#. Tag: programlisting
#: chapter-application.xml:646
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Find the application directory\n"
"String basepath = VaadinService.getCurrent()\n"
"                  .getBaseDirectory().getAbsolutePath();\n"
"\n"
"// Image as a file resource\n"
"FileResource resource = new FileResource(new File(basepath +\n"
"                        \"/WEB-INF/images/image.png\"));\n"
"\n"
"// Show the image in the application\n"
"Image image = new Image(\"Image from file\", resource);\n"
"        \n"
"// Let the user view the file in browser or download it\n"
"Link link = new Link(\"Link to the image file\", resource);]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:648
#, no-c-format
msgid ""
"The result, as well as the folder structure where the file is stored under a "
"regular Eclipse Vaadin project, is shown in <xref linkend=\"figure."
"application.resources.file\"/>."
msgstr ""
"上面例子的运行结果, 以及在通常的 Eclipse Vaadin 工程中存储的文件结构, 参见 "
"<xref linkend=\"figure.application.resources.file\"/>."

#. Tag: title
#: chapter-application.xml:655
#, no-c-format
msgid "File Resource"
msgstr "文件资源"

#. Tag: title
#: chapter-application.xml:665
#, no-c-format
msgid "Class Loader Resources"
msgstr "Class Loader 资源"

#. Tag: para
#: chapter-application.xml:667
#, no-c-format
msgid ""
"The <classname>ClassResource</classname> allows resources to be loaded from "
"the class path using Java Class Loader. Normally, the relevant class path "
"entry is the <filename>WEB-INF/classes</filename> folder under the web "
"application, where the Java compilation should compile the Java classes and "
"copy other files from the source tree."
msgstr ""
"<classname>ClassResource</classname> 可以使用 Java Class Loader 从类路径中装"
"载资源. 通常, 使用的类路径是 Web 应用程序中的 <filename>WEB-INF/classes</"
"filename> 文件夹, 这里就是 Java 编译器生成 Java 类文件, 并从源代码树中复制其"
"他资源文件时的输出位置."

#. Tag: para
#: chapter-application.xml:675
#, no-c-format
msgid ""
"The one-line example below loads an image resource from the application "
"package and displays it in an <classname>Image</classname> component."
msgstr ""
"下面的示例从应用程序包中装载一个图片资源, 并显示在一个 <classname>Image</"
"classname> 组件中."

#. Tag: programlisting
#: chapter-application.xml:681
#, no-c-format
msgid ""
"<?pocket-size 80% ?><![CDATA[layout.addComponent(new Image(null,\n"
"        new ClassResource(\"smiley.jpg\")));]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:685 chapter-application.xml:705
#, no-c-format
msgid "Theme Resources"
msgstr "Theme 资源"

#. Tag: para
#: chapter-application.xml:687
#, no-c-format
msgid ""
"Theme resources of <classname>ThemeResource</classname> class are files, "
"typically images, included in a theme. A theme is located with the path "
"<filename>VAADIN/themes/themename</filename> in a web application. The name "
"of a theme resource is given as the parameter for the constructor, with a "
"path relative to the theme folder."
msgstr ""
"<classname>ThemeResource</classname> 类是Theme 资源, 它是 Theme 内的文件, 通"
"常是图片. Theme 位于 Web 应用程序的 <filename>VAADIN/themes/themename</"
"filename> 目录下. Theme 资源的名字作为参数传递给构造函数, 其内容是资源文件相"
"对于 theme 文件夹的相对路径."

#. Tag: programlisting
#: chapter-application.xml:696
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A theme resource in the current theme "
"(\"mytheme\")\n"
"// Located in: VAADIN/themes/mytheme/img/themeimage.png\n"
"ThemeResource resource = new ThemeResource(\"img/themeimage.png\");\n"
"\n"
"// Use the resource\n"
"Image image = new Image(\"My Theme Image\", resource);]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:698
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.application.resources.theme\"/"
">, also illustrating the folder structure for the theme resource file in an "
"Eclipse project."
msgstr ""
"上面示例的运行结果, 参见 <xref linkend=\"figure.application.resources.theme"
"\"/>, 此图还展示了 Eclipse 工程中 Theme 资源文件的目录结构."

#. Tag: para
#: chapter-application.xml:713
#, no-c-format
msgid ""
"To use theme resources, you must set the theme for the UI. See <xref linkend="
"\"themes\"/> for more information regarding themes."
msgstr ""
"为了使用 Theme 资源, 你需要为 UI 设置 theme. 关于 Theme 的更多介绍, 详情请参"
"见 <xref linkend=\"themes\"/>."

#. Tag: title
#: chapter-application.xml:720
#, no-c-format
msgid "Stream Resources"
msgstr "流资源"

#. Tag: para
#: chapter-application.xml:722
#, no-c-format
msgid ""
"Stream resources allow creating dynamic resource content. Charts are typical "
"examples of dynamic images. To define a stream resource, you need to "
"implement the <classname>StreamResource.StreamSource</classname> interface "
"and its <methodname>getStream()</methodname> method. The method needs to "
"return an <classname>InputStream</classname> from which the stream can be "
"read."
msgstr ""
"流资源可用来创建动态的资源内容. 图表是动态图片的典型例子. 要生成一个流资源, "
"你需要实现 <classname>StreamResource.StreamSource</classname> 接口, 及其中的 "
"<methodname>getStream()</methodname> 方法. 这个方法需要返回一个 "
"<classname>InputStream</classname> 对象, 从这个 InputStream 中应该能够读取到"
"资源的内容."

#. Tag: para
#: chapter-application.xml:731
#, no-c-format
msgid ""
"The following example demonstrates the creation of a simple image in PNG "
"image format."
msgstr "下面的例子演示如何创建一个简单的 PNG 格式图片."

#. Tag: programlisting
#: chapter-application.xml:736
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[import java.awt.image.*;\n"
"\n"
"public class MyImageSource\n"
"             implements StreamResource.StreamSource {\n"
"    ByteArrayOutputStream imagebuffer = null;\n"
"    int reloads = 0;\n"
"    \n"
"    /* We need to implement this method that returns\n"
"     * the resource as a stream. */\n"
"    public InputStream getStream () {\n"
"        /* Create an image and draw something on it. */\n"
"        BufferedImage image = new BufferedImage (200, 200,\n"
"                               BufferedImage.TYPE_INT_RGB);\n"
"        Graphics drawable = image.getGraphics();\n"
"        drawable.setColor(Color.lightGray);\n"
"        drawable.fillRect(0,0,200,200);\n"
"        drawable.setColor(Color.yellow);\n"
"        drawable.fillOval(25,25,150,150);\n"
"        drawable.setColor(Color.blue);\n"
"        drawable.drawRect(0,0,199,199);\n"
"        drawable.setColor(Color.black);\n"
"        drawable.drawString(\"Reloads=\"+reloads, 75, 100);\n"
"        reloads++;\n"
"\n"
"        try {\n"
"            /* Write the image to a buffer. */\n"
"            imagebuffer = new ByteArrayOutputStream();\n"
"            ImageIO.write(image, \"png\", imagebuffer);\n"
"            \n"
"            /* Return a stream from the buffer. */\n"
"            return new ByteArrayInputStream(\n"
"                         imagebuffer.toByteArray());\n"
"        } catch (IOException e) {\n"
"            return null;\n"
"        }\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:738
#, no-c-format
msgid ""
"The content of the generated image is dynamic, as it updates the reloads "
"counter with every call. The <classname>ImageIO</classname>."
"<methodname>write()</methodname> method writes the image to an output "
"stream, while we had to return an input stream, so we stored the image "
"contents to a temporary buffer."
msgstr ""
"上面例子生成的图片内容是动态的, 因为每次访问它, 它都会更新自己的访问次数. "
"<classname>ImageIO</classname>.<methodname>write()</methodname> 方法将图片内"
"容写入到 output 流中, 但我们需要返回 input 流, 所以我们将图片内容保存到一个临"
"时缓冲区中."

#. Tag: para
#: chapter-application.xml:747
#, no-c-format
msgid ""
"Below we display the image with the <classname>Image</classname> component."
msgstr "下面我们使用 <classname>Image</classname> 组件来显示图片."

#. Tag: programlisting
#: chapter-application.xml:752
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create an instance of our stream source.\n"
"StreamResource.StreamSource imagesource = new MyImageSource ();\n"
"        \n"
"// Create a resource that uses the stream source and give it a name.\n"
"// The constructor will automatically register the resource in\n"
"// the application.\n"
"StreamResource resource =\n"
"        new StreamResource(imagesource, \"myimage.png\");\n"
"        \n"
"// Create an image component that gets its contents\n"
"// from the resource.\n"
"layout.addComponent(new Image(\"Image title\", resource));]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:754
#, no-c-format
msgid ""
"The resulting image is shown in <xref linkend=\"figure.application.resource."
"stream\"/>."
msgstr ""
"上面示例的运行结果见 <xref linkend=\"figure.application.resource.stream\"/>."

#. Tag: title
#: chapter-application.xml:760
#, no-c-format
msgid "A Stream Resource"
msgstr "流资源"

#. Tag: para
#: chapter-application.xml:771
#, no-c-format
msgid ""
"Another way to create dynamic content is a request handler, described in "
"<xref linkend=\"advanced.requesthandler\"/>."
msgstr ""
"创建动态内容的另一种方法是使用请求处理器, 详情请参见 <xref linkend="
"\"advanced.requesthandler\"/>."

#. Tag: title
#: chapter-application.xml:779
#, no-c-format
msgid "Handling Errors"
msgstr "错误处理"

#. Tag: title
#: chapter-application.xml:782
#, no-c-format
msgid "Error Indicator and Message"
msgstr "错误指示器和消息"

#. Tag: para
#: chapter-application.xml:784
#, no-c-format
msgid ""
"All components have a built-in error indicator that is turned on if "
"validating the component fails, and can be set explicitly with "
"<methodname>setComponentError()</methodname>. Usually, the error indicator "
"is placed right of the component caption. The error indicator is part of the "
"component caption, so its placement is usually managed by the layout in "
"which the component is contained, but some components handle it themselves. "
"Hovering the mouse pointer over the field displays the error message."
msgstr ""
"所有的组件都带有内建的错误指示器, 当某个组件的输入校验发生错误时, 错误指示器"
"将被激活, 错误指示器还可以使用 <methodname>setComponentError()</methodname> "
"方法显式地激活. 错误指示器通常位于组件标题的右侧. 错误指示器是组件标题的一部"
"分, 因此它的位置通常由组件所属的布局管理组件来控制, 但某些组件会自行控制错误"
"指示器. 将鼠标指针移动到组件上方, 会显示它的错误消息."

#. Tag: programlisting
#: chapter-application.xml:795
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[textfield.setComponentError(new UserError(\"Bad "
"value\"));\n"
"button.setComponentError(new UserError(\"Bad click\"));]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:797
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.application.errors.error-"
"indicator\"/>."
msgstr ""
"上述示例程序的运行结果见 <xref linkend=\"figure.application.errors.error-"
"indicator\"/>."

#. Tag: title
#: chapter-application.xml:803
#, no-c-format
msgid "Error Indicator Active"
msgstr "激活时的错误指示器"

#. Tag: title
#: chapter-application.xml:818
#, no-c-format
msgid "Customizing System Messages"
msgstr "自定义系统消息"

#. Tag: para
#: chapter-application.xml:820
#, no-c-format
msgid ""
"System messages are notifications that indicate a major invalid state that "
"usually requires restarting the application. Session timeout is perhaps the "
"most typical such state."
msgstr ""
"系统消息是一种通知, 它指出应用程序处于严重的不正常状态, 通常需要重启应用程"
"序. 最典型的例子就是 Session 超时."

#. Tag: para
#: chapter-application.xml:826
#, no-c-format
msgid ""
"System messages are strings managed in the <classname>SystemMessages</"
"classname> class."
msgstr "系统消息由<classname>SystemMessages</classname> 类管理的字符串, ."

#. Tag: term
#: chapter-application.xml:833
#, no-c-format
msgid "sessionExpired"
msgstr ""

#. Tag: primary
#: chapter-application.xml:837 chapter-application.xml:841
#: chapter-application.xml:1390 chapter-application.xml:1672
#: chapter-application.xml:1731
#, no-c-format
msgid "session"
msgstr ""

#. Tag: secondary
#: chapter-application.xml:838 chapter-application.xml:1598
#: chapter-application.xml:1673
#, no-c-format
msgid "expiration"
msgstr ""

#. Tag: secondary
#: chapter-application.xml:842
#, no-c-format
msgid "timeout"
msgstr ""

#. Tag: para
#: chapter-application.xml:843
#, no-c-format
msgid ""
"Application servlet session expired. A session expires if no server requests "
"are made during the session timeout period. The session timeout can be "
"configured with the <parameter>session-timeout</parameter> parameter in "
"<filename>web.xml</filename>, as described in <xref linkend=\"application."
"environment.web-xml\"/>."
msgstr ""
"应用程序 Servlet 的 Session 过期. 如果在指定的 Session 超期时限内没有发生对服"
"务器的请求, Session 就会过期. Session 超期时限可以通过 <filename>web.xml</"
"filename>文件中的 <parameter>session-timeout</parameter> 参数进行配置, 详情参"
"见 <xref linkend=\"application.environment.web-xml\"/>."

#. Tag: term
#: chapter-application.xml:855
#, no-c-format
msgid "communicationError"
msgstr ""

#. Tag: para
#: chapter-application.xml:857
#, no-c-format
msgid ""
"An unspecified communication problem between the Vaadin Client-Side Engine "
"and the application server. The server may be unavailable or there is some "
"other problem."
msgstr ""
"Vaadin 客户端引擎与应用程序服务器之间发生了不明的通信错误. 原因可能是服务器已"
"经无法使用, 或者发生了其他问题."

#. Tag: term
#: chapter-application.xml:865
#, no-c-format
msgid "authenticationError"
msgstr ""

#. Tag: para
#: chapter-application.xml:867
#, no-c-format
msgid ""
"This error occurs if 401 (Unauthorized) response to a request is received "
"from the server."
msgstr "当向服务器的某个请求得到 401 (Unauthorized) 应答时, 将发生这个错误."

#. Tag: term
#: chapter-application.xml:874
#, no-c-format
msgid "internalError"
msgstr ""

#. Tag: para
#: chapter-application.xml:876
#, no-c-format
msgid ""
"A serious internal problem, possibly indicating a bug in Vaadin Client-Side "
"Engine or in some custom client-side code."
msgstr ""
"严重的内部错误, 原因可能是 Vaadin 客户端引擎本身的 bug, 也可能是自定义的客户"
"端代码的 bug."

#. Tag: term
#: chapter-application.xml:883
#, no-c-format
msgid "outOfSync"
msgstr ""

#. Tag: para
#: chapter-application.xml:885
#, no-c-format
msgid "The client-side state is invalid with respect to server-side state."
msgstr "客户端状态与服务器端状态不一致."

#. Tag: term
#: chapter-application.xml:892
#, no-c-format
msgid "cookiesDisabled"
msgstr ""

#. Tag: para
#: chapter-application.xml:894
#, no-c-format
msgid ""
"Informs the user that cookies are disabled in the browser and the "
"application does not work without them."
msgstr ""
"这个错误告诉用户, 浏览器禁用了 cookie, 应用程序无法在没有 cookie 的状态下工"
"作."

#. Tag: para
#: chapter-application.xml:902
#, no-c-format
msgid ""
"Each message has four properties: a short caption, the actual message, a URL "
"to which to redirect after displaying the message, and property indicating "
"whether the notification is enabled."
msgstr ""
"每一条消息都有4个属性: 1, 短标题, 2, 完整的消息内容, 3, 显示完消息之后应该跳"
"转去的 URL 地址, 4, 是否允许通知."

#. Tag: para
#: chapter-application.xml:908
#, no-c-format
msgid ""
"Additional details may be written (in English) to the debug console window "
"described in <xref linkend=\"advanced.debug\"/>."
msgstr ""
"详细信息(英文)可能会输出到调试窗口, 调试窗口参见 <xref linkend=\"advanced."
"debug\"/>."

#. Tag: para
#: chapter-application.xml:913
#, no-c-format
msgid ""
"You can override the default system messages by setting the "
"<interfacename>SystemMessagesProvider</interfacename> in the "
"<classname>VaadinService</classname>. You need to implement the "
"<methodname>getSystemMessages()</methodname> method, which should return a "
"<classname>SystemMessages</classname> object. The easiest way to customize "
"the messages is to use a <classname>CustomizedSystemMessages</classname> "
"object."
msgstr ""
"你可以替换掉默认的系统消息, 方法是在 <classname>VaadinService</classname> 中"
"设置 <interfacename>SystemMessagesProvider</interfacename>. 你需要实现 "
"<methodname>getSystemMessages()</methodname> 方法, 这个方法需要返回 "
"<classname>SystemMessages</classname> 对象. 定制消息的最简单方法是使用 "
"<classname>CustomizedSystemMessages</classname> 对象."

#. Tag: para
#: chapter-application.xml:923
#, no-c-format
msgid ""
"You can set the system message provider in the "
"<methodname>servletInitialized()</methodname> method of a custom servlet "
"class, for example as follows:"
msgstr ""
"在自定义 Servlet 类的 <methodname>servletInitialized()</methodname> 方法中, "
"你可以设置 system message provider , 示例如下:"

#. Tag: programlisting
#: chapter-application.xml:929
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[getService().setSystemMessagesProvider(\n"
"    new SystemMessagesProvider() {\n"
"    @Override \n"
"    public SystemMessages getSystemMessages(\n"
"        SystemMessagesInfo systemMessagesInfo) {\n"
"        CustomizedSystemMessages messages =\n"
"                new CustomizedSystemMessages();\n"
"        messages.setCommunicationErrorCaption(\"Comm Err\");\n"
"        messages.setCommunicationErrorMessage(\"This is bad.\");\n"
"        messages.setCommunicationErrorNotificationEnabled(true);\n"
"        messages.setCommunicationErrorURL(\"http://vaadin.com/\");\n"
"        return messages;\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:931
#, no-c-format
msgid ""
"See <xref linkend=\"application.lifecycle.servlet-service\"/> for "
"information about customizing Vaadin servlets."
msgstr ""
"定制 Vaadin Servlet的方法, 请参见 <xref linkend=\"application.lifecycle."
"servlet-service\"/>"

#. Tag: title
#: chapter-application.xml:938
#, no-c-format
msgid "Handling Uncaught Exceptions"
msgstr "管理未被 catch 的例外"

#. Tag: para
#: chapter-application.xml:940
#, no-c-format
msgid ""
"Handling events can result in exceptions either in the application logic or "
"in the framework itself, but some of them may not be caught properly by the "
"application. Any such exceptions are eventually caught by the framework. It "
"delegates the exceptions to the <classname>DefaultErrorHandler</classname>, "
"which displays the error as a component error, that is, with a small red \"!"
"\" -sign (depending on the theme). If the user hovers the mouse pointer over "
"it, the entire backtrace of the exception is shown in a large tooltip box, "
"as illustrated in <xref linkend=\"figure.application.errors.unchecked-"
"exceptions\"/>."
msgstr ""
"事件处理可能导致在应用程序逻辑中, 甚至框架本身中, 发生例外, 但这些例外有可能"
"没有被应用程序正确地 catch 住. 任何一个未被应用程序 catch 的例外最终都会被框"
"架 catch 住. 框架将例外转发给 <classname>DefaultErrorHandler</classname> 类, "
"这个类将错误消息显示为组件错误, 也就是, 在组件上显示一个小小的红色 \"!\" 符"
"号 (具体表现取决于 theme). 如果用户将鼠标指针移动到这个符号之上, 例外的全部 "
"backtrace 信息将被显示在一个大的 tooltip 框中, 参见 <xref linkend=\"figure."
"application.errors.unchecked-exceptions\"/>."

#. Tag: title
#: chapter-application.xml:953
#, no-c-format
msgid "Uncaught Exception in Component Error Indicator"
msgstr "未 catch 的例外被显示在组件的错误指示器中"

#. Tag: para
#: chapter-application.xml:964
#, no-c-format
msgid ""
"You can customize the default error handling by implementing a custom "
"<interfacename>ErrorHandler</interfacename> and enabling it with "
"<methodname>setErrorHandler()</methodname> in any of the components in the "
"component hierarchy, including the <classname>UI</classname>, or in the "
"<classname>VaadinSession</classname> object. You can either implement the "
"<interfacename>ErrorHandler</interfacename> or extend the "
"<classname>DefaultErrorHandler</classname>. In the following example, we "
"modify the behavior of the default handler."
msgstr ""
"你可以改变默认的错误处理方式, 方法是实现自定义的 "
"<interfacename>ErrorHandler</interfacename>, 并在组件层级中的任何组件上个通"
"过 <methodname>setErrorHandler()</methodname> 方法来激活它, 也可以在 "
"<classname>UI</classname>, 或 <classname>VaadinSession</classname> 对象上使用"
"你的自定义错误处理器. 你可以实现 <interfacename>ErrorHandler</interfacename> "
"接口, 也可以从 <classname>DefaultErrorHandler</classname> 类继承. 下面的例子"
"中, 我们修改默认的错误处理器的行为."

#. Tag: programlisting
#: chapter-application.xml:975
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here's some code that produces an uncaught "
"exception \n"
"final VerticalLayout layout = new VerticalLayout();\n"
"final Button button = new Button(\"Click Me!\",\n"
"    new Button.ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        ((String)null).length(); // Null-pointer exception\n"
"    }\n"
"});\n"
"layout.addComponent(button);\n"
"\n"
"// Configure the error handler for the UI\n"
"UI.getCurrent().setErrorHandler(new DefaultErrorHandler() {\n"
"    @Override\n"
"    public void error(com.vaadin.server.ErrorEvent event) {\n"
"        // Find the final cause\n"
"        String cause = \"<b>The click failed because:</b><br/>\";\n"
"        for (Throwable t = event.getThrowable(); t != null;\n"
"             t = t.getCause())\n"
"            if (t.getCause() == null) // We're at final cause\n"
"                cause += t.getClass().getName() + \"<br/>\";\n"
"        \n"
"        // Display the error message in a custom fashion\n"
"        layout.addComponent(new Label(cause, ContentMode.HTML));\n"
"           \n"
"        // Do the default error handling (optional)\n"
"        doDefault(event);\n"
"    } \n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:977
#, no-c-format
msgid ""
"The above example also demonstrates how to dig up the final cause from the "
"cause stack."
msgstr "上面的例子还演示了如何从例外的 cause stack 中找出例外发生的最初原因."

#. Tag: para
#: chapter-application.xml:982
#, no-c-format
msgid ""
"When extending <classname>DefaultErrorHandler</classname>, you can call "
"<methodname>doDefault()</methodname> as was done above to run the default "
"error handling, such as set the component error for the component where the "
"exception was thrown. See the source code of the implementation for more "
"details. You can call <methodname>findAbstractComponent(event)</methodname> "
"to find the component that caused the error. If the error is not associated "
"with a component, it returns null."
msgstr ""
"当从 <classname>DefaultErrorHandler</classname> 类继承时, 你可以象上面的例子"
"一样, 调用 <methodname>doDefault()</methodname> 方法, 来执行默认的错误处理动"
"作, 比如为发生例外的组件设置错误信息. 具体细节请查看源代码. 你可以调用 "
"<methodname>findAbstractComponent(event)</methodname> 方法, 来找出导致错误的"
"组件. 如果错误没有关联到某个组件, 这个方法的返回值将为 null."

#. Tag: title
#: chapter-application.xml:996
#, no-c-format
msgid "Notifications"
msgstr "通知"

#. Tag: para
#: chapter-application.xml:998
#, no-c-format
msgid ""
"Notifications are error or information boxes that appear briefly, typically "
"at the center of the screen. A notification box has a caption and an "
"optional description and icon. The box stays on the screen either for a "
"preset time or until the user clicks it. The notification type defines the "
"default appearance and behaviour of a notification."
msgstr ""
"通知是在界面上短暂显示的错误信息或提示信息, 一般显示在屏幕的正中. 通知框有一"
"个标题, 还有可选的描述信息和图标. 通知框在屏幕上停留预先指定的时间后消失, 或"
"者用户点击它也可以让它消失. 通知的类型决定了一个通知的默认表现和行为."

#. Tag: para
#: chapter-application.xml:1006
#, no-c-format
msgid ""
"There are two ways to create a notification. The easiest is to use a static "
"shorthand <methodname>Notification.show()</methodname> method, which takes "
"the caption of the notification as a parameter, and an optional description "
"and notification type, and displays it in the current page."
msgstr ""
"有两种方法创建通知. 最简单的方法是使用静态方法 <methodname>Notification."
"show()</methodname>, 这个方法的参数是通知的标题, 以及可选的通知描述信息和通知"
"类型, 使用这个方法可以将通知显示在当前页面中."

#. Tag: programlisting
#: chapter-application.xml:1013
#, no-c-format
msgid ""
"<![CDATA[Notification.show(\"This is the caption\",\n"
"                  \"This is the description\",\n"
"                  Notification.Type.WARNING_MESSAGE);]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:1016
#, no-c-format
msgid "Notification"
msgstr "通知"

#. Tag: para
#: chapter-application.xml:1027
#, no-c-format
msgid ""
"For more control, you can create a <classname>Notification</classname> "
"object. Different constructors exist for taking just the caption, and "
"optionally the description, notification type, and whether HTML is allowed "
"or not. Notifications are shown in a <classname>Page</classname>, typically "
"the current page."
msgstr ""
"为了对通知进行更精确地控制, 你可以创建一个 <classname>Notification</"
"classname> 类. 这个类的构造方法存在多个不同版本, 各构造方法的参数可以有标题, "
"可选的描述信息, 通知类型, HTML 是否可用. 通知显示在 <classname>Page</"
"classname> 中, 通常就是当前页面."

#. Tag: programlisting
#: chapter-application.xml:1035
#, no-c-format
msgid ""
"<![CDATA[new Notification(\"This is a warning\",\n"
"    \"<br/>This is the <i>last</i> warning\",\n"
"    Notification.TYPE_WARNING_MESSAGE, true)\n"
"    .show(Page.getCurrent());]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1037
#, no-c-format
msgid ""
"The caption and description are by default written on the same line. If you "
"want to have a line break between them, use the HTML line break markup "
"\"<literal>&lt;br/&gt;</literal>\" if HTML is enabled, or \"<literal>\\n</"
"literal>\" if not. HTML is disabled by default, but can be enabled with "
"<methodname>setHtmlContentAllowed(true)</methodname>. When enabled, you can "
"use any HTML markup in the caption and description of a notification. If it "
"is in any way possible to get the notification content from user input, you "
"should either disallow HTML or sanitize the content carefully, as noted in "
"<xref linkend=\"advanced.security.sanitizing\"/>."
msgstr ""
"标题和描述信息默认显示在同一行中. 如果你希望在它们之间显示一个换行符, 在 "
"HTML 可用的情况下请用 HTML 的换行标记 \"<literal>&lt;br/&gt;</literal>\", "
"HTML 禁用时可以使用 \"<literal>\\n</literal>\". HTML 默认是禁用的, 但可以通"
"过 <methodname>setHtmlContentAllowed(true)</methodname> 来允许使用 HTML . 当 "
"HTML 允许使用时, 你可以在通知的标题和描述信息中使用任意的 HTML 标签. 如果你的"
"通知内容有可能来自用户的输入, 你应该禁用 HTML, 否则的话, 应该仔细处理通知内"
"容, 以防发生 HTML 注入, 详情参见 <xref linkend=\"advanced.security.sanitizing"
"\"/>."

#. Tag: title
#: chapter-application.xml:1050
#, no-c-format
msgid "Notification with HTML Formatting"
msgstr "使用 HTML 格式化的通知"

#. Tag: title
#: chapter-application.xml:1062
#, no-c-format
msgid "Notification Type"
msgstr "通知类型"

#. Tag: para
#: chapter-application.xml:1064
#, no-c-format
msgid ""
"The notification type defines the overall default style and behaviour of a "
"notification. If no notification type is given, the \"humanized\" type is "
"used as the default. The notification types, listed below, are defined in "
"the <classname>Notification.Type</classname> class."
msgstr ""
"通知类型决定了一个通知的默认 style 和默认行为. 如果没有指定通知类型, 默认会使"
"用 \"humanized\" 类型. 如下所示的各通知类型, 声明在 <classname>Notification."
"Type</classname> 类中."

#. Tag: parameter
#: chapter-application.xml:1074
#, no-c-format
msgid "TYPE_HUMANIZED_MESSAGE"
msgstr ""

#. Tag: para
#: chapter-application.xml:1085
#, no-c-format
msgid ""
"A user-friendly message that does not annoy too much: it does not require "
"confirmation by clicking and disappears quickly. It is centered and has a "
"neutral gray color."
msgstr ""
"一种用户友好的消息, 不会过度干扰用户: 它不要求用户点击来确认它, 而且会快速消"
"失. 它显示为灰色, 位于屏幕中间."

#. Tag: parameter
#: chapter-application.xml:1094
#, no-c-format
msgid "TYPE_WARNING_MESSAGE"
msgstr ""

#. Tag: para
#: chapter-application.xml:1105
#, no-c-format
msgid ""
"Warnings are messages of medium importance. They are displayed with colors "
"that are neither neutral nor too distractive. A warning is displayed for 1.5 "
"seconds, but the user can click the message box to dismiss it. The user can "
"continue to interact with the application while the warning is displayed."
msgstr ""
"警告, 是中等重要度的消息. 它显示为既不太黑白, 也不过于引人注目的彩色. 警告显"
"示1.5秒, 但用户可以点击警告框, 立即关闭它. 即使在警告显示时, 用户也可以继续操"
"作应用程序."

#. Tag: parameter
#: chapter-application.xml:1116
#, no-c-format
msgid "TYPE_ERROR_MESSAGE"
msgstr ""

#. Tag: para
#: chapter-application.xml:1127
#, no-c-format
msgid ""
"Error messages are notifications that require the highest user attention, "
"with alert colors, and they require the user to click the message to dismiss "
"it. The error message box does not itself include an instruction to click "
"the message, although the close box in the upper right corner indicates it "
"visually. Unlike with other notifications, the user can not interact with "
"the application while the error message is displayed."
msgstr ""
"错误消息是通知的一种, 它要求用户的高度注意, 它显示为警报的颜色, 而且要求用户"
"点击错误消息框才能关闭它. 错误消息框本身并没有指示用户去点击消息, 不过在它的"
"右上角会显示一个关闭框. 与其他类型的通知不同, 当错误消息显示时, 用户不可以操"
"作应用程序."

#. Tag: parameter
#: chapter-application.xml:1141
#, no-c-format
msgid "TYPE_TRAY_NOTIFICATION"
msgstr ""

#. Tag: para
#: chapter-application.xml:1152
#, no-c-format
msgid ""
"Tray notifications are displayed in the \"system tray\" area, that is, in "
"the lower-right corner of the browser view. As they do not usually obscure "
"any user interface, they are displayed longer than humanized or warning "
"messages, 3 seconds by default. The user can continue to interact with the "
"application normally while the tray notification is displayed."
msgstr ""
"托盘通知显示在 \"系统托盘\" 区域, 也就是, 浏览器的右下角区域. 由于托盘通知通"
"常不会遮挡任何用户界面, 因此它们的显示时间比 \"humanized\"类型或警告类型要"
"长, 默认为 3 秒. 托盘通知显示时, 用户可以继续正常操作应用程序."

#. Tag: title
#: chapter-application.xml:1166
#, no-c-format
msgid "Customizing Notifications"
msgstr "定制通知"

#. Tag: para
#: chapter-application.xml:1168
#, no-c-format
msgid ""
"All of the features of specific notification types can be controlled with "
"the <classname>Notification</classname> properties. Once configured, you "
"need to show it in the current page."
msgstr ""
"上述各通知类型的一切功能, 都可以通过 <classname>Notification</classname> 的属"
"性来精确控制. 通知设置完成之后, 你还需要将它显示在当前页面中."

#. Tag: programlisting
#: chapter-application.xml:1174
#, no-c-format
msgid ""
"<![CDATA[// Notification with default settings for a warning\n"
"Notification notif = new Notification(\n"
"    \"Warning\",\n"
"    \"<br/>Area of reindeer husbandry\",\n"
"    Notification.TYPE_WARNING_MESSAGE);\n"
"\n"
"// Customize it\n"
"notif.setDelayMsec(20000);\n"
"notif.setPosition(Position.BOTTOM_RIGHT);\n"
"notif.setStyleName(\"mystyle\");\n"
"notif.setIcon(new ThemeResource(\"img/reindeer.png\"));\n"
"                \n"
"// Show it in the page\n"
"notif.show(Page.getCurrent());]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1176
#, no-c-format
msgid ""
"The <methodname>setPosition()</methodname> method allows setting the "
"positioning of the notification. The position can be specified by any of the "
"constants defined in the <classname>Position</classname> enum."
msgstr ""
"<methodname>setPosition()</methodname> 方法可用来设置通知的显示位置. 位置可以"
"由枚举型 <classname>Position</classname> 中定义的常数来指定."

#. Tag: para
#: chapter-application.xml:1182
#, no-c-format
msgid ""
"The <methodname>setDelayMSec()</methodname> allows setting the time for how "
"long the notification is displayed in milliseconds. Parameter value "
"<literal>-1</literal> means that the message is displayed until the user "
"clicks the message box. It also prevents interaction with other parts of the "
"application window, which is the default behaviour for error notifications. "
"It does not, however, add a close box that the error notification has."
msgstr ""
"<methodname>setDelayMSec()</methodname> 方法可用来设置通知的显示时间, 单位是"
"毫秒. 参数值 <literal>-1</literal> 表示消息将永远显示, 直到用户点击消息框它才"
"会消失. 这个参数值还会禁止用户操作应用程序的其他部分, 这也是错误型通知的默认"
"行为. 但它不会象错误型通知那样, 在消息框上增加一个关闭框."

#. Tag: title
#: chapter-application.xml:1194
#, no-c-format
msgid "Styling with CSS"
msgstr "使用 CSS 来控制样式"

#. Tag: programlisting
#: chapter-application.xml:1196
#, no-c-format
msgid ""
"<![CDATA[.v-Notification {}\n"
"  .popupContent {}\n"
"    .gwt-HTML {}\n"
"      h1 {}\n"
"      p  {}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1198
#, no-c-format
msgid ""
"The notification box is a floating <literal>div</literal> element under the "
"<literal>body</literal> element of the page. It has an overall <literal>v-"
"Notification</literal> style. The content is wrapped inside an element with "
"<literal>popupContent</literal> style. The caption is enclosed within an "
"<literal>h1</literal> element and the description in a <literal>p</literal> "
"element."
msgstr ""
"通知消息框是一个浮动的 <literal>div</literal> 元素, 位于页面的 "
"<literal>body</literal> 元素之下. 它的最顶层样式是 <literal>v-Notification</"
"literal>. 通知的内容被包装在一个元素内, 这个元素的样式是 "
"<literal>popupContent</literal>. 标题包含在 <literal>h1</literal> 元素内, 描"
"述信息则在 <literal>p</literal> 元素内."

#. Tag: para
#: chapter-application.xml:1207
#, no-c-format
msgid ""
"To customize it, add a style for the <classname>Notification</classname> "
"object with <methodname>setStyleName(\"mystyle\")</methodname>, and make the "
"settings in the theme, for example as follows:"
msgstr ""
"想要定制通知的外观表现, 首先可以通过 <methodname>setStyleName(\"mystyle\")</"
"methodname> 方法为 <classname>Notification</classname> 对象添加一个样式, 然后"
"在 theme 内设置这个样式的外观表现, 例子如下:"

#. Tag: programlisting
#: chapter-application.xml:1213
#, no-c-format
msgid ""
"<![CDATA[.v-Notification.mystyle {\n"
"    background: #FFFF00;\n"
"    border: 10px solid #C00000;\n"
"    color: black;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1215
#, no-c-format
msgid ""
"The result is shown, with the icon set earlier in the customization example, "
"in <xref linkend=\"figure.application.errors.notifications.css\"/>."
msgstr ""
"上述示例的运行结果见 <xref linkend=\"figure.application.errors.notifications."
"css\"/>, 图中显示的图标, 是由更前面的\"定制通知\"中的示例设定的."

#. Tag: title
#: chapter-application.xml:1222
#, no-c-format
msgid "A Styled Notification"
msgstr "自定义样式的通知"

#. Tag: title
#: chapter-application.xml:1236
#, no-c-format
msgid "Application Lifecycle"
msgstr "应用程序的生命周期"

#. Tag: para
#: chapter-application.xml:1238
#, no-c-format
msgid ""
"In this section, we look into more technical details of application "
"deployment, user sessions, and UI instance lifecycle. These details are not "
"generally needed for writing Vaadin applications, but may be useful for "
"understanding how they actually work and, especially, in what circumstances "
"their execution ends."
msgstr ""
"本节中, 我们从技术细节的层面详细讨论应用程序的发布, 用户 Session, UI 实例的生"
"命周期等等问题. 对于 Vaadin 应用程序开发来说, 这些技术细节并不是必须的知识, "
"但有助于理解 Vaadin 应用程序究竟是如何工作的, 尤其是可以帮助理解应用程序会在"
"什么情况下结束运行."

#. Tag: title
#: chapter-application.xml:1247
#, no-c-format
msgid "Deployment"
msgstr "发布"

#. Tag: para
#: chapter-application.xml:1249
#, no-c-format
msgid ""
"Before a Vaadin application can be used, it has to be deployed to a Java web "
"server, as described in <xref linkend=\"application.environment\"/>. "
"Deploying reads the servlet classes annotated with the <literal>@WebServlet</"
"literal> annotation (Servlet 3.0) or the <filename>web.xml</filename> "
"deployment descriptor (Servlet 2.4) in the application to register servlets "
"for specific URL paths and loads the classes. Deployment does not yet "
"normally run any code in the application, although static blocks in classes "
"are executed when they are loaded."
msgstr ""
"Vaadin 应用程序可供用户使用之前, 必须发布到 Java Web 服务器上, 详情请参见 "
"<xref linkend=\"application.environment\"/>. 发布过程将读取 Servlet 类设定, "
"这个设定可以通过 <literal>@WebServlet</literal> 注解来指定(Servlet 3.0 环境"
"下), 也可以使用应用程序内的部署描述文件 <filename>web.xml</filename> 来指定"
"(Servlet 2.4 环境下), 得到 Servlet 类设定信息后, 发布过程会为特定的 URL 路径"
"注册 Servlet, 并装载 Java 类. 到此为止发布过程还不会运行应用程序内的任何代"
"码, 不过 Java 类被装载时, 其中的 static 代码段会被执行."

#. Tag: title
#: chapter-application.xml:1262
#, no-c-format
msgid "Undeploying and Redeploying"
msgstr "卸载和重发布"

#. Tag: para
#: chapter-application.xml:1264
#, no-c-format
msgid ""
"Applications are undeployed when the server shuts down, during redeployment, "
"and when they are explicitly undeployed. Undeploying a server-side Vaadin "
"application ends its execution, all application classes are unloaded, and "
"the heap space allocated by the application is freed for garbage-collection."
msgstr ""
"应用程序的卸载发生在以下3种情况: 1,服务器停止运行, 2, 应用程序重发布, 3, 被管"
"理者明确地卸载. 卸载一个服务器端 Vaadin 应用程序将终止它的运行, 应用程序内的"
"所有 Java 类将被卸载, 应用程序分配的全部堆空间(heap space)将被释放, 未来会被 "
"Java 机的垃圾收集器回收."

#. Tag: para
#: chapter-application.xml:1272
#, no-c-format
msgid ""
"If any user sessions are open at this point, the client-side state of the "
"UIs is left hanging and an Out of Sync error is displayed on the next server "
"request."
msgstr ""
"如果此时存在活动的用户 Session , UI 的客户端状态将被挂起, 下次发生向服务器的"
"请求时, 将出现一个同步失败的错误消息."

#. Tag: title
#: chapter-application.xml:1280
#, no-c-format
msgid "Redeployment and Serialization"
msgstr "重发布与序列化"

#. Tag: para
#: chapter-application.xml:1282
#, no-c-format
msgid ""
"Some servers, such as Tomcat, support <emphasis>hot deployment</emphasis>, "
"where the classes are reloaded while preserving the memory state of the "
"application. This is done by serializing the application state and then "
"deserializing it after the classes are reloaded. This is, in fact, done with "
"the basic Eclipse setup with Tomcat and if a UI is marked as "
"<classname>@PreserveOnRefresh</classname>, you may actually need to give the "
"<literal>?restartApplication</literal> URL parameter to force it to restart "
"when you reload the page. Tools such as JRebel go even further by reloading "
"the code in place without need for serialization. The server can also "
"serialize the application state when shutting down and restarting, thereby "
"preserving sessions over restarts."
msgstr ""
"某些服务器, 比如 Tomcat, 支持 <emphasis>热部署</emphasis>, 这种情况下类可以被"
"重新装载, 同时保持应用程序的内存状态不变. 这种功能是通过以下手段实现的: 1,首"
"先将应用程序状态序列化, 2,重新装载 Java 类后, 再反序列化, 恢复原来的应用程序"
"状态. 如果你使用基本的 Eclipse 加 Tomcat 配置, 而且 UI 被标记了"
"<classname>@PreserveOnRefresh</classname> 注解, 这个功能就会生效. 如果你希望"
"强制应用程序重启动, 你需要在 URL 中加上 <literal>?restartApplication</"
"literal> 参数才可以. JRebel 之类的工具的功能更为强大, 它可以在适当的时刻重新"
"装载 Java 类的代码, 而不需要使用序列化/反序列化手段. 服务器关闭和重启时也可以"
"序列化应用程序状态, 这样在服务器重启时就可以保持住 Session 信息了."

#. Tag: para
#: chapter-application.xml:1298
#, no-c-format
msgid ""
"Serialization requires that the applications are <emphasis>serializable</"
"emphasis>, that is, all classes implement the <interfacename>Serializable</"
"interfacename> interface. All Vaadin classes do. If you extend them or "
"implement interfaces, you can provide an optional serialization key, which "
"is automatically generated by Eclipse if you use it. Serialization is also "
"used for clustering and cloud computing, such as with Google App "
"Engine<phrase condition=\"web\">, as described in <xref linkend=\"advanced."
"gae\"/></phrase>."
msgstr ""
"序列化功能需要应用程序是 <emphasis>可序列化的</emphasis>, 也就是说, 所有的类"
"必须实现 <interfacename>Serializable</interfacename> 接口. Vaadin 的所有类都"
"已实现了这个接口. 如果你需要扩展 Vaadin 类, 或实现接口, 你可以给定一个可选的"
"序列化 key, 如果你使用 Eclipse 的话, 这个 key 可以自动生成. 序列化也被用于集"
"群计算和云计算环境, 比如 Google App Engine<phrase condition=\"web\">, 详情请"
"参见 <xref linkend=\"advanced.gae\"/></phrase>."

#. Tag: title
#: chapter-application.xml:1313
#, no-c-format
msgid "Vaadin Servlet, Portlet, and Service"
msgstr "Vaadin Servlet, Portlet, 和 Service"

#. Tag: para
#: chapter-application.xml:1315
#, no-c-format
msgid ""
"The <classname>VaadinServlet</classname>, or <classname>VaadinPortlet</"
"classname> in a portal, receives all server requests mapped to it by its "
"URL, as defined in the deployment configuration, and associates them with "
"sessions. The sessions further associate the requests with particular UIs."
msgstr ""
"<classname>VaadinServlet</classname> 类, 或 portal 中的 "
"<classname>VaadinPortlet</classname> 类, 接受所有向服务器的请求, 请求通过 "
"URL 映射到这些类, 映射关系由发布设定来配置, 然后 VaadinServlet 或 "
"VaadinPortlet 将请求关联到 Session 上. Sessions 再将请求关联到某个特定的 UI."

#. Tag: para
#: chapter-application.xml:1323
#, no-c-format
msgid ""
"When servicing requests, the Vaadin servlet or portlet handles all tasks "
"common to both servlets and portlets in a <classname>VaadinService</"
"classname>. It manages sessions, gives access to the deployment "
"configuration information, handles system messages, and does various other "
"tasks. Any further servlet or portlet specific tasks are handled in the "
"corresponding <classname>VaadinServletService</classname> or "
"<classname>VaadinPortletService</classname>. The service acts as the primary "
"low-level customization layer for processing requests."
msgstr ""
"当收到请求时, Vaadin Servlet 或 portlet 通过 <classname>VaadinService</"
"classname> 来处理 Servlet 和 portlet 共有的任务. 这个类负责管理 Session, 提供"
"对部署设定信息的访问能力, 管理系统消息, 并负责其他很多任务. 与 Servlet 或 "
"portlet 相关的更多特别处理, 由 <classname>VaadinServletService</classname> 类"
"或 <classname>VaadinPortletService</classname> 类来处理. Service 以主要低阶定"
"制层的形式处理客户端请求."

#. Tag: title
#: chapter-application.xml:1336
#, no-c-format
msgid "Customizing Vaadin Servlet"
msgstr "定制 Vaadin Servlet"

#. Tag: para
#: chapter-application.xml:1338
#, no-c-format
msgid ""
"Many common configuration tasks need to be done in the servlet class, which "
"you already have if you are using the <literal>@WebServlet</literal> "
"annotation for Servlet 3.0 to deploy the application. You can handle most "
"customization by overriding the <methodname>servletInitialized()</"
"methodname> method, where the <classname>VaadinService</classname> object is "
"available with <methodname>getService()</methodname> (it would not be "
"available in a constructor). You should always call <methodname>super."
"servletInitialized()</methodname> in the beginning."
msgstr ""
"在 Servlet 类中需要完成很多共通的配置任务, 如果你使用 Servlet 3.0 环境的 "
"<literal>@WebServlet</literal> 注解来部署你的应用程序, 你的配置任务其实已经完"
"成了. 你可以重载 <methodname>servletInitialized()</methodname> 方法来实现大部"
"分的定制任务, 在这个方法中可以通过 <methodname>getService()</methodname> 方法"
"得到 <classname>VaadinService</classname> 对象(这个对象在构造方法中是无法得到"
"的). 在你的代码中, 首先必须调用 <methodname>super.servletInitialized()</"
"methodname> 方法."

#. Tag: programlisting
#: chapter-application.xml:1350
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyServlet extends VaadinServlet {\n"
"    @Override\n"
"    protected void servletInitialized()\n"
"            throws ServletException {\n"
"        super.servletInitialized();\n"
"\n"
"        ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1352
#, no-c-format
msgid ""
"To add custom functionality around request handling, you can override the "
"<methodname>service()</methodname> method."
msgstr ""
"在处理客户端请求的过程中, 想要追加某种定制的功能的话, 你可以重载 "
"<methodname>service()</methodname> 方法."

#. Tag: para
#: chapter-application.xml:1357
#, no-c-format
msgid ""
"To use the custom servlet class in a Servlet 2.4 project, you need to define "
"it in the <filename>web.xml</filename> deployment descriptor instead of the "
"regular <classname>VaadinServlet</classname> class, as described in <xref "
"linkend=\"application.environment.web-xml\"/>."
msgstr ""
"在 Servlet 2.4 环境下, 想要使用定制的 Servlet 类的话, 你需要在部署描述文件 "
"<filename>web.xml</filename> 中指定使用你的 Servlet 类, 而不是通常的 "
"<classname>VaadinServlet</classname> 类, 详情请参见 <xref linkend="
"\"application.environment.web-xml\"/>."

#. Tag: title
#: chapter-application.xml:1366
#, no-c-format
msgid "Customizing Vaadin Portlet"
msgstr "定制 Vaadin Portlet"

#. Tag: emphasis
#: chapter-application.xml:1369
#, no-c-format
msgid "To Be Done"
msgstr "本节未完成"

#. Tag: title
#: chapter-application.xml:1374
#, no-c-format
msgid "Customizing Vaadin Service"
msgstr "定制 Vaadin Service"

#. Tag: para
#: chapter-application.xml:1376
#, no-c-format
msgid ""
"To customize <classname>VaadinService</classname>, you first need to extend "
"the <classname>VaadinServlet</classname> or -<classname>Portlet</classname> "
"class and override the <methodname>createServletService()</methodname> to "
"create a custom service object."
msgstr ""
"想要定制 <classname>VaadinService</classname>, 你首先需要继承 "
"<classname>VaadinServlet</classname> 或 <classname>Portlet</classname> 类, 重"
"载 <methodname>createServletService()</methodname> 方法, 然后创建定制的 "
"Service 对象."

#. Tag: title
#: chapter-application.xml:1387
#, no-c-format
msgid "User Session"
msgstr "用户 Session"

#. Tag: para
#: chapter-application.xml:1393
#, no-c-format
msgid ""
"A user session begins when a user first makes a request to a Vaadin servlet "
"or portlet by opening the URL for a particular <classname>UI</classname>. "
"All server requests belonging to a particular UI class are processed by the "
"<classname>VaadinServlet</classname> or <classname>VaadinPortlet</classname> "
"class. When a new client connects, it creates a new user session, "
"represented by an instance of <classname>VaadinSession</classname>. Sessions "
"are tracked using cookies stored in the browser."
msgstr ""
"当用户打开某个<classname>UI</classname> 的 URL, 初次访问一个 Vaadin servlet "
"或 portlet 时,  用户 Session 就开始活动了. 属于某个 UI 类的全部服务器请求都"
"由 <classname>VaadinServlet</classname> 或 <classname>VaadinPortlet</"
"classname> 类来处理. 当一个新的客户端连接到应用程序时, 它会创建出新的用户 "
"Session, <classname>VaadinSession</classname> 类的一个实例就代表一个用户 "
"Session. Session 的追踪是使用浏览器端保存的 cookie 来实现的."

#. Tag: para
#: chapter-application.xml:1404
#, no-c-format
msgid ""
"You can obtain the <classname>VaadinSession</classname> of a <classname>UI</"
"classname> with <methodname>getSession()</methodname> or globally with "
"<methodname>VaadinSession.getCurrent()</methodname>. It also provides access "
"to the lower-level session objects, <interfacename>HttpSession</"
"interfacename> and <interfacename>PortletSession</interfacename>, through a "
"<classname>WrappedSession</classname>. You can also access the deployment "
"configuration through <classname>VaadinSession</classname>, as described in "
"<xref linkend=\"application.environment.configuration\"/>."
msgstr ""
"你可以使用 <classname>UI</classname> 类的 <methodname>getSession()</"
"methodname> 方法得到它的 <classname>VaadinSession</classname>, 或者通过全局方"
"法 <methodname>VaadinSession.getCurrent()</methodname> 也可以. 通过 "
"<classname>WrappedSession</classname> 还可以访问到低阶 Session 对象, 也就是 "
"<interfacename>HttpSession</interfacename> 和 <interfacename>PortletSession</"
"interfacename>. 通过 <classname>VaadinSession</classname> 你还可以访问到部署"
"配置信息, 详情请参见 <xref linkend=\"application.environment.configuration\"/"
">."

#. Tag: para
#: chapter-application.xml:1416
#, no-c-format
msgid ""
"A session ends after the last <classname>UI</classname> instance expires or "
"is closed, as described later."
msgstr ""
"当 <classname>UI</classname> 实例过期或被关闭时, 用户 Session 就会结束. 详情"
"参见本节后述内容."

#. Tag: title
#: chapter-application.xml:1422
#, no-c-format
msgid "Handling Session Initialization and Destruction"
msgstr "处理 Session 的初始化和消灭"

#. Tag: classname
#: chapter-application.xml:1425
#, no-c-format
msgid "SessionInitListener"
msgstr ""

#. Tag: classname
#: chapter-application.xml:1428
#, no-c-format
msgid "<classname>SessionDestroyListener</classname>"
msgstr ""

#. Tag: classname
#: chapter-application.xml:1432
#, no-c-format
msgid "VaadinService"
msgstr ""

#. Tag: para
#: chapter-application.xml:1432
#, no-c-format
msgid ""
"You can handle session initialization and destruction by implementing a "
"<interfacename>SessionInitListener</interfacename> or "
"<interfacename>SessionDestroyListener</interfacename>, respectively, to the "
"<classname>VaadinService</classname>. "
"<indexterm><primary><methodname>servletInitialized()</methodname></primary></"
"indexterm> <indexterm><primary><classname>VaadinServlet</classname></"
"primary></indexterm> You can do that best by extending "
"<classname>VaadinServlet</classname> and overriding the "
"<methodname>servletInitialized()</methodname> method, as outlined in <xref "
"linkend=\"application.lifecycle.servlet-service\"/>."
msgstr ""
"你可以处理 Session 的初期化和消灭, 方法是分别实现 "
"<interfacename>SessionInitListener</interfacename> 和 "
"<interfacename>SessionDestroyListener</interfacename> 接口, 然后将这两个监听"
"器追加到 <classname>VaadinService</classname> 中. "
"<indexterm><primary><methodname>servletInitialized()</methodname></primary></"
"indexterm> <indexterm><primary><classname>VaadinServlet</classname></"
"primary></indexterm> 实现以上任务最简单的方法是扩展 "
"<classname>VaadinServlet</classname> 类, 重载它的 "
"<methodname>servletInitialized()</methodname> 方法, 详情请参见 <xref linkend="
"\"application.lifecycle.servlet-service\"/>."

#. Tag: programlisting
#: chapter-application.xml:1448
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyServlet extends VaadinServlet\n"
"    implements SessionInitListener, SessionDestroyListener {\n"
"\n"
"    @Override\n"
"    protected void servletInitialized() throws ServletException {\n"
"        super.servletInitialized();\n"
"        getService().addSessionInitListener(this);\n"
"        getService().addSessionDestroyListener(this);\n"
"    }\n"
"\n"
"    @Override\n"
"    public void sessionInit(SessionInitEvent event)\n"
"            throws ServiceException {\n"
"        // Do session start stuff here\n"
"    }\n"
"\n"
"    @Override\n"
"    public void sessionDestroy(SessionDestroyEvent event) {\n"
"        // Do session end stuff here\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1450
#, no-c-format
msgid ""
"If using Servlet 2.4, you need to configure the custom servlet class in the "
"<parameter>servlet-class</parameter> parameter in the <filename>web.xml</"
"filename> descriptor instead of the <classname>VaadinServlet</classname>, as "
"described in <xref linkend=\"application.environment.web-xml\"/>."
msgstr ""
"如果使用的是 Servlet 2.4, 你需要将部署描述文件 <filename>web.xml</filename> "
"中的 <parameter>servlet-class</parameter> 参数设置为你的自定义的Servlet 类, "
"而不是通常的 <classname>VaadinServlet</classname> 类, 详情请参见 <xref "
"linkend=\"application.environment.web-xml\"/>."

#. Tag: title
#: chapter-application.xml:1461
#, no-c-format
msgid "Loading a UI"
msgstr "装载 UI"

#. Tag: primary
#: chapter-application.xml:1464 chapter-application.xml:1559
#: chapter-application.xml:1597 chapter-application.xml:1630
#: chapter-application.xml:1786
#, no-c-format
msgid "<primary>UI</primary>"
msgstr ""

#. Tag: secondary
#: chapter-application.xml:1465
#, no-c-format
msgid "loading"
msgstr ""

#. Tag: para
#: chapter-application.xml:1468
#, no-c-format
msgid ""
"When a browser first accesses a URL mapped to the servlet of a particular UI "
"class, the Vaadin servlet generates a loader page. The page loads the client-"
"side engine (widget set), which in turn loads the UI in a separate request "
"to the Vaadin servlet."
msgstr ""
"当浏览器初次访问某个 UI 的 URL 时, Vaadin Servlet 会生成一个装载页面. 这个页"
"面会装载客户端引擎(widget set), 客户端引擎再向 Vaadin Servlet 发起一个独立的"
"请求来装载 UI."

#. Tag: classname
#: chapter-application.xml:1476
#, no-c-format
msgid "<classname>UIProvider</classname>"
msgstr ""

#. Tag: classname
#: chapter-application.xml:1477
#, no-c-format
msgid "DefaultUIProvider"
msgstr ""

#. Tag: classname
#: chapter-application.xml:1478
#, no-c-format
msgid "BrowserWindowOpener"
msgstr ""

#. Tag: para
#: chapter-application.xml:1478
#, no-c-format
msgid ""
"A <classname>UI</classname> instance is created when the client-side engine "
"makes its first request. The servlet creates the UIs using a "
"<classname>UIProvider</classname> registered in the "
"<classname>VaadinSession</classname> instance. A session has at least a "
"<classname>DefaultUIProvider</classname> for managing UIs opened by the "
"user. If the application lets the user open popup windows with a "
"<classname>BrowserWindowOpener</classname>, each of them has a dedicated "
"special UI provider."
msgstr ""
"当客户端引擎发起它的初次请求时, <classname>UI</classname> 类的一个实例会被创"
"建出来 . Servlet 使用 <classname>UIProvider</classname> 类来创建 UI 实"
"例,     UIProvider 则被注册在 <classname>VaadinSession</classname> 实例中. 一"
"个 Session 至少拥有一个 <classname>DefaultUIProvider</classname> 来管理用户打"
"开的 UI. 如果应用程序允许用户使用 <classname>BrowserWindowOpener</classname> "
"打开弹出式窗口 , 那么每个弹出式窗口都将拥有独自的 UI Provider."

#. Tag: classname
#: chapter-application.xml:1492
#, no-c-format
msgid "VaadinRequest"
msgstr ""

#. Tag: methodname
#: chapter-application.xml:1493
#, no-c-format
msgid "init()"
msgstr ""

#. Tag: para
#: chapter-application.xml:1493
#, no-c-format
msgid ""
"Once a new UI is created, its <methodname>init()</methodname> method is "
"called. The method gets the request as a <classname>VaadinRequest</"
"classname>."
msgstr ""
"新的 UI 实例创建出来之后, 它的 <methodname>init()</methodname> 方法将被调用. "
"这个方法将收到 <classname>VaadinRequest</classname> 类代表的请求对象."

#. Tag: title
#: chapter-application.xml:1501
#, no-c-format
msgid "Customizing the Loader Page"
msgstr "定制装载页面"

#. Tag: para
#: chapter-application.xml:1503
#, no-c-format
msgid ""
"The HTML content of the loader page is generated as an HTML DOM object, "
"which can be customized by implementing a <interfacename>BootstrapListener</"
"interfacename> that modifies the DOM object. To do so, you need to extend "
"the <classname>VaadinServlet</classname> and add a "
"<interfacename>SessionInitListener</interfacename> to the service object, as "
"outlined in <xref linkend=\"application.lifecycle.session\"/>. You can then "
"add the bootstrap listener to a session with "
"<methodname>addBootstrapListener()</methodname> when the session is "
"initialized."
msgstr ""
"装载页面的 HTML 内容是以 HTML DOM 对象方式生成的, 其内容是可以定制的, 方法是"
"实现一个 <interfacename>BootstrapListener</interfacename>, 在这个监听器中修"
"改 DOM 对象. 为了这个目的, 你需要扩展 <classname>VaadinServlet</classname> "
"类, 向 Service 对象追加一个 <interfacename>SessionInitListener</"
"interfacename>, 详情请参见 <xref linkend=\"application.lifecycle.session\"/"
">. 然后在 Session 初期化时, 通过 <methodname>addBootstrapListener()</"
"methodname> 方法向 Session 追加一个 BootstrapListener."

#. Tag: para
#: chapter-application.xml:1517
#, no-c-format
msgid ""
"Loading the widget set is handled in the loader page with functions defined "
"in a separate <filename>vaadinBootstrap.js</filename> script."
msgstr ""
"Widget 群通过装载页面来装载,  负责处理这个任务的函数定义在单独的 "
"<filename>vaadinBootstrap.js</filename> 脚本文件中."

#. Tag: para
#: chapter-application.xml:1522
#, no-c-format
msgid ""
"You can also use entirely custom loader code, such as in a static HTML page, "
"as described in <xref linkend=\"advanced.embedding\"/>."
msgstr ""
"你也可以使用完全自定义的装载代码, 比如一个静态的 HTML 页面, 详情请参照 <xref "
"linkend=\"advanced.embedding\"/>."

#. Tag: title
#: chapter-application.xml:1530
#, no-c-format
msgid "Custom UI Providers"
msgstr "定制 UI Provider"

#. Tag: interfacename
#: chapter-application.xml:1533
#, no-c-format
msgid "<interfacename>UIProvider</interfacename>"
msgstr ""

#. Tag: secondary
#: chapter-application.xml:1534
#, no-c-format
msgid "custom"
msgstr ""

#. Tag: para
#: chapter-application.xml:1537
#, no-c-format
msgid ""
"You can create UI objects dynamically according to their request parameters, "
"such as the URL path, by defining a custom <interfacename>UIProvider</"
"interfacename>. You need to add custom UI providers to the session object "
"which calls them. The providers are chained so that they are requested "
"starting from the one added last, until one returns a UI (otherwise they "
"return null). You can add a UI provider to a session most conveniently by "
"implementing a custom servlet and adding the UI provider to sessions in a "
"<interfacename>SessionInitListener</interfacename>."
msgstr ""
"你可以根据请求参数(比如 URL 路径)来动态地创建 UI 对象, 方法是定义一个定制的 "
"<interfacename>UIProvider</interfacename>. 你需要将定制的 UI Provider 添加到 "
"Session 对象中, Session 对象负责调用 UI Provider . UI Provider 是串联工作的, "
"因此最后添加的那个 UI Provider 将会第一个被调用, 如果串联起来的多个 UI "
"Provider 中有一个返回了 UI, 那么它之后的 UI Provider 就不会被调用, 相反, 如果"
"某个 UI Provider  返回了 null, 那么它之后的 UI Provider 会被继续调用. 将 UI "
"Provider 添加到 Session 对象中, 最简便的方法是实现一个定制的 Servlet, 然后在 "
"<interfacename>SessionInitListener</interfacename> 监听器中, 将 UI Provider "
"添加到 Session 中."

#. Tag: para
#: chapter-application.xml:1549
#, no-c-format
msgid ""
"You can find an example of custom UI providers in <xref linkend=\"mobile."
"features.fallback\"/>."
msgstr ""
"关于定制 UI provider 的例子, 请参见 <xref linkend=\"mobile.features.fallback"
"\"/>."

#. Tag: title
#: chapter-application.xml:1556
#, no-c-format
msgid "Preserving UI on Refresh"
msgstr "阻止 UI 刷新"

#. Tag: secondary
#: chapter-application.xml:1560
#, no-c-format
msgid "preserving on refresh"
msgstr ""

#. Tag: classname
#: chapter-application.xml:1564
#, no-c-format
msgid "@PreserveOnRefresh"
msgstr ""

#. Tag: para
#: chapter-application.xml:1567
#, no-c-format
msgid ""
"Reloading a page in the browser normally spawns a new <classname>UI</"
"classname> instance and the old UI is left hanging, until cleaned up after a "
"while. This can be undesired as it resets the UI state for the user. To "
"preserve the UI, you can use the <classname>@PreserveOnRefresh</classname> "
"annotation for the UI class. You can also use a <classname>UIProvider</"
"classname> with a custom implementation of <methodname>isUiPreserved()</"
"methodname>."
msgstr ""
"在浏览器中重新装载页面通常会产生一个新的 <classname>UI</classname> 实例, 而旧"
"的 UI 将会残留在服务器中, 直到一段时间后才会被清除. 这样的结果可能是不理想"
"的, 因为对使用者来说, UI 的原有状态被清除了. 为了保护 UI 不被刷新, 你可以对 "
"UI 类使用 <classname>@PreserveOnRefresh</classname> 注解. 你也可以使用一个 "
"<classname>UIProvider</classname>, 定制它的 <methodname>isUiPreserved()</"
"methodname> 方法."

#. Tag: programlisting
#: chapter-application.xml:1577
#, no-c-format
msgid ""
"<![CDATA[@PreserveOnRefresh\n"
"public class MyUI extends UI {]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1579
#, no-c-format
msgid ""
"Adding the <uri>?restartApplication</uri> parameter in the URL tells the "
"Vaadin servlet to create a new <classname>UI</classname> instance when "
"loading the page, thereby overriding the <classname>@PreserveOnRefresh</"
"classname>. This is often necessary when developing such a UI in Eclipse, "
"when you need to restart it after redeploying, because Eclipse likes to "
"persist the application state between redeployments. If you also include a "
"URI fragment, the parameter should be given before the fragment."
msgstr ""
"在 URL 中添加 <uri>?restartApplication</uri> 参数, 会告诉 Vaadin Servlet 在装"
"载页面时创建新的 <classname>UI</classname> 实例, 因此也就推翻了 "
"<classname>@PreserveOnRefresh</classname> 注解的设定. Eclipse 在重发布应用程"
"序时通常会保持住应用程序状态, 而你修改代码后往往会希望重启 UI, 因此在 "
"Eclipse 中开发 UI 时常常有必要使用这个参数. 如果你的 URL 中含有 URI 片段, 这"
"个参数需要出现在 URI 片段之前."

#. Tag: title
#: chapter-application.xml:1594
#, no-c-format
msgid "UI Expiration"
msgstr "UI 过期"

#. Tag: para
#: chapter-application.xml:1601
#, no-c-format
msgid ""
"<classname>UI</classname> instances are cleaned up if no communication is "
"received from them after some time. If no other server requests are made, "
"the client-side sends keep-alive heartbeat requests. A UI is kept alive for "
"as long as requests or heartbeats are received from it. It expires if three "
"consecutive heartbeats are missed."
msgstr ""
"如果在一定时间内没有收到来自 UI 的通信, <classname>UI</classname> 实例会被清"
"除. 当没有向服务器发送其他请求时, 客户端会定期发送心跳请求, 以便保持 UI 处于"
"活动状态. 只要有来自 UI 的请求, 或心跳信号, UI 就会一直保持激活. 如果连续3次"
"心跳信号没有收到, 那么这个 UI 将会过期."

#. Tag: para
#: chapter-application.xml:1609
#, no-c-format
msgid ""
"The heartbeats occur at an interval of 5 minutes, which can be changed with "
"the <parameter>heartbeatInterval</parameter> parameter of the servlet. You "
"can configure the parameter in <classname>@VaadinServletConfiguration</"
"classname> or in <filename>web.xml</filename> as described in <xref linkend="
"\"application.environment.parameters\"/>."
msgstr ""
"心跳信号的发生间隔时间是 5 分钟, 这个间隔时间可以通过 Servlet 的 "
"<parameter>heartbeatInterval</parameter> 参数来修改. 你可以在 "
"<classname>@VaadinServletConfiguration</classname> 类中配置这个参数, 也可以"
"在 <filename>web.xml</filename> 文件中配置它, 详情请参见 <xref linkend="
"\"application.environment.parameters\"/>."

#. Tag: para
#: chapter-application.xml:1618
#, no-c-format
msgid ""
"When the UI cleanup happens, a <classname>DetachEvent</classname> is sent to "
"all <classname>DetachListener</classname>s added to the UI. When the "
"<classname>UI</classname> is detached from the session, "
"<methodname>detach()</methodname> is called for it."
msgstr ""
"当 UI 被清除时, <classname>DetachEvent</classname> 事件会被发送给这个 UI 上的"
"所有 <classname>DetachListener</classname> 监听器. 当 <classname>UI</"
"classname> 被从 Session 中断开时, 它的 <methodname>detach()</methodname> 方法"
"会被调用."

#. Tag: title
#: chapter-application.xml:1627
#, no-c-format
msgid "Closing UIs Explicitly"
msgstr "显式地关闭 UI"

#. Tag: secondary
#: chapter-application.xml:1631 chapter-application.xml:1732
#, no-c-format
msgid "closing"
msgstr ""

#. Tag: methodname
#: chapter-application.xml:1636 chapter-application.xml:1736
#, no-c-format
msgid "close()"
msgstr ""

#. Tag: secondary
#: chapter-application.xml:1637
#, no-c-format
msgid "<secondary>UI</secondary>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1638
#, no-c-format
msgid ""
"You can explicitly close a UI with <methodname>close()</methodname>. The "
"method marks the UI to be detached from the session after processing the "
"current request. Therefore, the method does not invalidate the UI instance "
"immediately and the response is sent as usual."
msgstr ""
"你可以使用 <methodname>close()</methodname>方法, 显式地关闭一个 UI. 这个方法"
"会在当前请求处理完毕之后, 将 UI 标记为与 session 脱离. 因此, 这个方法不会使 "
"UI 实例立即失效, 当前请求的应答也可以正常发回给客户端."

#. Tag: para
#: chapter-application.xml:1646
#, no-c-format
msgid ""
"Detaching a UI does not close the page or browser window in which the UI is "
"running and further server request will cause error. Typically, you either "
"want to close the window, reload it, or redirect it to another URL. If the "
"page is a regular browser window or tab, browsers generally do not allow "
"closing them programmatically, but redirection is possible. You can redirect "
"the window to another URL with <methodname>setLocation()</methodname>, as is "
"done in the examples in <xref linkend=\"application.lifecycle.session-closing"
"\"/>. You can close popup windows by making JavaScript <methodname>close()</"
"methodname> call for them, as described in <xref linkend=\"advanced.windows."
"popup-closing\"/>."
msgstr ""
"解除一个 UI 不会关闭 UI 所在的浏览器端页面或窗口, 但此后向服务器发起的请求都"
"会导致错误. 通常, 你可能希望关闭窗口, 或者重新载入页面, 或者跳转到其他 URL. "
"如果这个页面是一个通常的浏览器窗口或 tab 页, 浏览器一般不会允许通过程序来关闭"
"它, 但跳转到其他地址是允许的. 你可以使用 <methodname>setLocation()</"
"methodname> 方法将窗口重定向到另一个 URL, 比如 <xref linkend=\"application."
"lifecycle.session-closing\"/> 中的示例程序中就是如此. 对于弹出窗口, 你可以调"
"用 JavaScript <methodname>close()</methodname> 函数来关闭它, 详情请参见 "
"<xref linkend=\"advanced.windows.popup-closing\"/>."

#. Tag: para
#: chapter-application.xml:1660
#, no-c-format
msgid ""
"If you close other UI than the one associated with the current request, they "
"will not be detached at the end of the current request, but after next "
"request from the particular UI. You can make that occur quicker by making "
"the UI heartbeat faster or immediately by using server push."
msgstr ""
"如果你关闭与当前请求关联的 UI 实例之外的其他 UI 实例, 那么这个 UI 实例不会在"
"当前请求结束时解除, 而是在它自己发起的下一次请求结束之后才解除. 你可以让 UI "
"心跳间隔更快一些, 使得 UI 的解除尽快发生, 也可以使用服务器端 PUSH 来让 UI 的"
"解除立即发生."

#. Tag: title
#: chapter-application.xml:1669
#, no-c-format
msgid "Session Expiration"
msgstr "Session 过期"

#. Tag: para
#: chapter-application.xml:1676
#, no-c-format
msgid ""
"A session is kept alive by server requests caused by user interaction with "
"the application as well as the heartbeat monitoring of the UIs. Once all UIs "
"have expired, the session still remains. It is cleaned up from the server "
"when the session timeout configured in the web application expires."
msgstr ""
"当用户在应用程序中进行操作时, 就会发生对服务器的请求, 同时 UI 自身还会发送心"
"跳请求, 这两种请求将会保持 Session 激活. 当所有 UI 都失效时, Session 仍会保持"
"住. 当 Web 应用程序的 Session 过期时间到达之后, Session 才会过期, 然后被服务"
"器清除."

#. Tag: primary
#: chapter-application.xml:1684 chapter-application.xml:2312
#, no-c-format
msgid "closeIdleSessions"
msgstr ""

#. Tag: para
#: chapter-application.xml:1684
#, no-c-format
msgid ""
"If there are active UIs in an application, their heartbeat keeps the session "
"alive indefinitely. You may want to have the sessions timeout if the user is "
"inactive long enough, which is the original purpose of the session timeout "
"setting. <indexterm> <primary>session</primary> <secondary>timeout</"
"secondary> </indexterm> <indexterm><primary>closeIdleSessions</primary></"
"indexterm> If the <parameter>closeIdleSessions</parameter> parameter of the "
"servlet is set to <literal>true</literal> in the <filename>web.xml</"
"filename>, as described in <xref linkend=\"application.environment.web-xml\"/"
">, the session and all of its UIs are closed when the timeout specified by "
"the <parameter>session-timeout</parameter> parameter of the servlet expires "
"after the last non-heartbeat request. Once the session is gone, the browser "
"will show an Out Of Sync error on the next server request. "
"<indexterm><primary>redirection</primary></indexterm> To avoid the ugly "
"message, you may want to set a redirect URL for the UIs<phrase condition="
"\"web\">, as described in <xref linkend=\"application.errors.systemmessages"
"\"/></phrase>."
msgstr ""
"如果应用程序中还存在激活的 UI, 它们的心跳请求将保持 Session 永远激活. 当用户"
"长期不操作应用程序时, 你可能会希望 Session 超时, 这也正是 Session 超时设定本"
"来的意图. <indexterm> <primary>session</primary> <secondary>timeout</"
"secondary> </indexterm> <indexterm><primary>closeIdleSessions</primary></"
"indexterm>  如果在 <filename>web.xml</filename> 文件中, Servlet 的 "
"<parameter>closeIdleSessions</parameter> 参数被设置为 <literal>true</"
"literal>, (详情参见 <xref linkend=\"application.environment.web-xml\"/>), 那"
"么当最后一次非心跳请求之后, Servlet 的 <parameter>session-timeout</"
"parameter> 参数指定的超时时间达到之后, Session 会被判定为超时, Session 及其中"
"所有的 UI 都会被关闭. 一旦 Session 消失, 浏览器端下一次向服务器发起请求时, 将"
"显示一个同步失败的错误消息. <indexterm><primary>redirection</primary></"
"indexterm>  如果不想看到这个丑陋的消息, 你可能希望为 UI 设置一个重定向 "
"URL<phrase condition=\"web\">, 详情请参见 <xref linkend=\"application.errors."
"systemmessages\"/></phrase>."

#. Tag: para
#: chapter-application.xml:1713
#, no-c-format
msgid ""
"The related configuration parameters are described in <xref linkend="
"\"application.environment.parameters\"/>."
msgstr ""
"相关的设定参数请参见 <xref linkend=\"application.environment.parameters\"/>."

#. Tag: interfacename
#: chapter-application.xml:1719
#, no-c-format
msgid "<interfacename>SessionDestroyListener</interfacename>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1719
#, no-c-format
msgid ""
"You can handle session expiration on the server-side with a "
"<interfacename>SessionDestroyListener</interfacename>, as described in <xref "
"linkend=\"application.lifecycle.session\"/>."
msgstr ""
"你可以在服务器端使用<interfacename>SessionDestroyListener</interfacename> 监"
"听器来处理 Session 过期, 详情请参见 <xref linkend=\"application.lifecycle."
"session\"/>."

#. Tag: title
#: chapter-application.xml:1728
#, no-c-format
msgid "Closing a Session"
msgstr "关闭 Session"

#. Tag: para
#: chapter-application.xml:1736
#, no-c-format
msgid ""
"You can close a session by calling <methodname>close()</methodname> on the "
"<classname>VaadinSession</classname>. It is typically used when logging a "
"user out and the session and all the UIs belonging to the session should be "
"closed. The session is closed immediately and any objects related to it are "
"not available after calling the method."
msgstr ""
"你可以调用 <classname>VaadinSession</classname> 的 <methodname>close()</"
"methodname> 方法来关闭一个 session. 这种方式通常用于用户从系统中 Log out 时, "
"session 以及所有属于这个 session 的 UI 都需要关闭. 调用这个方法后, session 会"
"被立即关闭, 所有与之相关的对象都将不可使用."

#. Tag: para
#: chapter-application.xml:1745
#, no-c-format
msgid ""
"When closing the session from a UI, you typically want to redirect the user "
"to another URL. <indexterm><primary>redirection</primary></indexterm> "
"<indexterm><primary><methodname>setLocation()</methodname></primary></"
"indexterm> <indexterm><primary>Page</"
"primary><secondary><methodname>setLocation()</methodname></secondary></"
"indexterm> You can do the redirect using the <methodname>setLocation()</"
"methodname> method in <classname>Page</classname>. This needs to be done "
"before closing the session, as the UI or page are not available after that. "
"In the following example, we display a logout button, which closes the user "
"session."
msgstr ""
"当从 UI 中关闭 session 时, 你通常会希望将用户导向另一个 URL. "
"<indexterm><primary>redirection</primary></indexterm> "
"<indexterm><primary><methodname>setLocation()</methodname></primary></"
"indexterm> <indexterm><primary>Page</"
"primary><secondary><methodname>setLocation()</methodname></secondary></"
"indexterm> 你可以使用 <classname>Page</classname> 的 "
"<methodname>setLocation()</methodname> 方法来实现页面跳转. 这个跳转需要在关"
"闭 session 之前执行, 因为 session 关闭之后 UI 和 page 都将不可用. 下例中, 我"
"们显示一个 logout 按钮, 它将关闭用户 session."

#. Tag: primary
#: chapter-application.xml:1760
#, no-c-format
msgid "logout"
msgstr ""

#. Tag: programlisting
#: chapter-application.xml:1763
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        setContent(new Button(\"Logout\", event -> {// Java 8\n"
"            // Redirect this page immediately\n"
"            getPage().setLocation(\"/myapp/logout.html\");\n"
"            \n"
"            // Close the session\n"
"            getSession().close();\n"
"        }));\n"
"\n"
"        // Notice quickly if other UIs are closed\n"
"        setPollInterval(3000);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1765
#, no-c-format
msgid ""
"This is not enough. When a session is closed from one UI, any other UIs "
"attached to it are left hanging. When the client-side engine notices that a "
"UI and the session are gone on the server-side, it displays a \"Session "
"Expired\" message and, by default, reloads the UI when the message is "
"clicked. <indexterm> <primary>session</primary> <secondary>expiration</"
"secondary> </indexterm> <indexterm><primary>redirection</primary></"
"indexterm> <indexterm><primary>system messages</primary></indexterm> You can "
"customize the message and the redirect URL in the system messages, as "
"described in <xref linkend=\"application.errors.systemmessages\"/>."
msgstr ""
"这样还不够. 当从一个 UI 关闭 session 时, 与这个 session 关联的其他 UI 还会残"
"留在浏览器端. 当客户端引擎发现服务器端的 UI 和 session 消失之后, 它会显示一"
"个 \"Session Expired\" 消息, 而且, 当用户点击这个消息之后, 它会默认地重新装"
"载 UI. <indexterm> <primary>session</primary> <secondary>expiration</"
"secondary> </indexterm> <indexterm><primary>redirection</primary></"
"indexterm> <indexterm><primary>system messages</primary></indexterm> 你可以在"
"系统消息中定制这个消息内容, 以及点击消息之后的跳转 URL, 详情请参见 <xref "
"linkend=\"application.errors.systemmessages\"/>."

#. Tag: primary
#: chapter-application.xml:1785
#, no-c-format
msgid "<primary>heartbeat</primary>"
msgstr ""

#. Tag: secondary
#: chapter-application.xml:1786
#, no-c-format
msgid "<secondary>heartbeat</secondary>"
msgstr ""

#. Tag: primary
#: chapter-application.xml:1787
#, no-c-format
msgid "push"
msgstr ""

#. Tag: primary
#: chapter-application.xml:1788
#, no-c-format
msgid "server push"
msgstr ""

#. Tag: para
#: chapter-application.xml:1788
#, no-c-format
msgid ""
"The client-side engine notices the expiration when user interaction causes a "
"server request to be made or when the keep-alive heartbeat occurs. To make "
"the UIs detect the situation faster, you need to make the heart beat faster, "
"as was done in the example above. You can also use server push to close the "
"other UIs immediately, as is done in the following example. Access to the "
"UIs must be synchronized as described in <xref linkend=\"advanced.push\"/>."
msgstr ""
"当用户操作导致需要发起一次服务器请求, 或者当 UI 心跳发生时, 客户端引擎就会注"
"意到 session 超期. 为了让 UI 更快地发现 session 超期, 你需要让 UI 心跳的间隔"
"时间更快一些, 上面的例子就是这样做的. 你也可以使用服务器端 PUSH 来立即关闭其"
"他 UI 实例, 如下例所示. 对 UI 的访问必须使用同步方式, 详情请参见 <xref "
"linkend=\"advanced.push\"/>."

#. Tag: programlisting
#: chapter-application.xml:1800
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Push\n"
"public class MyPushyUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        setContent(new Button(\"Logout\", event -> {// Java 8\n"
"            for (UI ui: VaadinSession.getCurrent().getUIs())\n"
"                ui.access(() -> {\n"
"                    // Redirect from the page\n"
"                    ui.getPage().setLocation(\"/logout.html\");\n"
"                });\n"
"\n"
"            getSession().close();\n"
"        }));\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:1802
#, no-c-format
msgid ""
"In the above example, we assume that all UIs in the session have push "
"enabled and that they should be redirected; popups you might want to close "
"instead of redirecting. It is not necessary to call <methodname>close()</"
"methodname> for them individually, as we close the entire session afterwards."
msgstr ""
"在上例中, 我们假定 session 内的所有 UI 都激活了 PUSH 功能, 还假定它们都需要跳"
"转到其他地址; 对于弹出窗口, 通常你会希望关闭它们, 而不是跳转到其他地址. 没有"
"必要对它们分别调用 <methodname>close()</methodname> 方法, 因为我们在后面的代"
"码中关闭了整个 session."

#. Tag: title
#: chapter-application.xml:1852
#, no-c-format
msgid "Deploying an Application"
msgstr "发布应用程序"

#. Tag: para
#: chapter-application.xml:1854
#, no-c-format
msgid ""
"Vaadin applications are deployed as <emphasis>Java web applications</"
"emphasis>, which can contain a number of servlets, each of which can be a "
"Vaadin application or some other servlet, and static resources such as HTML "
"files. Such a web application is normally packaged as a WAR (Web application "
"ARchive) file, which can be deployed to a Java application server (or a "
"servlet container to be exact). A WAR file, which has the <filename>.war</"
"filename> extension, is a subtype of JAR (Java ARchive), and like a regular "
"JAR, is a ZIP-compressed file with a special content structure."
msgstr ""
"Vaadin 应用程序以 <emphasis>Java Web 应用程序</emphasis> 的形式发布, 其中可以"
"包含多个 Servlet, 各 Servlet 可以是一个 Vaadin 应用程序, 也可以是其他种类的 "
"Servlet, Web 应用程序中还可以包含静态资源, 比如 HTML 文件等. 这样的 Web 应用"
"程序通常打包为 WAR (Web application ARchive) 文件, WAR 可以被发布到 Java 应用"
"程序服务器(确切的说应该叫做 Servlet 容器). WAR 文件的扩展名为 <filename>."
"war</filename>, 是 JAR (Java ARchive) 文件的一种, 象通常的 JAR 文件一样, WAR "
"文件也是 ZIP 压缩文件, 但其中包含特殊的内容."

#. Tag: para
#: chapter-application.xml:1865
#, no-c-format
msgid ""
"For a detailed tutorial on how web applications are packaged, please refer "
"to any Java book that discusses Java Servlets."
msgstr "关于 Web 应用程序如何打包, 请参考关于 Java Servlet 的书籍."

#. Tag: para
#: chapter-application.xml:1870
#, no-c-format
msgid ""
"In the Java Servlet parlance, a \"web application\" means a collection of "
"Java servlets or portlets, JSP and static HTML pages, and various other "
"resources that form an application. Such a Java web application is typically "
"packaged as a WAR package for deployment. Server-side Vaadin UIs run as "
"servlets within such a Java web application. There exists also other kinds "
"of web applications. To avoid confusion with the general meaning of \"web "
"application\", we often refer to Java web applications with the slight "
"misnomer \"WAR\" in this book."
msgstr ""
"用 Java Servlet 的术语来说, 一个 \"Web 应用程序\" 指的是一组 Java Servlet 或 "
"portlet, JSP, 静态的 HTML 页面, 以及用于构成应用程序的各种其他资源. 这样的 "
"Java Web 应用程序通常打包为 WAR 包用于部署. Server 端 Vaadin UI 以 Servlet 的"
"方式运行在这样的 Java Web 应用程序之中. 当然也存在其他类型的 Web 应用程序. 为"
"了避免与通常所说的\"Web 应用程序\"混淆, 在本书中我们讨论 Java Web 应用程序"
"时, 一般使用 \"WAR\", 尽管用这个词并不十分准确."

#. Tag: title
#: chapter-application.xml:1884
#, no-c-format
msgid "Creating Deployable WAR in Eclipse"
msgstr "在 Eclipse 中创建发布用的 WAR 文件"

#. Tag: para
#: chapter-application.xml:1886
#, no-c-format
msgid ""
"To deploy an application to a web server, you need to create a WAR package. "
"Here we give the instructions for Eclipse."
msgstr ""
"要把应用程序发布到 Web 服务器上, 你首先需要创建 WAR 包. 以下给出在 Eclipse 中"
"的操作步骤."

#. Tag: para
#: chapter-application.xml:1893
#, no-c-format
msgid ""
"Select <menuchoice><guimenu>File</guimenu><guimenuitem>Export</guimenuitem></"
"menuchoice> and then <menuchoice><guimenu>Web</guimenu><guimenuitem>WAR "
"File</guimenuitem></menuchoice>. Or, right-click the project in the Project "
"Explorer and select <menuchoice><guimenu>Web</guimenu><guimenuitem>WAR File</"
"guimenuitem></menuchoice>."
msgstr ""
"选择菜单项 <menuchoice><guimenu>File</guimenu><guimenuitem>Export</"
"guimenuitem></menuchoice> 然后选择 <menuchoice><guimenu>Web</"
"guimenu><guimenuitem>WAR File</guimenuitem></menuchoice>. 或者, 在 Project "
"Explorer 中, 在工程上点击鼠标右键, 然后选择菜单项 <menuchoice><guimenu>Web</"
"guimenu><guimenuitem>WAR File</guimenuitem></menuchoice>."

#. Tag: para
#: chapter-application.xml:1904
#, no-c-format
msgid ""
"Select the <guilabel>Web project</guilabel> to export. Enter "
"<guilabel>Destination</guilabel> file name (<filename>.war</filename>)."
msgstr ""
"在 <guilabel>Web project</guilabel> 中选择需要导出的过程. 在 "
"<guilabel>Destination</guilabel> 中输入导出的目标文件名 (扩展名应该是 "
"<filename>.war</filename>)."

#. Tag: para
#: chapter-application.xml:1911
#, no-c-format
msgid ""
"Make any other settings in the dialog, and click <guibutton>Finish</"
"guibutton>."
msgstr "在对话框中输入其他设定, 然后点击 <guibutton>Finish</guibutton> 按钮."

#. Tag: title
#: chapter-application.xml:1920
#, no-c-format
msgid "Web Application Contents"
msgstr "Web 应用程序内容"

#. Tag: para
#: chapter-application.xml:1922
#, no-c-format
msgid ""
"The following files are required in a web application in order to run it."
msgstr "要运行一个 Web application, 其中需要包含以下文件."

#. Tag: title
#: chapter-application.xml:1928
#, no-c-format
msgid "Web Application Organization"
msgstr "Web 应用程序的内部组织"

#. Tag: term
#: chapter-application.xml:1931
#, no-c-format
msgid "<filename>WEB-INF/web.xml</filename> (optional with Servlet 3.0)"
msgstr ""
"<filename>WEB-INF/web.xml</filename> (对于 Servlet 3.0 来说, 这个文件是可选"
"的)"

#. Tag: para
#: chapter-application.xml:1935
#, no-c-format
msgid ""
"This is the web application descriptor that defines how the application is "
"organized, that is, what servlets and such it has. You can refer to any Java "
"book about the contents of this file. It is not needed if you define the "
"Vaadin servlet with the <literal>@WebServlet</literal> annotation in Servlet "
"API 3.0."
msgstr ""
"这是 Web 应用程序的描述文件, 其中定义了应用程序如何组织, 也就是说, 应用程序中"
"包含哪些 Servlet. 关于这个描述文件的内容, 请参考其他 Java 书籍. 如果你在 "
"Servlet API 3.0 环境中使用 <literal>@WebServlet</literal> 注解来定义 Vaadin "
"Servlet, 那么这个描述文件是不需要的."

#. Tag: filename
#: chapter-application.xml:1948
#, no-c-format
msgid "WEB-INF/lib/*.jar"
msgstr ""

#. Tag: para
#: chapter-application.xml:1953
#, no-c-format
msgid ""
"These are the Vaadin libraries and their dependencies. They can be found in "
"the installation package or as loaded by a dependency management system such "
"as Maven or Ivy."
msgstr ""
"这些文件是 Vaadin 库, 以及 Vaadin 库所依赖的其他库. 这些文件可以在安装包中得"
"到, 或者通过某种依赖管理系统(比如 Maven 或 Ivy)得到."

#. Tag: term
#: chapter-application.xml:1962
#, no-c-format
msgid "Your UI classes"
msgstr "你编写的 UI 类"

#. Tag: para
#: chapter-application.xml:1964
#, no-c-format
msgid ""
"You must include your UI classes either in a JAR file in <filename>WEB-INF/"
"lib</filename> or as classes in <filename>WEB-INF/classes</filename>"
msgstr ""
"你必须将你的 UI 类包含在 JAR 文件中, 放在 <filename>WEB-INF/lib</filename> 目"
"录下, 或者以 class 文件的形式放在 <filename>WEB-INF/classes</filename> 目录下"

#. Tag: term
#: chapter-application.xml:1975
#, no-c-format
msgid "Your own theme files (OPTIONAL)"
msgstr "你自己的 theme 文件(可选)"

#. Tag: para
#: chapter-application.xml:1977
#, no-c-format
msgid ""
"If your application uses a special theme (look and feel), you must include "
"it in <filename>VAADIN/themes/themename</filename> directory."
msgstr ""
"如果你的应用程序使用了特别的 theme (外观), 你必须将你的 theme 包含在 "
"<filename>VAADIN/themes/themename</filename> 目录下."

#. Tag: term
#: chapter-application.xml:1987
#, no-c-format
msgid "Widget sets (OPTIONAL)"
msgstr "Widget 群 (可选)"

#. Tag: para
#: chapter-application.xml:1989
#, no-c-format
msgid ""
"If your application uses a project-specific widget set, it must be compiled "
"in the <filename>VAADIN/widgetset/</filename> directory."
msgstr ""
"如果你的应用程序使用了独有的 widget 群, 它必须被编译后放在 <filename>VAADIN/"
"widgetset/</filename> 目录下."

#. Tag: title
#: chapter-application.xml:2000
#, no-c-format
msgid "Web Servlet Class"
msgstr "Web Servlet 类"

#. Tag: para
#: chapter-application.xml:2002
#, no-c-format
msgid ""
"When using the Servlet 3.0 API, you normally declare the Vaadin servlet "
"classes with the <literal>@WebServlet</literal> annotation. The Vaadin UI "
"associated with the servlet and other Vaadin-specific parameters are "
"declared with a separate <literal>@VaadinServletConfiguration</literal> "
"annotation."
msgstr ""
"使用 Servlet 3.0 API 时, 你通常可以使用 <literal>@WebServlet</literal> 注解来"
"定义 Vaadin Servlet 类. 与 Servlet 关联的 Vaadin UI 以及其他 Vaadin 相关参数"
"使用另外的 <literal>@VaadinServletConfiguration</literal> 注解来指定."

#. Tag: programlisting
#: chapter-application.xml:2010
#, no-c-format
msgid ""
"<?pocket-size 75% ?>@WebServlet(value = \"<emphasis role=\"bold\">/*</"
"emphasis>\",\n"
"            asyncSupported = true)\n"
"@VaadinServletConfiguration(\n"
"        productionMode = <emphasis role=\"bold\">false</emphasis>,\n"
"        ui = <emphasis role=\"bold\">MyProjectUI</emphasis>.class)\n"
"public class <emphasis role=\"bold\">MyProjectServlet</emphasis> extends "
"VaadinServlet {\n"
"}"
msgstr ""

#. Tag: para
#: chapter-application.xml:2012
#, no-c-format
msgid ""
"The Vaadin Plugin for Eclipse creates the servlet class as a static inner "
"class of the UI class. Normally, you may want to have it as a separate "
"regular class."
msgstr ""
"Vaadin Plugin for Eclipse 将 Servlet 类创建为 UI 类的静态 inner 类. 通常你可"
"能会希望 Servlet 类作为一个普通类存在."

#. Tag: para
#: chapter-application.xml:2018
#, no-c-format
msgid ""
"The <parameter>value</parameter> parameter is the URL pattern for mapping "
"request URLs to the servlet, as described in <xref linkend=\"application."
"environment.servlet-mapping\"/>. The <parameter>ui</parameter> parameter is "
"the UI class. Production mode is disabled by default, which enabled on-the-"
"fly theme compilation, debug window, and other such development features. "
"See the subsequent sections for details on the different servlet and Vaadin "
"configuration parameters."
msgstr ""
"其中的 <parameter>value</parameter> 参数是映射到这个 Servlet 上的 URL 模式, "
"详情请参见 <xref linkend=\"application.environment.servlet-mapping\"/>. "
"<parameter>ui</parameter> 参数是 UI 类. 生产模式默认是关闭的, 因此可以即时编"
"译 theme, 可以显示调试窗口, 其他各种开发期专有功能也都是激活的. 关于 Servlet "
"和 Vaadin 的其他配置参数, 请阅读后续各章节."

#. Tag: para
#: chapter-application.xml:2028
#, no-c-format
msgid ""
"You can also use a <filename>web.xml</filename> deployment descriptor in "
"Servlet 3.0 projects."
msgstr ""
"在 Servlet 3.0 工程中, 你也可以使用部署描述文件 <filename>web.xml</filename>."

#. Tag: title
#: chapter-application.xml:2035
#, no-c-format
msgid "Using a <filename>web.xml</filename> Deployment Descriptor"
msgstr "使用部署描述文件 <filename>web.xml</filename>"

#. Tag: para
#: chapter-application.xml:2037
#, no-c-format
msgid ""
"A deployment descriptor is an XML file with the name <filename>web.xml</"
"filename> in the <filename>WEB-INF</filename> sub-directory of a web "
"application. It is a standard component in Java EE describing how a web "
"application should be deployed. The descriptor is not required with Servlet "
"API 3.0, where you can also define servlets with the <classname>@WebServlet</"
"classname> annotation as decribed earlier, as web fragments, or "
"programmatically. You can use both a <filename>web.xml</filename> and "
"WebServlet in the same application. Settings in the <filename>web.xml</"
"filename> override the ones given in annotations."
msgstr ""
"部署描述文件是一种 XML 文件, 其文件名为 <filename>web.xml</filename>, 位于 "
"Web 应用程序的 <filename>WEB-INF</filename> 子目录下. 在 Java EE 中这个文件是"
"一个标准组件, 它定义了 Web 应用程序应该如何部署. 对于 Servlet API 3.0, 这个描"
"述文件不是必须的, 前面已经说过, 你可以使用 <classname>@WebServlet</"
"classname> 注解来定义 Servlet , 也可以使用 web fragment 来定义, 也可以使用程"
"序来定义. 在同一个应用程序中, 你可以同时使用 <filename>web.xml</filename> 和 "
"WebServlet. <filename>web.xml</filename> 文件中的设定将覆盖程序注解中的设定."

#. Tag: para
#: chapter-application.xml:2050
#, no-c-format
msgid ""
"The following example shows the basic contents of a deployment descriptor "
"for a Servlet 2.4 application. You simply specify the UI class with the "
"<parameter>UI</parameter> parameter for the <classname>com.vaadin.server."
"VaadinServlet</classname>. The servlet is then mapped to a URL path in a "
"standard way for Java Servlets."
msgstr ""
"下面的例子演示 Servlet 2.4 应用程序部署描述文件的基本内容. 这里只简单地通过 "
"<parameter>UI</parameter> 参数为 <classname>com.vaadin.server.VaadinServlet</"
"classname>指定 UI 类 . Servlet 通过 Java Servlet 的标准方式映射到 URL 路径上."

#. Tag: programlisting
#: chapter-application.xml:2058
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"
"&lt;web-app\n"
"  id=\"WebApp_ID\" version=\"2.4\"\n"
"  xmlns=\"http://java.sun.com/xml/ns/j2ee\" \n"
"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n"
"  xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee\n"
"     http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;\n"
"\n"
"  &lt;servlet&gt;\n"
"    &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/"
"servlet-name&gt;\n"
"    &lt;servlet-class&gt;\n"
"        com.vaadin.server.VaadinServlet\n"
"    &lt;/servlet-class&gt;\n"
"\n"
"    &lt;init-param&gt;\n"
"      &lt;param-name&gt;&ui;&lt;/param-name&gt;\n"
"      &lt;param-value&gt;<emphasis role=\"strong\">com.ex.myprj.MyUI</"
"emphasis>&lt;/param-value&gt;\n"
"    &lt;/init-param&gt;\n"
"\n"
"    &lt;!-- If not using the default widget set--&gt;\n"
"    &lt;init-param&gt;\n"
"      &lt;param-name&gt;widgetset&lt;/param-name&gt;\n"
"      &lt;param-value&gt;<emphasis role=\"strong\">com.ex.myprj.MyWidgetSet</"
"emphasis>&lt;/param-value&gt;\n"
"    &lt;/init-param&gt;\n"
"  &lt;/servlet&gt;\n"
"\n"
"  &lt;servlet-mapping&gt;\n"
"    &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/"
"servlet-name&gt;\n"
"    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n"
"  &lt;/servlet-mapping&gt;\n"
"&lt;/web-app&gt;"
msgstr ""

#. Tag: para
#: chapter-application.xml:2060
#, no-c-format
msgid ""
"The descriptor defines a servlet with the name <filename>myservlet</"
"filename>. The servlet class, <classname>com.vaadin.server.VaadinServlet</"
"classname>, is provided by Vaadin framework and is normally the same for all "
"Vaadin projects. For some purposes, you may need to use a custom servlet "
"class that extends the <classname>VaadinServlet</classname>. The class name "
"must include the full package path."
msgstr ""
"描述文件定义了一个 Servlet, 名为 <filename>myservlet</filename>. Servlet 类, "
"<classname>com.vaadin.server.VaadinServlet</classname>, 是 Vaadin 框架提供"
"的, 对所有的 Vaadin 工程来说, 通常都使用同样的 Servlet 类. 为了某些特别目的, "
"你可能会需要使用继承自 <classname>VaadinServlet</classname> 的自定义 Servlet "
"类. 注意, 类名需要包含完整的包路径."

#. Tag: title
#: chapter-application.xml:2071
#, no-c-format
msgid "Servlet API Version"
msgstr "Servlet API 版本"

#. Tag: para
#: chapter-application.xml:2073
#, no-c-format
msgid ""
"The descriptor example given above was for Servlet 2.4. For a later version, "
"such as Servlet 3.0, you should use:"
msgstr ""
"上面的描述文件示例是适用于 Servlet 2.4 环境的. 对于比较新的版本, 比如 "
"Servlet 3.0, 你应该使用:"

#. Tag: programlisting
#: chapter-application.xml:2078
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;web-app\n"
"  id=\"WebApp_ID\" version=\"<emphasis role=\"bold\">3.0</emphasis>\"\n"
"  xmlns=\"http://java.sun.com/xml/ns/j2ee\" \n"
"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n"
"  xsi:schemaLocation=\"<emphasis role=\"bold\">http://java.sun.com/xml/ns/"
"javaee\n"
"      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd</emphasis>\"&gt;"
msgstr ""

#. Tag: para
#: chapter-application.xml:2080
#, no-c-format
msgid "Servlet 3.0 support is useful for at least server push."
msgstr "至少对于服务器 PUSH 功能来说, Servlet 3.0 是需要的."

#. Tag: title
#: chapter-application.xml:2086
#, no-c-format
msgid "Widget Set"
msgstr "Widget 群"

#. Tag: para
#: chapter-application.xml:2088
#, no-c-format
msgid ""
"If the UI uses add-on components or custom widgets, it needs a custom widget "
"set, which can be specified with the <parameter>widgetset</parameter> "
"parameter for the servlet. Alternatively, you can defined it with the "
"<classname>@Widgetset</classname> annotation for the UI class. The parameter "
"is a class name with the same path but without the <filename>.gwt.xml</"
"filename> extension as the widget set definition file. If the parameter is "
"not given, the <classname>com.vaadin.DefaultWidgetSet</classname> is used, "
"which contains all the widgets for the built-in Vaadin components."
msgstr ""
"如果 UI 使用了插件组件, 或使用了定制的 widget, 它就需要定制的 widget 群, 定制"
"的 widget 群可以通过 Servlet 的 <parameter>widgetset</parameter> 参数来指定. "
"或者, 你也可以对 UI 类使用 <classname>@Widgetset</classname> 注解来指定它. 这"
"个设定的参数是一个类名, 这个类名与 widget 群定义文件的路径相同, 但不带 "
"<filename>.gwt.xml</filename> 扩展名. 如果这个参数没有指定, 那么默认会使用 "
"<classname>com.vaadin.DefaultWidgetSet</classname> , 这个类中包含内建的 "
"Vaadin 组件所用到的所有 widget."

#. Tag: para
#: chapter-application.xml:2101
#, no-c-format
msgid ""
"Unless using the default widget set (which is included in the "
"<filename>vaadin-client-compiled</filename> JAR), the widget set must be "
"compiled, as described in <xref linkend=\"addons\"/> or <xref linkend="
"\"clientside.compiling\"/>, and properly deployed with the application."
msgstr ""
"除非使用默认的 widget 群 (包含在 <filename>vaadin-client-compiled</filename> "
"JAR 文件中), 否则 widget 群必须编译, 详情请参见 <xref linkend=\"addons\"/> "
"or <xref linkend=\"clientside.compiling\"/>, 还需要与应用程序一起正确地发布到"
"服务器上."

#. Tag: title
#: chapter-application.xml:2112
#, no-c-format
msgid "Servlet Mapping with URL Patterns"
msgstr "Servlet 与 URL 模式的映射"

#. Tag: para
#: chapter-application.xml:2114
#, no-c-format
msgid ""
"The servlet needs to be mapped to an URL path, which requests it is to "
"handle."
msgstr ""
"Servlet 需要映射到 URL 路径上, 这个 URL 路径就成为 Servlet 所处理的请求的路"
"径."

#. Tag: para
#: chapter-application.xml:2119
#, no-c-format
msgid ""
"With <classname>@WebServlet</classname> annotation for the servlet class:"
msgstr ""
"对 Servlet 类使用 <classname>@WebServlet</classname> 注解来指定映射 URL 路径:"

#. Tag: programlisting
#: chapter-application.xml:2123
#, no-c-format
msgid ""
"<?pocket-size 75% ?>@WebServlet(value = \"<emphasis role=\"bold\">/*</"
"emphasis>\", asyncSupported = true)"
msgstr ""

#. Tag: para
#: chapter-application.xml:2125 chapter-application.xml:2164
#: chapter-application.xml:2243 chapter-application.xml:2275
#: chapter-application.xml:2294 chapter-application.xml:2323
#: chapter-application.xml:2348 chapter-application.xml:2371
#, no-c-format
msgid "In a <filename>web.xml</filename>:"
msgstr "在 <filename>web.xml</filename> 文件中设置如下:"

#. Tag: programlisting
#: chapter-application.xml:2129
#, no-c-format
msgid ""
"<?pocket-size 75% ?>  &lt;servlet-mapping&gt;\n"
"    &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/"
"servlet-name&gt;\n"
"    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n"
"  &lt;/servlet-mapping&gt;"
msgstr ""

#. Tag: para
#: chapter-application.xml:2131
#, no-c-format
msgid ""
"The URL pattern is defined in the above examples as <literal>/*</literal>. "
"This matches any URL under the project context. We defined above the project "
"context as <literal>myproject</literal> so the URL for the page of the &ui; "
"will be <uri>http://localhost:8080/myproject/</uri>."
msgstr ""
"上面的示例中, URL 模式被设置为 <literal>/*</literal>. 这个 URL 模式将与工程 "
"context 下的全部 URL 相匹配. 上面的例子中我们将工程 context 设定为 "
"<literal>myproject</literal>, 因此 &ui; 页面的 URL 将是 <uri>http://"
"localhost:8080/myproject/</uri>."

#. Tag: title
#: chapter-application.xml:2140
#, no-c-format
msgid "Mapping Sub-Paths"
msgstr "映射到子路径上"

#. Tag: para
#: chapter-application.xml:2142
#, no-c-format
msgid ""
"If an application has multiple &ui;s or servlets, they have to be given "
"different paths in the URL, matched by a different URL pattern. Also, you "
"may need to have statically served content under some path. Having an URL "
"pattern <literal>/myui/*</literal> would match a URL such as <uri>http://"
"localhost:8080/myproject/myui/</uri>. Notice that the slash and the asterisk "
"<emphasis>must</emphasis> be included at the end of the pattern. In such "
"case, you also need to map URLs with <literal>/VAADIN/*</literal> to a "
"servlet (unless you are serving it statically as noted below)."
msgstr ""
"如果应用程序有多个 &ui;, 或多个 Servlet, 它们必须对应到 URL 的不同路径上, 匹"
"配不同的 URL 模式. 而且, 你可能需要使用某些路径对外提供静态内容. 使用 "
"<literal>/myui/*</literal> 这样的 URL 模式, 将匹配到 <uri>http://"
"localhost:8080/myproject/myui/</uri> 这样的 URL. 注意在 URL 模式的末尾"
"<emphasis>必须</emphasis>包含斜线和星号. 这时, 你还需要将 <literal>/VAADIN/"
"*</literal> 这样的 URL 映射到 Servlet 上 (除非你用静态的方式为这个 URL 提供服"
"务, 详情参见后面的章节)."

#. Tag: para
#: chapter-application.xml:2156
#, no-c-format
msgid ""
"With a <classname>@WebServlet</classname> annotation for a servlet class, "
"you can define multiple mappings as a list enclosed in curly braces as "
"follows:"
msgstr ""
"对 Servlet 类使用 <classname>@WebServlet</classname> 注解时, 你可以用列表的形"
"式指定多个 URL 映射, 列表使用大括号括起, 示例如下:"

#. Tag: programlisting
#: chapter-application.xml:2162
#, no-c-format
msgid ""
"@WebServlet(value = {\"<emphasis role=\"strong\">/myui/*</emphasis>\", \"/"
"VAADIN/*\"},\n"
"            asyncSupported = true)"
msgstr ""

#. Tag: programlisting
#: chapter-application.xml:2168
#, no-c-format
msgid ""
"...\n"
"    &lt;servlet-mapping&gt;\n"
"        &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</"
"emphasis>&lt;/servlet-name&gt;\n"
"        &lt;url-pattern&gt;<emphasis role=\"strong\">/myui/*</emphasis>&lt;/"
"url-pattern&gt;\n"
"    &lt;/servlet-mapping&gt;\n"
"\n"
"    &lt;servlet-mapping&gt;\n"
"        &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</"
"emphasis>&lt;/servlet-name&gt;\n"
"        &lt;url-pattern&gt;/VAADIN/*&lt;/url-pattern&gt;\n"
"    &lt;/servlet-mapping&gt;"
msgstr ""

#. Tag: para
#: chapter-application.xml:2170
#, no-c-format
msgid ""
"If you have multiple servlets, you should specify only one <literal>/VAADIN/"
"*</literal> mapping. It does not matter which servlet you map the pattern "
"to, as long as it is a Vaadin servlet."
msgstr ""
"如果你有多个 servlet, 你只能指定一个 <literal>/VAADIN/*</literal> 映射. 只要"
"你的 Servlet 是 Vaadin Servlet, 那么你将这个 URL 路径映射到哪个 Servlet 上是"
"无所谓的."

#. Tag: para
#: chapter-application.xml:2176
#, no-c-format
msgid ""
"You do not have to provide the above <literal>/VAADIN/*</literal> mapping if "
"you serve both the widget sets and (custom and default) themes statically in "
"the <filename>/VAADIN</filename> directory in the web application. The "
"mapping simply allows serving them dynamically from the Vaadin JAR. Serving "
"them statically is recommended for production environments as it is faster. "
"If you serve the content from within the same web application, you may not "
"have the root pattern <literal>/*</literal> for the Vaadin servlet, as then "
"all the requests would be mapped to the servlet."
msgstr ""
"如果你的 widget 群和 theme (无论是默认的还是定制的), 都以 Web 应用程序的 "
"<filename>/VAADIN</filename> 目录下的静态内容的方式向外提供, 那么你就不必指定"
"上面说的 <literal>/VAADIN/*</literal> 路径映射. 这个映射只是为了从 Vaadin "
"JAR 中动态的向外提供这些内容. 在生产环境下, 推荐以静态文件的方式向外提供这些"
"内容, 因为这样速度更快. 如果你在同一个应用程序内向外提供这些内容的话, 你不应"
"该将根路径 <literal>/*</literal> 映射到 Vaadin Servlet 上, 因为这样会将所有的"
"请求都映射给 Servlet."

#. Tag: title
#: chapter-application.xml:2191
#, no-c-format
msgid "Other Servlet Configuration Parameters"
msgstr "Servlet 的其他配置参数"

#. Tag: para
#: chapter-application.xml:2193
#, no-c-format
msgid ""
"The servlet class or deployment descriptor can have many parameters and "
"options that control the execution of a servlet. You can find complete "
"documentation of the basic servlet parameters in the appropriate <link xlink:"
"href=\"http://wiki.apache.org/tomcat/Specifications\">Java Servlet "
"Specification</link>. <classname>@VaadinServletConfiguration</classname> "
"accepts a number of special parameters, as described below."
msgstr ""
"Servlet 类, 或者部署描述文件, 可以使用很多参数来控制 Servlet 的运行. 关于 "
"Servlet 参数的完整文档, 请参阅 <link xlink:href=\"http://wiki.apache.org/"
"tomcat/Specifications\">Java Servlet 规范</link>. "
"<classname>@VaadinServletConfiguration</classname> 则使用一些特有的参数, 详情"
"见下文."

#. Tag: para
#: chapter-application.xml:2203
#, no-c-format
msgid ""
"In a <filename>web.xml</filename>, you can set most parameters either as a "
"<literal>&lt;context-param&gt;</literal> for the entire web application, in "
"which case they apply to all Vaadin servlets, or as an <literal>&lt;init-"
"param&gt;</literal> for an individual servlet. If both are defined, servlet "
"parameters override context parameters."
msgstr ""
"在 <filename>web.xml</filename> 中, 大多数参数可以通过两种方式设定, 1,  "
"<literal>&lt;context-param&gt;</literal> 参数应用于整个 Web 应用程序, 因此会"
"对所有的 Vaadin Servlet 有效, 2, <literal>&lt;init-param&gt;</literal> 参数, "
"只是用于单个 Servlet. 如果以上两种参数都有指定, 那么 Servlet 参数将覆盖 "
"context 参数."

#. Tag: title
#: chapter-application.xml:2212
#, no-c-format
msgid "Production Mode"
msgstr "生产模式"

#. Tag: para
#: chapter-application.xml:2214
#, no-c-format
msgid ""
"By default, Vaadin applications run in <emphasis>debug mode</emphasis> (or "
"<emphasis>development mode</emphasis>), which should be used during "
"development. This enables various debugging features. For production use, "
"you should have the <literal>productionMode=true</literal> setting in the "
"<classname>@VaadinServletConfiguration</classname>, or in <filename>web.xml</"
"filename>:"
msgstr ""
"Vaadin 应用程序默认运行在 <emphasis>调试模式</emphasis> 下 (或者叫 <emphasis>"
"开发模式</emphasis>), 这种模式适用于应用程序的开发阶段. 它打开了各种调试功"
"能. 对于生产环境, 你应该在 <classname>@VaadinServletConfiguration</"
"classname> 中设置 <literal>productionMode=true</literal>, 或者在 "
"<filename>web.xml</filename> 中设置如下:"

#. Tag: programlisting
#: chapter-application.xml:2224
#, no-c-format
msgid ""
"<![CDATA[<context-param>\n"
"  <param-name>productionMode</param-name>\n"
"  <param-value>true</param-value>\n"
"  <description>Vaadin production mode</description>\n"
"</context-param>]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:2226
#, no-c-format
msgid ""
"The parameter and the debug and production modes are described in more "
"detail in <xref linkend=\"advanced.debug\"/>."
msgstr ""
"这个设置参数, 以及调试模式和生产模式的详细信息, 请参见 <xref linkend="
"\"advanced.debug\"/>."

#. Tag: title
#: chapter-application.xml:2233
#, no-c-format
msgid "Custom UI Provider"
msgstr "定制的 UI Provider"

#. Tag: para
#: chapter-application.xml:2235
#, no-c-format
msgid ""
"Vaadin normally uses the <classname>DefaultUIProvider</classname> for "
"creating <classname>UI</classname> class instances. If you need to use a "
"custom UI provider, you can define its class with the <parameter>UIProvider</"
"parameter> parameter. The provider is registered in the "
"<classname>VaadinSession</classname>."
msgstr ""
"Vaadin 通常使用 <classname>DefaultUIProvider</classname> 来创建 "
"<classname>UI</classname> 类的实例. 如果你需要使用定制的 UI Provider, 你可以"
"使用 <parameter>UIProvider</parameter> 参数来配置 UI Provider 类. UI "
"Provider 类将被注册到 <classname>VaadinSession</classname> 中."

#. Tag: programlisting
#: chapter-application.xml:2247
#, no-c-format
msgid ""
"&lt;servlet&gt;\n"
"    ...\n"
"    &lt;init-param&gt;\n"
"      &lt;param-name&gt;UIProvider&lt;/param-name&gt;\n"
"      &lt;param-value&gt;<emphasis role=\"bold\">com.ex.my.MyUIProvider</"
"emphasis>&lt;/param-value&gt;\n"
"    &lt;/init-param&gt;"
msgstr ""

#. Tag: para
#: chapter-application.xml:2249
#, no-c-format
msgid ""
"The parameter is logically associated with a particular servlet, but can be "
"defined in the context as well."
msgstr "这个参数通常与特定的 Servlet 相关联, 但也可以在 context 范围内指定."

#. Tag: title
#: chapter-application.xml:2256
#, no-c-format
msgid "UI Heartbeat"
msgstr "UI 心跳"

#. Tag: para
#: chapter-application.xml:2258
#, no-c-format
msgid ""
"Vaadin follows UIs using a heartbeat, as explained in <xref linkend="
"\"application.lifecycle.ui-expiration\"/>. If the user closes the browser "
"window of a Vaadin application or navigates to another page, the Client-Side "
"Engine running in the page stops sending heartbeat to the server, and the "
"server eventually cleans up the <classname>UI</classname> instance."
msgstr ""
"Vaadin 使用心跳来追踪 UI, 详情请参见 <xref linkend=\"application.lifecycle."
"ui-expiration\"/>. 如果用户关闭了 Vaadin 应用程序的浏览器窗口, 或者跳转到了其"
"他的页面, 那么页面中运行的客户端引擎将停止向服务器发送心跳请求, 服务器最终将"
"清除 <classname>UI</classname> 实例."

#. Tag: para
#: chapter-application.xml:2267
#, no-c-format
msgid ""
"The interval of the heartbeat requests can be specified in seconds with the "
"<parameter>heartbeatInterval</parameter> parameter either as a context "
"parameter for the entire web application or an init parameter for the "
"individual servlet. The default value is 300 seconds (5 minutes)."
msgstr ""
"心跳请求的间隔时间可以通过 <parameter>heartbeatInterval</parameter> 参数指"
"定, 单位为秒, 这个参数可以作为 context 参数对整个 Web 应用程序全局设置, 也可"
"以作为 init 参数对单个 Servlet 进行设置. 默认值是 300 妙 (5 分钟)."

#. Tag: programlisting
#: chapter-application.xml:2279
#, no-c-format
msgid ""
"<![CDATA[<context-param>\n"
"  <param-name>heartbeatInterval</param-name>\n"
"  <param-value>300</param-value>\n"
"</context-param>]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:2283
#, no-c-format
msgid "Session Timeout After User Inactivity"
msgstr "用户停止操作后的 Session 超时"

#. Tag: para
#: chapter-application.xml:2285
#, no-c-format
msgid ""
"In normal servlet operation, the session timeout defines the allowed time of "
"inactivity after which the server should clean up the session. The "
"inactivity is measured from the last server request. Different servlet "
"containers use varying defaults for timeouts, such as 30 minutes for Apache "
"Tomcat. You can set the timeout under <literal>&lt;web-app&gt;</literal> "
"with:"
msgstr ""
"在通常的 Servlet 操作中, Session 超时时间定义了 Session 不再活动时, 服务器清"
"除 Session 之前应该等待的时间. Session 不再活动是从最后一次向服务器发送请求开"
"始计算的. 不同的 Servlet 容器使用不同的超时时间默认值, 比如 Apache Tomcat 的"
"默认超时时间是 30 分钟. 你可以在 <literal>&lt;web-app&gt;</literal> 之下设置"
"超时时间:"

#. Tag: primary
#: chapter-application.xml:2298
#, no-c-format
msgid "session-timeout"
msgstr ""

#. Tag: programlisting
#: chapter-application.xml:2300
#, no-c-format
msgid ""
"<![CDATA[<session-config>\n"
"    <session-timeout>30</session-timeout>\n"
"</session-config>]]>"
msgstr ""

#. Tag: primary
#: chapter-application.xml:2303
#, no-c-format
msgid "Out of Sync"
msgstr ""

#. Tag: para
#: chapter-application.xml:2303
#, no-c-format
msgid ""
"The session timeout should be longer than the heartbeat interval or "
"otherwise sessions are closed before the heartbeat can keep them alive. As "
"the session expiration leaves the UIs in a state where they assume that the "
"session still exists, this would cause an Out Of Sync error notification in "
"the browser."
msgstr ""
"Session 超时时间的设定应该比心跳间隔时间长, 否则心跳请求还来不及保持 Session "
"激活, Session 就已经被关闭了. 由于 Session 超期时, UI 仍会假定 Session 继续存"
"在, 因此在浏览器中会出现同步失败的错误通知消息."

#. Tag: para
#: chapter-application.xml:2314
#, no-c-format
msgid ""
"However, having a shorter heartbeat interval than the session timeout, which "
"is the normal case, prevents the sessions from expiring. If the "
"<parameter>closeIdleSessions</parameter> parameter for the servlet is "
"enabled (disabled by default), Vaadin closes the UIs and the session after "
"the time specified in the <parameter>session-timeout</parameter> parameter "
"expires after the last non-heartbeat request."
msgstr ""
"但是, 通常情况下, 如果心跳间隔比 Session 超时时间短, 会使得 Session 永远不过"
"期. 如果 Servlet 的 <parameter>closeIdleSessions</parameter> 参数被启用(默认"
"为禁用), 最后一次非心跳请求之后, 如果经过了 <parameter>session-timeout</"
"parameter> 参数指定的时间, Vaadin 将关闭 UI 和 Session."

#. Tag: programlisting
#: chapter-application.xml:2327
#, no-c-format
msgid ""
"&lt;servlet&gt;\n"
"    ...\n"
"    &lt;init-param&gt;\n"
"      &lt;param-name&gt;closeIdleSessions&lt;/param-name&gt;\n"
"      &lt;param-value&gt;true&lt;/param-value&gt;\n"
"    &lt;/init-param&gt;"
msgstr ""

#. Tag: title
#: chapter-application.xml:2332
#, no-c-format
msgid "Push Mode"
msgstr "PUSH 模式"

#. Tag: para
#: chapter-application.xml:2334
#, no-c-format
msgid ""
"You can enable server push, as described in <xref linkend=\"advanced.push\"/"
">, for a UI either with a <classname>@Push</classname> annotation for the UI "
"or in the descriptor. The push mode is defined with a <parameter>pushmode</"
"parameter> parameter. The <literal>automatic</literal> mode pushes changes "
"to the browser automatically after <emphasis>access()</emphasis> finishes. "
"With <literal>manual</literal> mode, you need to do the push explicitly with "
"<methodname>push()</methodname>. If you use a Servlet 3.0 compatible server, "
"you also want to enable asynchronous processing with the <literal>async-"
"supported</literal> parameter."
msgstr ""
"对于一个 UI, 你可以打开服务器 PUSH 功能, 方法是对 UI 类使用 "
"<classname>@Push</classname> 注解, 或在部署描述文件中配置, 详情请参见 <xref "
"linkend=\"advanced.push\"/>. PUSH 模式由 <parameter>pushmode</parameter> 参数"
"定义. <literal>automatic</literal> 模式会在 <emphasis>access()</emphasis> 结"
"束之后, 将变化信息自动推送到浏览器端. 使用 <literal>manual</literal> 模式, 你"
"需要使用 <methodname>push()</methodname> 方法自行显式地进行推送. 如果你使用兼"
"容 Servlet 3.0 的服务器, 你可能会希望使用<literal>async-supported</literal> "
"参数允许异步处理."

#. Tag: programlisting
#: chapter-application.xml:2352
#, no-c-format
msgid ""
"&lt;servlet&gt;\n"
"  ...\n"
"  &lt;init-param&gt;\n"
"    &lt;param-name&gt;pushmode&lt;/param-name&gt;\n"
"    &lt;param-value&gt;<emphasis role=\"bold\">automatic</emphasis>&lt;/"
"param-value&gt;\n"
"  &lt;/init-param&gt;\n"
"  &lt;async-supported&gt;<emphasis role=\"bold\">true</emphasis>&lt;/async-"
"supported&gt;"
msgstr ""

#. Tag: title
#: chapter-application.xml:2357
#, no-c-format
msgid "Cross-Site Request Forgery Prevention"
msgstr "防止跨站请求伪装"

#. Tag: para
#: chapter-application.xml:2359
#, no-c-format
msgid ""
"Vaadin uses a protection mechanism to prevent malicious cross-site request "
"forgery (XSRF or CSRF), also called one-click attacks or session riding, "
"which is a security exploit for executing unauthorized commands in a web "
"server. This protection is normally enabled. However, it prevents some forms "
"of testing of Vaadin applications, such as with JMeter. In such cases, you "
"can disable the protection by setting the <parameter>disable-xsrf-"
"protection</parameter> parameter to <literal>true</literal>."
msgstr ""
"Vaadin 使用一种保护机制来防止恶意的跨站请求伪装 (cross-site request forgery, "
"简称 XSRF 或 CSRF), 也叫 one-click 攻击, 或者叫 session riding, 这是一种安全"
"漏洞, 可被用来在Web 服务器上执行未授权的命令. Vaadin 的保护机制默认是启用的. "
"但是它同时也阻止了 Vaadin 应用程序的一些测试方法, 比如使用 JMeter. 这种情况"
"下, 你可以禁用这个保护机制, 方法是将 <parameter>disable-xsrf-protection</"
"parameter> 参数设置为 <literal>true</literal>."

#. Tag: programlisting
#: chapter-application.xml:2375
#, no-c-format
msgid ""
"<![CDATA[<context-param>\n"
"  <param-name>disable-xsrf-protection</param-name>\n"
"  <param-value>true</param-value>\n"
"</context-param>]]>"
msgstr ""

#. Tag: title
#: chapter-application.xml:2380
#, no-c-format
msgid "Deployment Configuration"
msgstr "发布配置"

#. Tag: para
#: chapter-application.xml:2382
#, no-c-format
msgid ""
"The Vaadin-specific parameters defined in the deployment configuration are "
"available from the <classname>DeploymentConfiguration</classname> object "
"managed by the <classname>VaadinSession</classname>."
msgstr ""
"部署配置中的 Vaadin 专有参数, 可以通过 <classname>VaadinSession</classname> "
"管理的 <classname>DeploymentConfiguration</classname> 对象得到."

#. Tag: programlisting
#: chapter-application.xml:2388
#, no-c-format
msgid ""
"<![CDATA[DeploymentConfiguration conf =\n"
"        getSession().getConfiguration();\n"
"\n"
"// Heartbeat interval in seconds\n"
"int heartbeatInterval = conf.getHeartbeatInterval();]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:2390
#, no-c-format
msgid ""
"Parameters defined in the Java Servlet definition, such as the session "
"timeout, are available from the low-level <classname>HttpSession</classname> "
"or <classname>PortletSession</classname> object, which are wrapped in a "
"<classname>WrappedSession</classname> in Vaadin. You can access the low-"
"level session wrapper with <methodname>getSession()</methodname> of the "
"<classname>VaadinSession</classname>."
msgstr ""
"Java Servlet 定义中指定的参数, 比如 Session 超时时间, 可以通过低阶的 "
"<classname>HttpSession</classname> 或 <classname>PortletSession</classname> "
"对象得到, 这些对象被包装在 Vaadin 的 <classname>WrappedSession</classname> "
"中. 要得到这个包装对象, 你可以使用 <classname>VaadinSession</classname> 的 "
"<methodname>getSession()</methodname> 方法."

#. Tag: programlisting
#: chapter-application.xml:2400
#, no-c-format
msgid ""
"<![CDATA[WrappedSession session = getSession().getSession();\n"
"int sessionTimeout = session.getMaxInactiveInterval();]]>"
msgstr ""

#. Tag: para
#: chapter-application.xml:2402
#, no-c-format
msgid ""
"You can also access other <classname>HttpSession</classname> and "
"<classname>PortletSession</classname> session properties through the "
"interface, such as set and read session attributes that are shared by all "
"servlets belonging to a particular servlet or portlet session."
msgstr ""
"你也可以通过 <classname>HttpSession</classname> 和 "
"<classname>PortletSession</classname> 接口访问 Session 的其他属性, 比如设置和"
"读取 session attribute, 某个 Servlet Session 或 Portlet Session 下属的所有 "
"Servlet, 可以通过这些 attribute 共享数据."
