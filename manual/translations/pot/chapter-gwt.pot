# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-05-20 12:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: chapter-gwt.xml:11
#, no-c-format
msgid "Integrating with the Server-Side"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:14
#, no-c-format
msgid "Google Web Toolkit"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:15
#, no-c-format
msgid "<secondary>widgets</secondary>"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:17
#, no-c-format
msgid "<primary>widgets</primary>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:19
#, no-c-format
msgid "This chapter describes how you can integrate client-side widgets or JavaScript components with a server-side component. The client-side implementations of all standard server-side components in Vaadin use the same client-side interfaces and patterns."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:27
#, no-c-format
msgid "Overview"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:29
#, no-c-format
msgid "Vaadin components consist of two parts: a server-side and a client-side component. The latter are also called <emphasis>widgets</emphasis> in Google Web Toolkit (GWT) parlance. A Vaadin application uses the API of the server-side component, which is rendered as a client-side widget in the browser. As on the server-side, the client-side widgets form a hierarchy of layout widgets and regular widgets as the leaves."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:39
#, no-c-format
msgid "Integration of Client-Side Widgets"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:50
#, no-c-format
msgid "The communication between a client-side widget and a server-side component is managed with a <emphasis>connector</emphasis> that handles syncronizing the widget state and events to and from the server-side."
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:55
#, no-c-format
msgid "connector"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:58
#, no-c-format
msgid "When rendering the user interface, a client-side connector and a widget are created for each server-side component. The mapping from a component to a connector is defined in the connector class with a <literal>@Connect</literal> annotation, and the widget is created by the connector class."
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:64
#, no-c-format
msgid "@Connect"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:67
#, no-c-format
msgid "The state of a server-side component is synchronized automatically to the client-side widget using a <emphasis>shared state</emphasis> object. A shared state object implements the <interfacename>ComponentState</interfacename> interface and it is used both in the server-side and the client-side component. On the client-side, a connector always has access to its state instance, as well to the state of its parent component state and the states of its children."
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:76
#, no-c-format
msgid "state object"
msgstr ""

#. Tag: classname
#: chapter-gwt.xml:77
#, no-c-format
msgid "ComponentState"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:80
#, no-c-format
msgid "The state sharing assumes that state is defined with standard Java types, such as primitive and boxed primitive types, <classname>String</classname>, arrays, and certain collections (<classname>List</classname>, <classname>Set</classname>, and <classname>Map</classname>) of the supported types. Also the Vaadin <classname>Connector</classname> and some special internal types can be shared."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:89
#, no-c-format
msgid "In addition to state, both server- and client-side can make remote procedure calls (RPC) to the other side. RPC is used foremost for event notifications. For example, when a client-side connector of a button receives a click, it sends the event to the server-side using RPC."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:97
#, no-c-format
msgid "Project Structure"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:99
#, no-c-format
msgid "Widget set compilation, as described in <xref linkend=\"clientside.module\"/>, requires using a special project structure, where the client-side classes are located under a <filename>client</filename> package under the package of the module descriptor. Any static resources, such as stylesheets and images, should be located under a <filename>public</filename> folder (not Java package). The source for the server-side component may be located anywhere, except not in the client-side package."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:110
#, no-c-format
msgid "The basic project structure is illustrated in <xref linkend=\"figure.gwt.overview.project\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:115
#, no-c-format
msgid "Basic Widget Integration Project Structure"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:126
#, no-c-format
msgid "The Eclipse wizard, described in <xref linkend=\"gwt.eclipse\"/>, creates a widget integration skeleton with the above structure."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:133
#, no-c-format
msgid "Integrating JavaScript Components"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:135
#, no-c-format
msgid "In addition to the GWT widget integration, Vaadin offers a simplified way to integrate pure JavaScript components. The JavaScript connector code is published from the server-side. As the JavaScript integration does not involve GWT programming, no widget set compilation is needed."
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:141
#, no-c-format
msgid "JavaScript"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:147
#, no-c-format
msgid "Starting It Simple With Eclipse"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:150
#, no-c-format
msgid "Eclipse"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:151
#, no-c-format
msgid "widget development"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:154
#, no-c-format
msgid "Let us first take the easy way and create a simple component with Eclipse. While you can develop new widgets with any IDE or even without, you may find Eclipse and the Vaadin Plugin for it useful, as it automates all the basic routines of widget development, most importantly the creation of new widgets."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:162
#, no-c-format
msgid "Creating a Widget"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:166
#, no-c-format
msgid "Right-click the project in the Project Explorer and select <menuchoice><guimenu>New</guimenu><guimenuitem>Other...</guimenuitem></menuchoice>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:172
#, no-c-format
msgid "In the wizard selection, select <menuchoice><guimenu>Vaadin</guimenu><guimenuitem>Vaadin Widget</guimenuitem></menuchoice> and click <guibutton>Next</guibutton>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:191
#, no-c-format
msgid "In the <guilabel>New Component Wizard</guilabel>, make the following settings."
msgstr ""

#. Tag: guilabel
#: chapter-gwt.xml:206
#, no-c-format
msgid "Source folder"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:208
#, no-c-format
msgid "The root folder of the entire source tree. The default value is the default source tree of your project, and you should normally leave it unchanged unless you have a different project structure."
msgstr ""

#. Tag: guilabel
#: chapter-gwt.xml:217
#, no-c-format
msgid "Package"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:219
#, no-c-format
msgid "The parent package under which the new server-side component should be created. If the project does not already have a widget set, one is created under this package in the <package>widgetset</package> subpackage. The subpackage will contain the <filename>.gwt.xml</filename> descriptor that defines the widget set and the new widget stub under the <package>widgetset.client</package> subpackage."
msgstr ""

#. Tag: guilabel
#: chapter-gwt.xml:232
#, no-c-format
msgid "Name"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:234
#, no-c-format
msgid "The class name of the new <emphasis>server-side component</emphasis>. The name of the client-side widget stub will be the same but with \"-<classname>Widget</classname>\" suffix, for example, <classname>MyComponentWidget</classname>. You can rename the classes afterwards."
msgstr ""

#. Tag: guilabel
#: chapter-gwt.xml:245
#, no-c-format
msgid "Superclass"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:247
#, no-c-format
msgid "The superclass of the server-side component. It is <classname>AbstractComponent</classname> by default, but <classname>com.vaadin.ui.AbstractField</classname> or <classname>com.vaadin.ui.AbstractSelect</classname> are other commonly used superclasses. If you are extending an existing component, you should select it as the superclass. You can easily change the superclass later."
msgstr ""

#. Tag: guilabel
#: chapter-gwt.xml:260
#, no-c-format
msgid "Template"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:262
#, no-c-format
msgid "Select which template to use. The default is <guilabel>Full fledged</guilabel>, which creates the server-side component, the client-side widget, the connector, a shared state object, and an RPC object. The <guilabel>Connector only</guilabel> leaves the shared state and RPC objects out."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:274
#, no-c-format
msgid "Finally, click <guibutton>Finish</guibutton> to create the new component."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:280
#, no-c-format
msgid "The wizard will:"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:286
#, no-c-format
msgid "Create a server-side component stub in the base package"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:290
#, no-c-format
msgid "If the project does not already have a widget set, the wizard creates a GWT module descriptor file (<filename>.gwt.xml</filename>) in the base package and modifies the servlet class or the <filename>web.xml</filename> deployment descriptor to specify the widget set class name parameter for the application"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:301
#, no-c-format
msgid "Create a client-side widget stub (along with the connector and shared state and RPC stubs) in the <filename>client.componentname</filename> package under the base package"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:308
#, no-c-format
msgid "The structure of the server-side component and the client-side widget, and the serialization of component state between them, is explained in the subsequent sections of this chapter."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:314
#, no-c-format
msgid "To compile the widget set, click the <guibutton>Compile widget set</guibutton> button in the Eclipse toolbar. See <xref linkend=\"gwt.eclipse.compiling\"/> for details. After the compilation finishes, you should be able to run your application as before, but using the new widget set. The compilation result is written under the <filename>WebContent/VAADIN/widgetsets</filename> folder. When you need to recompile the widget set in Eclipse, see <xref linkend=\"gwt.eclipse.compiling\"/>. For detailed information on compiling widget sets, see <xref linkend=\"clientside.compiling\"/>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:326
#, no-c-format
msgid "The following setting is inserted in the <filename>web.xml</filename> deployment descriptor to enable the widget set:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:331
#, no-c-format
msgid ""
      "<?pocket-size 65% ?>&lt;init-param&gt;\n"
      "    &lt;description&gt;Application widgetset&lt;/description&gt;\n"
      "    &lt;param-name&gt;widgetset&lt;/param-name&gt;\n"
      "    &lt;param-value&gt;<emphasis mode=\"bold\">com.example.myproject.widgetset.MyprojectApplicationWidgetset</emphasis>&lt;/param-value&gt;\n"
      "&lt;/init-param&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:333
#, no-c-format
msgid "You can refactor the package structure if you find need for it, but GWT compiler requires that the client-side code <emphasis>must</emphasis> always be stored under a package named \"<filename>client</filename>\" or a package defined with a <literal>source</literal> element in the widget set descriptor."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:343
#, no-c-format
msgid "Compiling the Widget Set"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:345
#, no-c-format
msgid "After you edit a widget, you need to compile the widget set. The Vaadin Plugin for Eclipse automatically suggests to compile the widget set in various situations, such as when you save a client-side source file. If this gets annoying, you can disable the automatic recompilation in the Vaadin category in project settings, by selecting the <guilabel>Suspend automatic widgetset builds</guilabel> option."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:354
#, no-c-format
msgid "You can compile the widget set manually by clicking the <guibutton>Compile widgetset</guibutton> button in the Eclipse toolbar, shown in <xref linkend=\"figure.gwt.eclipse.compiling.toolbar\"/>, while the project is open and selected. If the project has multiple widget set definition files, you need to select the one to compile in the Project Explorer."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:364
#, no-c-format
msgid "The <guibutton>Compile Widgetset</guibutton> Button in Eclipse Toolbar"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:375
#, no-c-format
msgid "The compilation progress is shown in the <guilabel>Console</guilabel> panel in Eclipse, illustrated in <xref linkend=\"figure.gwt.eclipse.compiling\"/>. You should note especially the list of widget sets found in the class path."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:383
#, no-c-format
msgid "Compiling a Widget Set"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:394
#, no-c-format
msgid "The compilation output is written under the <filename>WebContent/VAADIN/widgetsets</filename> folder, in a widget set specific folder."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:400
#, no-c-format
msgid "You can speed up the compilation significantly by compiling the widget set only for your browser during development. The generated <filename>.gwt.xml</filename> descriptor stub includes a disabled element that specifies the target browser. See <xref linkend=\"gwt.module.compilation-limiting\"/> for more details on setting the <literal>user-agent</literal> property."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:409
#, no-c-format
msgid "For more information on compiling widget sets, see <xref linkend=\"clientside.compiling\"/>. Should you compile a widget set outside Eclipse, you need to refresh the project by selecting it in <guilabel>Project Explorer</guilabel> and pressing <keycap>F5</keycap>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:422
#, no-c-format
msgid "Creating a Server-Side Component"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:424
#, no-c-format
msgid "Typical server-side Vaadin applications use server-side components that are rendered on the client-side using their counterpart widgets. A server-side component must manage state synchronization between the widget on the client-side, in addition to any server-side logic."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:432 chapter-gwt.xml:1553
#, no-c-format
msgid "Basic Server-Side Component"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:434
#, no-c-format
msgid "The component state is usually managed by a <emphasis>shared state</emphasis>, described later in <xref linkend=\"gwt.shared-state\"/>."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:439
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public class MyComponent extends AbstractComponent {\n"
      "    public MyComponent() {\n"
      "        getState().setText(\"This is MyComponent\");\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    protected MyComponentState getState() {\n"
      "        return (MyComponentState) super.getState();\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:448
#, no-c-format
msgid "Integrating the Two Sides with a Connector"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:450
#, no-c-format
msgid "A client-side widget is integrated with a server-side component with a <emphasis>connector</emphasis>. A connector is a client-side class that communicates changes to the widget state and events to the server-side."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:456
#, no-c-format
msgid "A connector normally gets the state of the server-side component by the <emphasis>shared state</emphasis>, described later in <xref linkend=\"gwt.shared-state\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:463
#, no-c-format
msgid "A Basic Connector"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:465
#, no-c-format
msgid "The basic tasks of a connector is to hook up to the widget and handle events from user interaction and changes received from the server. A connector also has a number of routine infrastructure methods which need to be implemented."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:472
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Connect(MyComponent.class)\n"
      "public class MyComponentConnector\n"
      "        extends AbstractComponentConnector {\n"
      "\n"
      "    @Override\n"
      "    public MyComponentWidget getWidget() {\n"
      "        return (MyComponentWidget) super.getWidget();\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    public MyComponentState getState() {\n"
      "        return (MyComponentState) super.getState();\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    public void onStateChanged(StateChangeEvent stateChangeEvent)\n"
      "    {\n"
      "        super.onStateChanged(stateChangeEvent);\n"
      "        \n"
      "        // Do something useful\n"
      "        final String text = getState().text;\n"
      "        getWidget().setText(text);\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:474
#, no-c-format
msgid "Here, we handled state change with the crude <methodname>onStateChanged()</methodname> method that is called when any of the state properties is changed. A finer and simpler handling is achieved by using the <classname>@OnStateChange</classname> annotation on a handler method for each property, or by <classname>@DelegateToWidget</classname> on a shared state property, as described later in <xref linkend=\"gwt.shared-state\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:486
#, no-c-format
msgid "Communication with the Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:488
#, no-c-format
msgid "The main task of a connector is to communicate user interaction with the widget to the server-side and receive state changes from the server-side and relay them to the widget."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:494
#, no-c-format
msgid "Server-to-client communication is normally done using a <emphasis>shared state</emphasis>, as described in <xref linkend=\"gwt.shared-state\"/>, as well as RPC calls. The serialization of the state data is handled completely transparently. <phrase condition=\"web\">Once the client-side engine receives the changes from the server, it reacts to them by creating and notifying connectors that in turn manage widgets. This is described in <xref linkend=\"gwt.advanced.phases\"/> in more detail.</phrase>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:504
#, no-c-format
msgid "For client-to-server communication, a connector can make remote procedure calls (RPC) to the server-side. Also, the server-side component can make RPC calls to the connector. For a thorough description of the RPC mechanism, refer to <xref linkend=\"gwt.rpc\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:514
#, no-c-format
msgid "Shared State"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:516
#, no-c-format
msgid "The basic communication from a server-side component to its the client-side widget counterpart is handled using a <emphasis>shared state</emphasis>. The shared state is serialized transparently. It should be considered read-only on the client-side, as it is not serialized back to the server-side."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:523
#, no-c-format
msgid "A shared state object simply needs to extend the <classname>ComponentState</classname>. The member variables should normally be declared as public."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:529
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class MyComponentState extends ComponentState {\n"
      "    public String text;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:531
#, no-c-format
msgid "A shared state should never contain any logic. If the members have private visibility for some reason, you can also use public setters and getters, in which case the property must not be public."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:538
#, no-c-format
msgid "Accessing Shared State on Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:540
#, no-c-format
msgid "A server-side component can access the shared state with the <methodname>getState()</methodname> method. It is required that you override the base implementation with one that returns the shared state object cast to the proper type, as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:547 chapter-gwt.xml:568
#, no-c-format
msgid ""
      "<![CDATA[@Override\n"
      "public MyComponentState getState() {\n"
      "    return (MyComponentState) super.getState();\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:549
#, no-c-format
msgid "You can then use the <methodname>getState()</methodname> to access the shared state object with the proper type."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:554
#, no-c-format
msgid ""
      "<![CDATA[public MyComponent() {\n"
      "    getState().setText(\"This is the initial state\");\n"
      "    ....\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:559
#, no-c-format
msgid "Handing Shared State in a Connector"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:561
#, no-c-format
msgid "A connector can access a shared state with the <methodname>getState()</methodname> method. The access should be read-only. It is required that you override the base implementation with one that returns the proper shared state type, as follows:"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:570
#, no-c-format
msgid "State changes made on the server-side are communicated transparently to the client-side. When a state change occurs, the <methodname>onStateChanged()</methodname> method in the connector is called. You should should always call the superclass method before anything else to handle changes to common component properties."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:578
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Override\n"
      "public void onStateChanged(StateChangeEvent stateChangeEvent) {\n"
      "    super.onStateChanged(stateChangeEvent);\n"
      "                \n"
      "    // Copy the state properties to the widget properties\n"
      "    final String text = getState().getText();\n"
      "    getWidget().setText(text);\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:580
#, no-c-format
msgid "The crude <methodname>onStateChanged()</methodname> method is called when any of the state properties is changed, allowing you to have even complex logic in how you manipulate the widget according to the state changes. In most cases, however, you can handle the property changes more easily and also more efficiently by using instead the <classname>@OnStateChange</classname> annotation on the handler methods for each property, as described next in <xref linkend=\"gwt.shared-state.onstatechange\"/>, or by delegating the property value directly to the widget, as described in <xref linkend=\"gwt.shared-state.delegatetowidget\"/>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:593
#, no-c-format
msgid "The processing phases of state changes are described in more detail in <xref linkend=\"gwt.advanced.phases\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:600
#, no-c-format
msgid "Handling Property State Changes with <classname>@OnStateChange</classname>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:602
#, no-c-format
msgid "The <classname>@OnStateChange</classname> annotation can be used to mark a connector method that handles state change on a particular property, given as parameter for the annotation. In addition to higher clarity, this avoids handling all property changes if a state change occurs in only one or some of them. However, if a state change can occur in multiple properties, you can only use this technique if the properties do not have interaction that prevents handling them separately in arbitrary order."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:612
#, no-c-format
msgid "We can replace the <methodname>onStateChange()</methodname> method in the earlier connector example with the following:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:617
#, no-c-format
msgid ""
      "<![CDATA[@OnStateChange(\"text\")\n"
      "void updateText() {\n"
      "    getWidget().setText(getState().text);\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:619
#, no-c-format
msgid "If the shared state property and the widget property have same name and do not require any type conversion, as is the case in the above example, you could simplify this even further by using the <classname>@DelegateToWidget</classname> annotation for the shared state property, as described in <xref linkend=\"gwt.shared-state.delegatetowidget\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:630
#, no-c-format
msgid "Delegating State Properties to Widget"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:632
#, no-c-format
msgid "The <classname>@DelegateToWidget</classname> annotation for a shared state property defines automatic delegation of the property value to the corresponding widget property of the same name and type, by calling the respective setter for the property in the widget."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:639
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public class MyComponentState extends AbstractComponentState {\n"
      "    @DelegateToWidget\n"
      "    public String text;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:641
#, no-c-format
msgid "This is equivalent to handling the state change in the connector, as done in the example in <xref linkend=\"gwt.shared-state.onstatechange\"/>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:646
#, no-c-format
msgid "If you want to delegate a shared state property to a widget property of another name, you can give the property name as a string parameter for the annotation."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:652
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public class MyComponentState extends AbstractComponentState {\n"
      "    @DelegateToWidget(\"description\")\n"
      "    public String text;\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:657
#, no-c-format
msgid "Referring to Components in Shared State"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:659
#, no-c-format
msgid "While you can pass any regular Java objects through a shared state, referring to another component requires special handling because on the server-side you can only refer to a server-side component, while on the client-side you only have widgets. References to components can be made by referring to their connectors (all server-side components implement the <interfacename>Connector</interfacename> interface)."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:668
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class MyComponentState extends ComponentState {\n"
      "    public Connector otherComponent;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:670
#, no-c-format
msgid "You could then access the component on the server-side as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:674
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class MyComponent {\n"
      "    public void MyComponent(Component otherComponent) {\n"
      "        getState().otherComponent = otherComponent;\n"
      "    }\n"
      "\n"
      "    public Component getOtherComponent() {\n"
      "        return (Component)getState().otherComponent;\n"
      "    }\n"
      "\n"
      "    // And the cast method\n"
      "    @Override\n"
      "    public MyComponentState getState() {\n"
      "        return (MyComponentState) super.getState();\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:676
#, no-c-format
msgid "On the client-side, you should cast it in a similar fashion to a <classname>ComponentConnector</classname>, or possibly to the specific connector type if it is known."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:684
#, no-c-format
msgid "Sharing Resources"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:686
#, no-c-format
msgid "Resources, which commonly are references to icons or other images, are another case of objects that require special handling. A <interfacename>Resource</interfacename> object exists only on the server-side and on the client-side you have an URL to the resource. You need to use the <methodname>setResource()</methodname> and <methodname>getResource()</methodname> on the server-side to access a resource, which is serialized to the client-side separately."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:696
#, no-c-format
msgid "Let us begin with the server-side API:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:700
#, no-c-format
msgid ""
      "<![CDATA[public class MyComponent extends AbstractComponent {\n"
      "    ...\n"
      "\n"
      "    public void setMyIcon(Resource myIcon) {\n"
      "        setResource(\"myIcon\", myIcon);\n"
      "    }\n"
      "\n"
      "    public Resource getMyIcon() {\n"
      "        return getResource(\"myIcon\");\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:702
#, no-c-format
msgid "On the client-side, you can then get the URL of the resource with <methodname>getResourceUrl()</methodname>."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:707
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Override\n"
      "public void onStateChanged(StateChangeEvent stateChangeEvent) {\n"
      "    super.onStateChanged(stateChangeEvent);\n"
      "    ...\n"
      "        \n"
      "    // Get the resource URL for the icon\n"
      "    getWidget().setMyIcon(getResourceUrl(\"myIcon\"));\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:709
#, no-c-format
msgid "The widget could then use the URL, for example, as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:713
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class MyWidget extends Label {\n"
      "    ...\n"
      "    \n"
      "    Element imgElement = null;\n"
      "    \n"
      "    public void setMyIcon(String url) {\n"
      "        if (imgElement == null) {\n"
      "            imgElement = DOM.createImg();\n"
      "            getElement().appendChild(imgElement);\n"
      "        }\n"
      "        \n"
      "        DOM.setElementAttribute(imgElement, \"src\", url);\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:719
#, no-c-format
msgid "RPC Calls Between Client- and Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:721
#, no-c-format
msgid "Vaadin supports making Remote Procedure Calls (RPC) between a server-side component and its client-side widget counterpart. RPC calls are normally used for communicating stateless events, such as button clicks or other user interaction, in contrast to changing the shared state. Either party can make an RPC call to the other side. When a client-side widget makes a call, a server request is made. Calls made from the server-side to the client-side are communicated in the response of the server request during which the call was made."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:732
#, no-c-format
msgid "If you use Eclipse and enable the \"Full-Fledged\" widget in the New Vaadin Widget wizard, it automatically creates a component with an RPC stub."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:738
#, no-c-format
msgid "RPC Calls to the Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:740
#, no-c-format
msgid "RPC calls from the client-side to the server-side are made through an RPC interface that extends the <interfacename>ServerRpc</interfacename> interface. A server RPC interface simply defines any methods that can be called through the interface."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:747
#, no-c-format
msgid "For example:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:751
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public interface MyComponentServerRpc extends ServerRpc {\n"
      "    public void clicked(String buttonName);\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:753
#, no-c-format
msgid "The above example defines a single <methodname>clicks()</methodname> RPC call, which takes a <classname>MouseEventDetails</classname> object as the parameter."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:759
#, no-c-format
msgid "You can pass the most common standard Java types, such as primitive and boxed primitive types, <classname>String</classname>, and arrays and some collections (<classname>List</classname>, <classname>Set</classname>, and <classname>Map</classname>) of the supported types. Also the Vaadin <classname>Connector</classname> and some special internal types can be passed."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:768
#, no-c-format
msgid "An RPC method must return void - the widget set compiler should complain if it doesn't."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:774
#, no-c-format
msgid "Making a Call"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:776
#, no-c-format
msgid "Before making a call, you need to instantiate the server RPC object with <methodname>RpcProxy.create()</methodname>. After that, you can make calls through the server RPC interface that you defined, for example as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:783
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Connect(MyComponent.class)\n"
      "public class MyComponentConnector\n"
      "       extends AbstractComponentConnector {\n"
      "\n"
      "    public MyComponentConnector() {\n"
      "        getWidget().addClickHandler(new ClickHandler() {\n"
      "            public void onClick(ClickEvent event) {\n"
      "                final MouseEventDetails mouseDetails =\n"
      "                     MouseEventDetailsBuilder\n"
      "                         .buildMouseEventDetails(\n"
      "                                 event.getNativeEvent(),\n"
      "                                 getWidget().getElement());\n"
      "                MyComponentServerRpc rpc =\n"
      "                    getRpcProxy(MyComponentServerRpc.class);\n"
      "\n"
      "                // Make the call\n"
      "                rpc.clicked(mouseDetails.getButtonName());\n"
      "            }\n"
      "        });\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:787
#, no-c-format
msgid "Handling a Call"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:789
#, no-c-format
msgid "RPC calls are handled in a server-side implementation of the server RPC interface. The call and its parameters are serialized and passed to the server in an RPC request transparently."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:795
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public class MyComponent extends AbstractComponent {\n"
      "    private MyComponentServerRpc rpc =\n"
      "    new MyComponentServerRpc() {\n"
      "        private int clickCount = 0;\n"
      "        \n"
      "        public void clicked(String buttonName) {\n"
      "            Notification.show(\"Clicked \" + buttonName);\n"
      "        }\n"
      "    };\n"
      "\n"
      "    public MyComponent() {\n"
      "        ...\n"
      "        registerRpc(rpc);\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:801
#, no-c-format
msgid "Component and &uiclass; Extensions"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:803
#, no-c-format
msgid "Adding features to existing components by extending them by inheritance creates a problem when you want to combine such features. For example, one add-on could add spell-check to a <classname>TextField</classname>, while another could add client-side validation. Combining such add-on features would be difficult if not impossible. You might also want to add a feature to several or even to all components, but extending all of them by inheritance is not really an option. Vaadin includes a component plug-in mechanism for these purposes. Such plug-ins are simply called <emphasis>extensions</emphasis>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:814
#, no-c-format
msgid "Also a &ui; can be extended in a similar fashion. In fact, some Vaadin features such as the JavaScript execution are UI extensions."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:819
#, no-c-format
msgid "Implementing an extension requires defining a server-side extension class and a client-side connector. An extension can have a shared state with the connector and use RPC, just like a component could."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:826
#, no-c-format
msgid "Server-Side Extension API"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:828
#, no-c-format
msgid "The server-side API for an extension consists of class that extends (in the Java sense) the <classname>AbstractExtension</classname> class. It typically has an <emphasis>extend()</emphasis> method, a constructor, or a static helper method that takes the extended component or &ui; as a parameter and passes it to <emphasis>super.extend()</emphasis>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:836
#, no-c-format
msgid "For example, let us have a trivial example with an extension that takes no special parameters, and illustrates the three alternative APIs:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:841
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class CapsLockWarning extends AbstractExtension {\n"
      "    // You could pass it in the constructor\n"
      "    public CapsLockWarning(PasswordField field) {\n"
      "        super.extend(field);\n"
      "    }\n"
      "\n"
      "    // Or in an extend() method\n"
      "    public void extend(PasswordField field) {\n"
      "        super.extend(field);\n"
      "    }\n"
      "\n"
      "    // Or with a static helper\n"
      "    public static addTo(PasswordField field) {\n"
      "        new CapsLockWarning().extend(field);\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:843
#, no-c-format
msgid "The extension could then be added to a component as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:847
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[PasswordField password = new PasswordField(\"Give it\");\n"
      "\n"
      "// Use the constructor\n"
      "new CapsLockWarning(password);\n"
      "\n"
      "// ... or with the extend() method\n"
      "new CapsLockWarning().extend(password);\n"
      "\n"
      "// ... or with the static helper\n"
      "CapsLockWarning.addTo(password);\n"
      "\n"
      "layout.addComponent(password);]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:849
#, no-c-format
msgid "Adding a feature in such a \"reverse\" way is a bit unusual in the Vaadin API, but allows type safety for extensions, as the method can limit the target type to which the extension can be applied, and whether it is a regular component or a &ui;."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:858
#, no-c-format
msgid "Extension Connectors"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:860
#, no-c-format
msgid "An extension does not have a corresponding widget on the client-side, but only an extension connector that extends the <classname>AbstractExtensionConnector</classname> class. The server-side extension class is specified with a <literal>@Connect</literal> annotation, just like in component connectors."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:868
#, no-c-format
msgid "An extension connector needs to implement the <methodname>extend()</methodname> method, which allows hooking to the extended component. The normal extension mechanism is to modify the extended component as needed and add event handlers to it to handle user interaction. An extension connector can share a state with the server-side extension as well as make RPC calls, just like with components."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:877
#, no-c-format
msgid "In the following example, we implement a \"Caps Lock warning\" extension. It listens for changes in Caps Lock state and displays a floating warning element over the extended component if the Caps Lock is on."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:883
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Connect(CapsLockWarning.class)\n"
      "public class CapsLockWarningConnector\n"
      "        extends AbstractExtensionConnector {\n"
      "\n"
      "    @Override\n"
      "    protected void extend(ServerConnector target) {\n"
      "        // Get the extended widget\n"
      "        final Widget pw =\n"
      "                ((ComponentConnector) target).getWidget();\n"
      "\n"
      "        // Preparations for the added feature\n"
      "        final VOverlay warning = new VOverlay();\n"
      "        warning.setOwner(pw);\n"
      "        warning.add(new HTML(\"Caps Lock is enabled!\"));\n"
      "\n"
      "        // Add an event handler\n"
      "        pw.addDomHandler(new KeyPressHandler() {\n"
      "            public void onKeyPress(KeyPressEvent event) {\n"
      "                if (isEnabled() && isCapsLockOn(event)) {\n"
      "                    warning.showRelativeTo(passwordWidget);\n"
      "                } else {\n"
      "                    warning.hide();\n"
      "                }\n"
      "            }\n"
      "        }, KeyPressEvent.getType());\n"
      "    }\n"
      "\n"
      "    private boolean isCapsLockOn(KeyPressEvent e) {\n"
      "        return e.isShiftKeyDown() ^\n"
      "               Character.isUpperCase(e.getCharCode());\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:885
#, no-c-format
msgid "The <methodname>extend()</methodname> method gets the connector of the extended component as the parameter, in the above example a <classname>PasswordFieldConnector</classname>. It can access the widget with the <methodname>getWidget()</methodname>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:892
#, no-c-format
msgid "An extension connector needs to be included in a widget set. The class must therefore be defined under the <filename>client</filename> package of a widget set, just like with component connectors."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:901
#, no-c-format
msgid "Styling a Widget"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:903
#, no-c-format
msgid "To make your widget look stylish, you need to style it. There are two basic ways to define CSS styles for a component: in the widget sources and in a theme. A default style should be defined in the widget sources, and different themes can then modify the style."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:911
#, no-c-format
msgid "Determining the CSS Class"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:913
#, no-c-format
msgid "The CSS class of a widget element is normally defined in the widget class and set with <methodname>setStyleName()</methodname>. A widget should set the styles for its sub-elements as it desires."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:919
#, no-c-format
msgid "For example, you could style a composite widget with an overall style and with separate styles for the sub-widgets as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:924
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public class MyPickerWidget extends ComplexPanel {\n"
      "    public static final String CLASSNAME = \"mypicker\";\n"
      "\n"
      "    private final TextBox textBox = new TextBox();\n"
      "    private final PushButton button = new PushButton(\"...\");\n"
      "\n"
      "    public MyPickerWidget() {\n"
      "        setElement(Document.get().createDivElement());\n"
      "        setStylePrimaryName(CLASSNAME);\n"
      "\n"
      "        textBox.setStylePrimaryName(CLASSNAME + \"-field\");\n"
      "        button.setStylePrimaryName(CLASSNAME + \"-button\");\n"
      "\n"
      "        add(textBox, getElement());\n"
      "        add(button, getElement());\n"
      "\n"
      "        button.addClickHandler(new ClickHandler() {\n"
      "            public void onClick(ClickEvent event) {\n"
      "              Window.alert(\"Calendar picker not yet supported!\");\n"
      "            }\n"
      "        });\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:926
#, no-c-format
msgid "In addition, all Vaadin components get the <literal>v-widget</literal> class. If it extends an existing Vaadin or GWT widget, it will inherit CSS classes from that as well."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:934
#, no-c-format
msgid "Default Stylesheet"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:936
#, no-c-format
msgid "A client-side module, which is normally a widget set, can include stylesheets. They must be placed under the <filename>public</filename> folder under the folder of the widget set, a described in <xref linkend=\"clientside.module.stylesheet\"/>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:943
#, no-c-format
msgid "For example, you could style the widget described above as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:947
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[.mypicker {\n"
      "        white-space: nowrap;\n"
      "}\n"
      "\n"
      ".mypicker-button {\n"
      "        display: inline-block;\n"
      "        border: 1px solid black;\n"
      "        padding: 3px;\n"
      "        width: 15px;\n"
      "        text-align: center;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:949
#, no-c-format
msgid "Notice that some size settings may require more complex handling and calculating the sizes dynamically."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:984
#, no-c-format
msgid "Component Containers"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:986
#, no-c-format
msgid "Component containers, such as layout components, are a special group of components that require some consideration. In addition to handling state, they need to manage communicating the hierarchy of their contained components to the other side."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:993
#, no-c-format
msgid "The easiest way to implement a component container is extend the <classname>AbstractComponentContainer</classname>, which handles the synchronization of the container server-side components to the client-side."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1022
#, no-c-format
msgid "Advanced Client-Side Topics"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1024
#, no-c-format
msgid "In the following, we mention some topics that you may encounter when integrating widgets."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1030
#, no-c-format
msgid "Client-Side Processing Phases"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1032
#, no-c-format
msgid "Vaadin's client-side engine reacts to changes from the server in a number of phases, the order of which can be relevant for a connector. The processing occurs in the <methodname>handleUIDLMessage()</methodname> method in <classname>ApplicationConnection</classname>, but the logic can be quite overwhelming, so we describe the phases in the following summary."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1042
#, no-c-format
msgid "Any dependencies defined by using <classname>@JavaScript</classname> or <classname>@StyleSheet</classname> on the server-side class are loaded. Processing does not continue until the browser confirms that they have been loaded."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1052
#, no-c-format
msgid "New connectors are instantiated and <methodname>init()</methodname> is run for each <interfacename>Connector</interfacename>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1060
#, no-c-format
msgid "State objects are updated, but no state change event is fired yet."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1066
#, no-c-format
msgid "The connector hierarchy is updated, but no hierarchy change event is fired yet. <methodname>setParent()</methodname> and <methodname>setChildren()</methodname> are run in this phase."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1074
#, no-c-format
msgid "Hierarchy change events are fired. This means that all state objects and the entire hierarchy are already up to date when this happens. The DOM hierarchy should in theory be up to date after all hierarchy events have been handled, although there are some built-in components that for various reasons do not always live up to this promise."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1085
#, no-c-format
msgid "Captions are updated, causing <methodname>updateCaption()</methodname> to be invoked on layouts as needed."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1093
#, no-c-format
msgid "<classname>@DelegateToWidget</classname> is handled for all changed state objects using the annotation."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1100
#, no-c-format
msgid "State change events are fired for all changed state objects."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1106
#, no-c-format
msgid "<methodname>updateFromUIDL()</methodname> is called for legacy connectors."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1113
#, no-c-format
msgid "All RPC methods received from the server are invoked."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1119
#, no-c-format
msgid "Connectors that are no longer included in the hierarchy are unregistered. This calls <methodname>onUnregister()</methodname> on the <interfacename>Connector</interfacename>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1127
#, no-c-format
msgid "The layout phase starts, first checking the sizes and positions of all elements, and then notifying any <interfacename>ElementResizeListener</interfacename>s, as well as calling the appropriate layout method for the connectors that implement either <classname>SimpleManagedLayout</classname> or <classname>DirectionalManagedLayout</classname> interface."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1141
#, no-c-format
msgid "Creating Add-ons"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:1144
#, no-c-format
msgid "<primary>add-ons</primary>"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:1145
#, no-c-format
msgid "creating"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1148
#, no-c-format
msgid "Add-ons are the most convenient way to reuse Vaadin code, either commercially or free. Vaadin Directory serves as the store for the add-ons. You can distribute add-ons both as JAR libraries and Zip packages."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1154
#, no-c-format
msgid "Creating a typical add-on package involves the following tasks:"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1159
#, no-c-format
msgid "Compile server-side classes"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1160
#, no-c-format
msgid "Compile JavaDoc (optional)"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1162
#, no-c-format
msgid "Build the JAR"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1164
#, no-c-format
msgid "Include Vaadin add-on manifest"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1165
#, no-c-format
msgid "Include the compiled server-side classes"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1166
#, no-c-format
msgid "Include the compiled JavaDoc (optional)"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1167
#, no-c-format
msgid "Include sources of client-side classes for widget set compilation (optional)"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1168
#, no-c-format
msgid "Include any JavaScript dependency libraries (optional)"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1169
#, no-c-format
msgid "Exclude any test or demo code in the project"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1174
#, no-c-format
msgid "The exact contents depend on the add-on type. Component add-ons often include a widget set, but not always, such as JavaScript components or pure server-side components. You can also have data container and theme add-ons, as well as various tools."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1181
#, no-c-format
msgid "It is common to distribute the JavaDoc in a separate JAR, but you can also include it in the same JAR."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1187
#, no-c-format
msgid "Exporting Add-on in Eclipse"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1189
#, no-c-format
msgid "If you use the Vaadin Plugin for Eclipse for your add-on project, you can simply export the add-on from Eclipse."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1196
#, no-c-format
msgid "Select the project and then <menuchoice><guimenu>File</guimenu><guimenuitem>Export</guimenuitem></menuchoice> from the menu"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1201
#, no-c-format
msgid "In the export wizard that opens, select <menuchoice><guimenu>Vaadin</guimenu><guimenuitem>Vaadin Add-on Package</guimenuitem></menuchoice>, and click <guibutton>Next</guibutton>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1206
#, no-c-format
msgid "In the <guilabel>Select the resources to export</guilabel> panel, select the content that should be included in the add-on package. In general, you should include sources in <filename>src</filename> folder (at least for the client-side package), compiled server-side classes, themes in <filename>WebContent/VAADIN/themes</filename>. These are all included automatically. You probably want to leave out any demo or example code."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1218
#, no-c-format
msgid "Exporting a Vaadin Add-on"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1226
#, no-c-format
msgid "If you are submitting the add-on to Vaadin Directory, the <guilabel>Implementation title</guilabel> should be exactly the name of the add-on in Directory. The name may contain spaces and most other letters. Notice that <emphasis>it is not possible to change the name later</emphasis>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1234
#, no-c-format
msgid "The <guilabel>Implementation version</guilabel> is the version of your add-on. Typically experimental or beta releases start from 0.1.0, and stable releases from 1.0.0."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1240
#, no-c-format
msgid "The <guilabel>Widgetsets</guilabel> field should list the widget sets included in the add-on, separated by commas. The widget sets should be listed by their class name, that is, without the <filename>.gwt.xml</filename> extension."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1247
#, no-c-format
msgid "The <guilabel>JAR file</guilabel> is the file name of the exported JAR file. It should normally include the version number of the add-on. You should follow the Maven format for the name, such as <filename>myaddon-1.0.0.jar</filename>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1254
#, no-c-format
msgid "Finally, click <guibutton>Finish</guibutton>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1262
#, no-c-format
msgid "Building Add-on with Ant"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1264
#, no-c-format
msgid "Building an add-on with Ant is similar to building Vaadin applications. Vaadin libraries and other dependencies are retrieved and included in the classpath using Apache Ivy."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1270
#, no-c-format
msgid "In the following, we assume the same structure as in the Eclipse project example. Let us put the build script in the <filename>build</filename> folder under the project. We begin the Ant script as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1276
#, no-c-format
msgid ""
      "&lt;?xml version=\"1.0\"?&gt;\n"
      "\n"
      "&lt;project xmlns:ivy=\"antlib:org.apache.ivy.ant\"\n"
      "         name=\"<emphasis role=\"bold\">My Own add-on</emphasis>\"\n"
      "         basedir=\"..\"\n"
      "         default=\"package-jar\"&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1278
#, no-c-format
msgid "The namespace declaration is all you need to do to enable Ivy in Ant 1.6 and later. For earlier Ant versions, please see the Ivy documentation."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1284
#, no-c-format
msgid "Configuration and Initialization"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1286
#, no-c-format
msgid "In the example script, we organize most settings in a <literal>configure</literal> target and then initialize the build in <literal>init</literal> target."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1292
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><!-- Update these settings for your project structure -->\n"
      "&lt;target name=\"configure\"&gt;\n"
      "    &lt;!-- Where project source files are located --&gt;\n"
      "    &lt;property name=\"src-location\" value=\"<emphasis role=\"bold\">src</emphasis>\" /&gt;\n"
      "        \n"
      "    &lt;!-- Name of the widget set. --&gt;\n"
      "    &lt;property name=\"widgetset\" value=\"<emphasis role=\"bold\">com.example.myaddon.widgetset.MyAddonWidgetset</emphasis>\"/&gt;\n"
      "\n"
      "    &lt;!-- Addon version --&gt;\n"
      "    &lt;property name=\"version\" value=\"<emphasis role=\"bold\">0.1.0</emphasis>\"/&gt;\n"
      "    \n"
      "    &lt;!-- Compilation result directory --&gt;\n"
      "    &lt;property name=\"result-dir\" value=\"build/result\"/&gt;\n"
      "    \n"
      "    &lt;!-- The target name of the built add-on JAR --&gt;\n"
      "    &lt;property name=\"target-jar\"\n"
      "        value=\"${result-dir}/<emphasis role=\"bold\">myaddon</emphasis>-${version}.jar\"/&gt;\n"
      "&lt;/target&gt;\n"
      "\n"
      "<!-- Initialize build -->\n"
      "&lt;target name=\"init\" depends=\"configure\"&gt;\n"
      "    &lt;!-- Construct and check classpath --&gt;\n"
      "    &lt;path id=\"compile.classpath\"&gt;\n"
      "        &lt;pathelement path=\"build/classes\" /&gt;\n"
      "        &lt;pathelement path=\"${src-location}\" /&gt;\n"
      "        &lt;fileset dir=\"${result-dir}/lib\"&gt;\n"
      "            &lt;include name=\"*.jar\"/&gt;\n"
      "        &lt;/fileset&gt;\n"
      "    &lt;/path&gt;\n"
      "\n"
      "    &lt;mkdir dir=\"${result-dir}\"/&gt;\n"
      "&lt;/target&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1294
#, no-c-format
msgid "You will need to make some configuration also in the <literal>package-jar</literal> target in addition to the <literal>configure</literal> target."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1302
#, no-c-format
msgid "Compiling the Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1304
#, no-c-format
msgid "Compiling the add-on requires the Vaadin libraries and any dependencies. We use Apache Ivy for resolving the dependencies and retrieving the library JARs."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1310
#, no-c-format
msgid ""
      "<?pocket-size 65% ?>&lt;!-- Retrieve dependencies with Ivy --&gt;\n"
      "&lt;target name=\"resolve\" depends=\"init\"&gt;\n"
      "    &lt;ivy:retrieve\n"
      "        pattern=\"${result-dir}/lib/[artifact].[ext]\"/&gt;\n"
      "&lt;/target&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1312
#, no-c-format
msgid "The <literal>pattern</literal> attribute for the <literal>&lt;retrieve&gt;</literal> task specifies where the dependencies are stored, in the above case in the <filename>build/result/lib</filename> directory."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1319
#, no-c-format
msgid "Compiling the server-side classes is then straight-forward:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1323
#, no-c-format
msgid ""
      "<![CDATA[<!-- Compile server-side -->\n"
      "<target name=\"compile-server-side\"\n"
      "        depends=\"init, resolve\">\n"
      "    <delete dir=\"${result-dir}/classes\"/>\n"
      "    <mkdir dir=\"${result-dir}/classes\"/>\n"
      "\n"
      "    <javac srcdir=\"${src-location}\"\n"
      "           destdir=\"${result-dir}/classes\">\n"
      "        <classpath>\n"
      "            <path refid=\"compile.classpath\"/>\n"
      "        </classpath>\n"
      "    </javac>\n"
      "</target>]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1327
#, no-c-format
msgid "Compiling the JavaDoc"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1329
#, no-c-format
msgid "You may want to include API documentation for the add-on in the same or in a different JAR file. You can do it as follows, using the configuration we defined earlier. You may want to exclude the client-side classes and any test and demo classes from the JavaDoc, as is done in this example, if they are in the same source tree."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1337
#, no-c-format
msgid ""
      "<?pocket-size 75% ?>&lt;!-- Compile JavaDoc --&gt;\n"
      "&lt;target name=\"compile-javadoc\" depends=\"init\"&gt;\n"
      "    &lt;delete dir=\"${result-dir}/javadoc\"/&gt;\n"
      "    &lt;mkdir dir=\"${result-dir}/javadoc\"/&gt;\n"
      "\n"
      "    &lt;javadoc destdir=\"${result-dir}/javadoc\"&gt;\n"
      "        &lt;sourcefiles&gt;\n"
      "            &lt;fileset dir=\"${src-location}\" id=\"src\"&gt;\n"
      "                &lt;include name=\"**/*.java\"/&gt;\n"
      "                \n"
      "                &lt;!-- Excluded stuff from the package --&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/client/**/*</emphasis>\"/&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/demo/**/*</emphasis>\"/&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/MyDemoUI.java</emphasis>\"/&gt;\n"
      "            &lt;/fileset&gt;\n"
      "        &lt;/sourcefiles&gt;\n"
      "        &lt;classpath&gt;\n"
      "            &lt;path refid=\"compile.classpath\"/&gt;\n"
      "        &lt;/classpath&gt;\n"
      "    &lt;/javadoc&gt;\n"
      "&lt;/target&gt;"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1341
#, no-c-format
msgid "Packaging the JAR"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1343
#, no-c-format
msgid "An add-on JAR typically includes the following:"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1348
#, no-c-format
msgid "Vaadin add-on manifest"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1349
#, no-c-format
msgid "The compiled server-side classes"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1350
#, no-c-format
msgid "The compiled JavaDoc (optional)"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1351
#, no-c-format
msgid "Sources of client-side classes (optional)"
msgstr ""

#. Tag: listitem
#: chapter-gwt.xml:1352
#, no-c-format
msgid "Any JavaScript dependency libraries (optional)"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1355
#, no-c-format
msgid "Let us begin crafting the target. The JAR requires the compiled server-side classes and the optional API documentation."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1360
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<!-- Build the JAR -->\n"
      "<target name=\"package-jar\"\n"
      "        depends=\"compile-server-side, compile-javadoc\">\n"
      "    <jar jarfile=\"${target-jar}\" compress=\"true\">]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1362
#, no-c-format
msgid "First, you need to include a manifest that defines basic information about the add-on. The implementation title must be the exact title of the add-on, as shown in the Vaadin Directory title. The vendor is you. The manifest also includes the license title and file reference for the add-on."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1370
#, no-c-format
msgid ""
      "<?pocket-size 65% ?>&lt;!-- Manifest required by Vaadin Directory --&gt;\n"
      "&lt;manifest&gt;\n"
      "    &lt;attribute name=\"Vaadin-Package-Version\"\n"
      "               value=\"1\" /&gt;\n"
      "    &lt;attribute name=\"Vaadin-Widgetsets\"\n"
      "               value=\"${widgetset}\" /&gt;\n"
      "    &lt;attribute name=\"Implementation-Title\"\n"
      "               value=\"<emphasis role=\"bold\">My Own Addon</emphasis>\" /&gt;\n"
      "    &lt;attribute name=\"Implementation-Version\"\n"
      "               value=\"${version}\" /&gt;\n"
      "    &lt;attribute name=\"Implementation-Vendor\"\n"
      "               value=\"<emphasis role=\"bold\">Me Myself</emphasis>\" /&gt;\n"
      "    &lt;attribute name=\"Vaadin-License-Title\"\n"
      "               value=\"<emphasis role=\"bold\">Apache2</emphasis>\" /&gt;\n"
      "    &lt;attribute name=\"Vaadin-License-File\"\n"
      "        value=\"<emphasis role=\"bold\">http://www.apache.org/licenses/LICENSE-2.0</emphasis>\" /&gt;\n"
      "&lt;/manifest&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1372
#, no-c-format
msgid "The rest of the <literal>package-jar</literal> target goes as follows. As was done in the JavaDoc compilation, you also need to exclude any test or demo code in the project here. You need to modify at least the emphasized parts for your project."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1379
#, no-c-format
msgid ""
      "<?pocket-size 65% ?>        &lt;!-- Include built server-side classes --&gt;\n"
      "        &lt;fileset dir=\"build/result/classes\"&gt;\n"
      "            &lt;patternset&gt;\n"
      "                &lt;include name=\"<emphasis role=\"bold\">com/example/myaddon/**/*</emphasis>\"/&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/client/**/*</emphasis>\"/&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/demo/**/*</emphasis>\"/&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/test/**/*</emphasis>\"/&gt;\n"
      "                &lt;exclude name=\"<emphasis role=\"bold\">**/MyDemoUI*</emphasis>\"/&gt;\n"
      "            &lt;/patternset&gt;\n"
      "        &lt;/fileset&gt;\n"
      "    \n"
      "        &lt;!-- Include widget set sources --&gt;\n"
      "        &lt;fileset dir=\"src\"&gt;\n"
      "            &lt;patternset&gt;\n"
      "                &lt;include name=\"<emphasis role=\"bold\">com/exaple/myaddon/**/*</emphasis>\"/&gt;\n"
      "            &lt;/patternset&gt;\n"
      "        &lt;/fileset&gt;\n"
      "    \n"
      "        &lt;!-- Include JavaDoc in the JAR --&gt;\n"
      "        &lt;fileset dir=\"${result-dir}/javadoc\"\n"
      "                 includes=\"**/*\"/&gt;\n"
      "    &lt;/jar&gt;\n"
      "&lt;/target&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1383
#, no-c-format
msgid "You should now be ready to run the build script with Ant."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1391
#, no-c-format
msgid "Migrating from Vaadin 6"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:1394
#, no-c-format
msgid "Vaadin 6 Migration"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:1395
#, no-c-format
msgid "<secondary>add-ons</secondary>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1398
#, no-c-format
msgid "The client-side architecture was redesigned almost entirely in Vaadin 7. In Vaadin 6, state synchronization was done explicitly by serializing and deserializing the state on the server- and client-side. In Vaadin 7, the serialization is handled automatically by the framework using state objects."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1405
#, no-c-format
msgid "In Vaadin 6, a server-side component serialized its state to the client-side using the <interfacename>Paintable</interfacename> interface in the client-side and deserialized the state through the <interfacename>VariableOwner</interfacename> interface. In Vaadin 7, these are done through the <interfacename>ClientConnector</interfacename> interface."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1413
#, no-c-format
msgid "On the client-side, a widget deserialized its state through the <interfacename>Paintable</interfacename> interface and sent state changes through the <interfacename>ApplicationConnection</interfacename> object. In Vaadin 7, these are replaced with the <interfacename>ServerConnector</interfacename>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1421
#, no-c-format
msgid "In addition to state synchronization, Vaadin 7 has an RPC mechanism that can be used for communicating events. They are especially useful for events that are not associated with a state change, such as a button click."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1427
#, no-c-format
msgid "The framework ensures that the connector hierarchy and states are up-to-date when listeners are called."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1433
#, no-c-format
msgid "Quick (and Dirty) Migration"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1435
#, no-c-format
msgid "Vaadin 7 has a compatibility layer that allows quick conversion of a widget."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1441
#, no-c-format
msgid "Create a connector class, such as <classname>MyConnector</classname>, that extends <classname>LegacyConnector</classname>. Implement the <methodname>getWidget()</methodname> method."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1449
#, no-c-format
msgid "Move the <literal>@ClientWidget(MyWidget.class)</literal> from the server-side component, say <classname>MyComponent</classname>, to the <classname>MyConnector</classname> class and make it <literal>@Connect(MyComponent.class)</literal>."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1457
#, no-c-format
msgid "Have the server-side component implement the <interface>LegacyComponent</interface> interface to enable compatibility handling."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1464
#, no-c-format
msgid "Remove any calls to <literal>super.paintContent()</literal>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1469
#, no-c-format
msgid "Update any imports on the client-side"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1480
#, no-c-format
msgid "Integrating JavaScript Components and Extensions"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:1483
#, no-c-format
msgid "JavaScript integration"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1486
#, no-c-format
msgid "Vaadin allows simplified integration of pure JavaScript components, as well as component and UI extensions. The JavaScript connector code is published from the server-side. As the JavaScript integration does not involve GWT programming, no widget set compilation is needed."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1494
#, no-c-format
msgid "Example JavaScript Library"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1496
#, no-c-format
msgid "There are many kinds of component libraries for JavaScript. In the following, we present a simple library that provides one object-oriented JavaScript component. We use this example later to show how to integrate it with a server-side Vaadin component."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1503
#, no-c-format
msgid "The example library includes a single <classname>MyComponent</classname> component, defined in <filename>mylibrary.js</filename>."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1508
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[// Define the namespace\n"
      "var mylibrary = mylibrary || {};\n"
      "\n"
      "mylibrary.MyComponent = function (element) {\n"
      "        element.innerHTML =\n"
      "                \"<div class='caption'>Hello, world!</div>\" +\n"
      "                \"<div class='textinput'>Enter a value: \" +\n"
      "                \"<input type='text' name='value'/>\" +\n"
      "                \"<input type='button' value='Click'/>\" +\n"
      "                \"</div>\";\n"
      "\n"
      "        // Style it\n"
      "        element.style.border = \"thin solid red\";\n"
      "        element.style.display = \"inline-block\";\n"
      "\n"
      "        // Getter and setter for the value property\n"
      "        this.getValue = function () {\n"
      "                return element.\n"
      "                    getElementsByTagName(\"input\")[0].value;\n"
      "        };\n"
      "        this.setValue = function (value) {\n"
      "                element.getElementsByTagName(\"input\")[0].value =\n"
      "                    value;\n"
      "        };\n"
      "\n"
      "        // Default implementation of the click handler\n"
      "        this.click = function () {\n"
      "                alert(\"Error: Must implement click() method\");\n"
      "        };\n"
      "\n"
      "        // Set up button click\n"
      "        var button = element.getElementsByTagName(\"input\")[1];\n"
      "        var self = this; // Can't use this inside the function\n"
      "        button.onclick = function () {\n"
      "                self.click();\n"
      "        };\n"
      "};]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1510
#, no-c-format
msgid "When used in an HTML page, the library would be included with the following definition:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1515
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[<script type=\"text/javascript\"\n"
      "        src=\"mylibrary.js\"></script>]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1517
#, no-c-format
msgid "You could then use it anywhere in the HTML document as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1521
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[<!-- Placeholder for the component -->    \n"
      "<div id=\"foo\"></div>\n"
      "    \n"
      "<!-- Create the component and bind it to the placeholder -->\n"
      "<script type=\"text/javascript\">\n"
      "    window.foo = new mylibrary.MyComponent(\n"
      "            document.getElementById(\"foo\"));\n"
      "    window.foo.click = function () {\n"
      "        alert(\"Value is \" + this.getValue());\n"
      "    }\n"
      "</script>]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1524
#, no-c-format
msgid "A JavaScript Component Example"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1532
#, no-c-format
msgid "You could interact with the component with JavaScript for example as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1537
#, no-c-format
msgid "<?pocket-size 65% ?><![CDATA[<a href=\"javascript:foo.setValue('New value')\">Click here</a>]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1541
#, no-c-format
msgid "A Server-Side API for a JavaScript Component"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1543
#, no-c-format
msgid "To begin integrating such a JavaScript component, you would need to sketch a bit how it would be used from a server-side Vaadin application. The component should support writing the value as well as listening for changes to it."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1550
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[final MyComponent mycomponent = new MyComponent();\n"
      "\n"
      "// Set the value from server-side\n"
      "mycomponent.setValue(\"Server-side value\");\n"
      "\n"
      "// Process a value input by the user from the client-side\n"
      "mycomponent.addValueChangeListener(\n"
      "        new MyComponent.ValueChangeListener() {\n"
      "    @Override\n"
      "    public void valueChange() {\n"
      "        Notification.show(\"Value: \" + mycomponent.getValue());\n"
      "    }\n"
      "});\n"
      "\n"
      "layout.addComponent(mycomponent);]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1555
#, no-c-format
msgid "A JavaScript component extends the <classname>AbstractJavaScriptComponent</classname>, which handles the shared state and RPC for the component."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1562
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[package com.vaadin.book.examples.client.js;\n"
      "\n"
      "@JavaScript({\"mylibrary.js\", \"mycomponent-connector.js\"})\n"
      "public class MyComponent extends AbstractJavaScriptComponent {\n"
      "    public interface ValueChangeListener extends Serializable {\n"
      "        void valueChange();\n"
      "    }\n"
      "    ArrayList<ValueChangeListener> listeners =\n"
      "            new ArrayList<ValueChangeListener>();\n"
      "    public void addValueChangeListener(\n"
      "                   ValueChangeListener listener) {\n"
      "        listeners.add(listener);\n"
      "    }\n"
      "    \n"
      "    public void setValue(String value) {\n"
      "        getState().value = value;\n"
      "    }\n"
      "    \n"
      "    public String getValue() {\n"
      "        return getState().value;\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    protected MyComponentState getState() {\n"
      "        return (MyComponentState) super.getState();\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1564
#, no-c-format
msgid "Notice later when creating the JavaScript connector that its name must match the package name of this server-side class."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1569
#, no-c-format
msgid "The shared state of the component is as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1573
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[public class MyComponentState extends JavaScriptComponentState {\n"
      "    public String value;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1575
#, no-c-format
msgid "If the member variables are private, you need to have public setters and getters for them, which you can use in the component."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1583
#, no-c-format
msgid "Defining a JavaScript Connector"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1585
#, no-c-format
msgid "A JavaScript connector is a function that initializes the JavaScript component and handles communication between the server-side and the JavaScript code."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1591
#, no-c-format
msgid "A connector is defined as a connector initializer function that is added to the <literal>window</literal> object. The name of the function must match the server-side class name, with the full package path. Instead of the Java dot notation for the package name, underscores need to be used as separators."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1599
#, no-c-format
msgid "The Vaadin client-side framework adds a number of methods to the connector function. The <methodname>this.getElement()</methodname> method returns the HTML DOM element of the component. The <methodname>this.getState()</methodname> returns a shared state object with the current state as synchronized from the server-side."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1607
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[window.com_vaadin_book_examples_client_js_MyComponent =\n"
      "function() {\n"
      "    // Create the component\n"
      "    var mycomponent =\n"
      "        new mylibrary.MyComponent(this.getElement());\n"
      "    \n"
      "    // Handle changes from the server-side\n"
      "    this.onStateChange = function() {\n"
      "        mycomponent.setValue(this.getState().value);\n"
      "    };\n"
      "\n"
      "    // Pass user interaction to the server-side\n"
      "    var self = this;\n"
      "    mycomponent.click = function() {\n"
      "        self.onClick(mycomponent.getValue());\n"
      "    };\n"
      "};]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1609
#, no-c-format
msgid "In the above example, we pass user interaction using the JavaScript RPC mechanism, as described in the next section."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1616
#, no-c-format
msgid "RPC from JavaScript to Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1618
#, no-c-format
msgid "User interaction with the JavaScript component has to be passed to the server-side using an RPC (Remote Procedure Call) mechanism. The JavaScript RPC mechanism is almost equal to regular client-side widgets, as described in <xref linkend=\"gwt.rpc\"/>."
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1627
#, no-c-format
msgid "Handling RPC Calls on the Server-Side"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1629
#, no-c-format
msgid "Let us begin with the RPC function registration on the server-side. RPC calls are handled on the server-side in function handlers that implement the <interfacename>JavaScriptFunction</interfacename> interface. A server-side function handler is registered with the <methodname>addFunction()</methodname> method in <classname>AbstractJavaScriptComponent</classname>. The server-side registration actually defines a JavaScript method that is available in the client-side connector object."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1641
#, no-c-format
msgid "Continuing from the server-side <classname>MyComponent</classname> example we defined earlier, we add a constructor to it that registers the function."
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1647
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public MyComponent() {\n"
      "    addFunction(\"onClick\", new JavaScriptFunction() {\n"
      "        @Override\n"
      "        public void call(JSONArray arguments)\n"
      "                throws JSONException {\n"
      "            getState().setValue(arguments.getString(0));\n"
      "            for (ValueChangeListener listener: listeners)\n"
      "                listener.valueChange();\n"
      "        }\n"
      "    });\n"
      "}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1651
#, no-c-format
msgid "Making an RPC Call from JavaScript"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1653
#, no-c-format
msgid "An RPC call is made simply by calling the RPC method in the connector. In the constructor function of the JavaScript connector, you could write as follows (the complete connector code was given earlier):"
msgstr ""

#. Tag: programlisting
#: chapter-gwt.xml:1666
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[window.com_vaadin_book_examples_gwt_js_MyComponent =\n"
      "    function() {\n"
      "        ...\n"
      "        var connector = this;\n"
      "        mycomponent.click = function() {\n"
      "            connector.onClick(mycomponent.getValue());\n"
      "        };\n"
      "    };]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1668
#, no-c-format
msgid "Here, the <literal>mycomponent.click</literal> is a function in the example JavaScript library, as described in <xref linkend=\"gwt.javascript.example\"/>. The <methodname>onClick()</methodname> is the method we defined on the server-side. We pass a simple string parameter in the call."
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1676
#, no-c-format
msgid "You can pass anything that is valid in JSON notation in the parameters."
msgstr ""

