# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-05-20 12:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: chapter-jpacontainer.xml:11
#, no-c-format
msgid "<title>Vaadin JPAContainer</title>"
msgstr ""

#. Tag: primary
#: chapter-jpacontainer.xml:14
#, no-c-format
msgid "JPAContainer"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:17
#, no-c-format
msgid "This chapter describes the use of the Vaadin JPAContainer add-on."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:22
#, no-c-format
msgid "Overview"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:24
#, no-c-format
msgid "Vaadin JPAContainer add-on makes it possible to bind user interface components to a database easily using the Java Persistence API (JPA). It is an implementation of the <interfacename>Container</interfacename> interface described in <xref linkend=\"datamodel.container\"/>. It supports a typical three-layer application architecture with an intermediate <emphasis>domain model</emphasis> between the user interface and the data access layer."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:36
#, no-c-format
msgid "Three-Layer Architecture Using JPAContainer And JPA"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:47
#, no-c-format
msgid "The role of Java Persistence API is to handle persisting the domain model in the database. The database is typically a relational database. Vaadin JPAContainer binds the user interface components to the domain model and handles database access with JPA transparently."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:54
#, no-c-format
msgid "JPA is really just an API definition and has many alternative implementations. Vaadin JPAContainer supports especially EclipseLink, which is the reference implementation of JPA, and Hibernate. Any other compliant implementation should work just as well. The architecture of an application using JPAContainer is shown in <xref linkend=\"figure.jpacontainer.overview.detailed-architecture\"/>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:64
#, no-c-format
msgid "JPAContainer Architecture"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:75
#, no-c-format
msgid "Vaadin JPAContainer also plays together with the Vaadin support for Java Bean Validation (JSR 303)."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:81
#, no-c-format
msgid "Java Persistence API"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:83
#, no-c-format
msgid "Java Persistence API (JPA) is an API for object-relational mapping (ORM) of Java objects to a relational database. In JPA and entity-relationship modeling in general, a Java class is considered an <emphasis>entity</emphasis>. Class (or entity) instances correspond with a row in a database table and member variables of a class with columns. Entities can also have relationships with other entities."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:92
#, no-c-format
msgid "The object-relational mapping is illustrated in <xref linkend=\"figure.jpacontainer.overview.jpa.orm\"/> with two entities with a one-to-many relationship."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:99
#, no-c-format
msgid "Object-Relational Mapping"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:110
#, no-c-format
msgid "The entity relationships are declared with metadata. With Vaadin JPAContainer, you provide the metadata with annotations in the entity classes. The JPA implementation uses reflection to read the annotations and defines a database model automatically from the class definitions. Definition of the domain model and the annotations are described in <xref linkend=\"jpacontainer.domain-model.annotation\"/>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:119
#, no-c-format
msgid "The main interface in JPA is the <interfacename>EntityManager</interfacename>, which allows making different kinds of queries either with the Java Persistence Query Language (JPQL), native SQL, or the Criteria API in JPA 2.0. You can always use the interface directly as well, using Vaadin JPAContainer only for binding the data to the user interface."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:128
#, no-c-format
msgid "Vaadin JPAContainer supports JPA 2.0 (JSR 317). It is available under the Apache License 2.0."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:135
#, no-c-format
msgid "JPAContainer Concepts"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:137
#, no-c-format
msgid "The <classname>JPAContainer</classname> is an implementation of the Vaadin <interfacename>Container</interfacename> interface that you can bind to user interface components such as <classname>Table</classname>, <classname>ComboBox</classname>, etc."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:144
#, no-c-format
msgid "The data access to the persistent entities is handled with a <emphasis>entity provider</emphasis>, as defined in the <interfacename>EntityProvider</interfacename> interface. JPAContainer provides a number of different entity providers for different use cases and optimizations. The built-in providers are described in <xref linkend=\"jpacontainer.entityprovider\"/>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:153
#, no-c-format
msgid "<classname>JPAContainer</classname> is by default <emphasis>unbuffered</emphasis>, so that any entity property changes are written immediately to the database when you call <methodname>setValue()</methodname> for a property, or when a user edits a bound field. A container can be set as <emphasis>buffered</emphasis>, so that changes are written on calling <methodname>commit()</methodname>. Buffering can be done both at item level, such as when updating item property values, or at container level, such as when adding or deleting items. Only <emphasis>batchable</emphasis> containers, that is, containers with a batchable entity provider, can be buffered. Note that buffering is recommended for situations where two users could update the same entity simultaneously, and when this would be a problem. In an unbuffered container, the entity is refreshed before writing an update, so the last write wins and a conflicting simultaneous update written before it is lost. A buffered container throws an <classname>OptimisticLockException</classname> when two users edit the same item (an unbuffered container never throws it), thereby allowing to handle the situation with application logic."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:176
#, no-c-format
msgid "Documentation and Support"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:178
#, no-c-format
msgid "In addition to this chapter in the book, the installation package includes the following documentation about JPAContainer:"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:184
#, no-c-format
msgid "API Documentation"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:185
#, no-c-format
msgid "JPAContainer Tutorial"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:186
#, no-c-format
msgid "JPAContainer AddressBook Demo"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:187
#, no-c-format
msgid "JPAContainer Demo"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:193
#, no-c-format
msgid "Installing"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:195
#, no-c-format
msgid "Vaadin JPAContainer can be installed either as an installation package, downloaded from the Vaadin Directory, or as a Maven dependency. You can also create a new JPAContainer-enabled Vaadin project using a Maven archetype."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:202
#, no-c-format
msgid "Downloading the Package"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:204
#, no-c-format
msgid "Vaadin JPAContainer is available for download from the <link xlink:href=\"http://vaadin.com/directory\">Vaadin Directory</link>. Please see <xref linkend=\"addons.downloading\"/> for basic instructions for downloading from Directory. The download page also gives the dependency declaration needed for retrieving the library with Maven."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:212
#, no-c-format
msgid "JPAContainer is a purely server-side component, so it does not include a widget set that you would need to compile."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:219
#, no-c-format
msgid "Installation Package Content"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:222
#, no-c-format
msgid "Once extracted to a local folder, the contents of the installation directory are as follows:"
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:229
#, no-c-format
msgid "README"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:231
#, no-c-format
msgid "A readme file describing the package contents."
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:237
#, no-c-format
msgid "LICENSE"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:239
#, no-c-format
msgid "The full license text for the library."
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:245
#, no-c-format
msgid "vaadin-jpacontainer-3.x.x.jar"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:247
#, no-c-format
msgid "The actual Vaadin JPAContainer library."
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:265
#, no-c-format
msgid "vaadin-jpacontainer-3.x.x-sources.jar"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:267
#, no-c-format
msgid "Source JAR for the library. You can use it for example in Eclipse by associating the JavaDoc JAR with the JPAContainer JAR in the build path settings of your project."
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:286
#, no-c-format
msgid "jpacontainer-tutorial.pdf"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:288
#, no-c-format
msgid "The tutorial in PDF format."
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:294
#, no-c-format
msgid "jpacontainer-tutorial-html"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:296
#, no-c-format
msgid "The tutorial in HTML format."
msgstr ""

#. Tag: filename
#: chapter-jpacontainer.xml:302
#, no-c-format
msgid "jpacontainer-addressbook-demo"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:304
#, no-c-format
msgid "The JPAContainer AddressBook Demo project covered in this tutorial. You can compile and package the application as a WAR with \"<command>mvn</command> <parameter>package</parameter>\" or launch it in the Jetty web browser with \"<command>mvn</command> <parameter>jetty:run</parameter>\". You can also import the demo project in Eclipse."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:318
#, no-c-format
msgid "Downloading with Maven"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:320
#, no-c-format
msgid "The <link xlink:href=\"http://vaadin.com/directory\">download page in Vaadin Directory</link> gives the dependency declaration needed for retrieving the Vaadin JPAContainer library with Maven."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:326
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<dependency>\n"
      "   <groupId>com.vaadin.addon</groupId>\n"
      "   <artifactId>jpacontainer-addon</artifactId>\n"
      "   <version>3.1.0</version>\n"
      "</dependency>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:328
#, no-c-format
msgid "Use the <literal>LATEST</literal> version tag to automatically download the latest stable release or use a specific version number as done above."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:333
#, no-c-format
msgid "See <xref linkend=\"addons.maven\"/> for detailed instructions for using a Vaadin add-on with Maven."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:339
#, no-c-format
msgid "Using the Maven Archetype"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:341
#, no-c-format
msgid "If you wish to create a new JPAContainer-enabled Vaadin project with Maven, you can use the <literal>vaadin-archetype-jpacontainer</literal> archetype. Please see <xref linkend=\"getting-started.maven\"/> for details on creating a Vaadin project with a Maven archetype."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:352
#, no-c-format
msgid "Including Libraries in Your Project"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:354
#, no-c-format
msgid "The Vaadin JPAContainer JAR must be included in the library folder of the web application. It is located in <filename>WEB-INF/lib</filename> path in a web application. In a normal Eclipse web projects the path is <filename>WebContent/WEB-INF/lib</filename>. In Maven projects the JARs are automatically included in the folder, as long as the dependencies are defined correctly."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:365
#, no-c-format
msgid "You will need the following JARs:"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:370
#, no-c-format
msgid "Vaadin Framework Library"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:371
#, no-c-format
msgid "<para>Vaadin JPAContainer</para>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:372
#, no-c-format
msgid "Java Persistence API 2.0 (javax.persistence package)"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:373
#, no-c-format
msgid "JPA implementation (EclipseLink, Hibernate, ...)"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:374
#, no-c-format
msgid "Database driver or embedded engine (H2, HSQLDB, MySQL, PostgreSQL, ...)"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:377
#, no-c-format
msgid "If you use Eclipse, the Vaadin Framework library is automatically downloaded and updated by the Vaadin Plugin for Eclipse."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:382
#, no-c-format
msgid "To use bean validation, you need an implementation of the Bean Validation, such as Hibernate Validator."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:389
#, no-c-format
msgid "Persistence Configuration"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:391
#, no-c-format
msgid "Persistence configuration is done in a <filename>persistence.xml</filename> file. In a regular Eclipse project, it should be located in <filename>WebContent/WEB-INF/classes/META-INF</filename>. In a Maven project, it should be in <filename>src/main/resources/META-INF</filename>. The configuration includes the following:"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:402
#, no-c-format
msgid "The persistence unit"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:403
#, no-c-format
msgid "The persistence provider"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:404
#, no-c-format
msgid "The database driver and connection"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:405
#, no-c-format
msgid "Logging"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:408
#, no-c-format
msgid "The <filename>persistence.xml</filename> file is packaged as <filename>WEB-INF/classes/META-INF/persistence.xml</filename> in the WAR. This is done automatically in a Maven build at the package phase."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:415
#, no-c-format
msgid "Persistence XML Schema"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:417
#, no-c-format
msgid "The beginning of a <filename>persistence.xml</filename> file defines the used schema and namespaces:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:422
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      "<persistence\n"
      "    xmlns=\"http://java.sun.com/xml/ns/persistence\"\n"
      "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "    xsi:schemaLocation=\"\n"
      "      http://java.sun.com/xml/ns/persistence\n"
      "      http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd\"\n"
      "    version=\"2.0\">]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:426
#, no-c-format
msgid "Defining the Persistence Unit"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:428
#, no-c-format
msgid "The root element of the persistence definition is persistence-unit. The name of the persistence unit is needed for creating <classname>JPAContainer</classname> instances from a <classname>JPAContainerFactory</classname>, as described in <xref linkend=\"jpacontainer.usage.jpacontainerfactory\"/> or when creating a JPA entity manager."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:437
#, no-c-format
msgid "<?pocket-size 75% ?><![CDATA[<persistence-unit name=\"addressbook\">]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:440
#, no-c-format
msgid "Persistence provider is the JPA provider implementation used. For example, the JPAContainer AddressBook demo uses the EclipseLink JPA, which is defined as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:446
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<provider>\n"
      "    org.eclipse.persistence.jpa.PersistenceProvider\n"
      "</provider>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:449
#, no-c-format
msgid "The persistent classes need to be listed with a <literal>&lt;class&gt;</literal> element. Alternatively, you can allow including unlisted classes for persistence by overriding the <literal>exclude-unlisted-classes</literal> default as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:456
#, no-c-format
msgid "<?pocket-size 75% ?><![CDATA[<exclude-unlisted-classes>false</exclude-unlisted-classes>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:459
#, no-c-format
msgid "JPA provider specific parameters are given under the <literal>properties</literal> element."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:464
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<properties>\n"
      "   ...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:466
#, no-c-format
msgid "In the following section we give parameters for the EclipseLink JPA and H2 database used in the JPAContainer AddressBook Demo. Please refer to the documentation of the JPA provider you use for a complete reference of parameters."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:475
#, no-c-format
msgid "Database Connection"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:478
#, no-c-format
msgid "EclipseLink allows using JDBC for database connection. For example, if we use the the H2 database, we define its driver here as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:483
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[<property name=\"eclipselink.jdbc.platform\"\n"
      " value=\"org.eclipse.persistence.platform.database.H2Platform\"/>\n"
      "<property name=\"eclipselink.jdbc.driver\"\n"
      "          value=\"org.h2.Driver\" />]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:486
#, no-c-format
msgid "Database connection is specified with a URL. For example, using an embedded H2 database stored in the home directory it would be as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:492
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.jdbc.url\"\n"
      "          value=\"jdbc:h2:~/my-app-h2db\"/>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:494
#, no-c-format
msgid "A hint: when using an embedded H2 database while developing a Vaadin application in Eclipse, you may want to add <literal>;FILE_LOCK=NO</literal> to the URL to avoid locking issues when redeploying."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:502
#, no-c-format
msgid "We can just use the default user name and password for the H2 database:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:507
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.jdbc.user\" value=\"sa\"/>\n"
      "<property name=\"eclipselink.jdbc.password\" value=\"sa\"/>]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:511
#, no-c-format
msgid "Logging Configuration"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:514
#, no-c-format
msgid "JPA implementations as well as database engines like to produce logs and they should be configured in the persistence configuration. For example, if using EclipseLink JPA, you can get log that includes all SQL statements with the <literal>FINE</literal> logging level:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:521
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.logging.level\" \n"
      "          value=\"FINE\" />]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:525
#, no-c-format
msgid "Other Settings"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:527
#, no-c-format
msgid "The rest is some Data Definition Language settings for EclipseLink. During development, when we use generated example data, we want EclipseLink to drop tables before trying to create them. In production environments, you should use <literal>create-tables</literal>."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:535
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.ddl-generation\" \n"
      "          value=\"drop-and-create-tables\" />]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:537
#, no-c-format
msgid "And there is no need to generate SQL files, just execute them directly to the database."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:542
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.ddl-generation.output-mode\"\n"
      "          value=\"database\"/>\n"
      "          </properties>\n"
      " </persistence-unit>\n"
      "</persistence>]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:547
#, no-c-format
msgid "Troubleshooting"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:549
#, no-c-format
msgid "Below are some typical errors that you might get when using JPA. These are not specific to JPAContainer."
msgstr ""

#. Tag: term
#: chapter-jpacontainer.xml:556
#, no-c-format
msgid "<classname>javax.persistence.PersistenceException</classname>: No Persistence provider for EntityManager"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:558
#, no-c-format
msgid "The most typical cases for this error are that the persistence unit name is wrong in the source code or in the <filename>persistence.xml</filename> file, or that the <filename>persistence.xml</filename> is at a wrong place or has some other problem. Make sure that the persistence unit name matches and the <filename>persistence.xml</filename> is in <filename>WEB-INF/classes/META-INF</filename> folder in the deployment."
msgstr ""

#. Tag: term
#: chapter-jpacontainer.xml:571
#, no-c-format
msgid "<classname>java.lang.IllegalArgumentException</classname>: The class is not an entity"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:573
#, no-c-format
msgid "The class is missing from the set of persistent entities. If the <filename>persistence.xml</filename> does not have <parameter>exclude-unlisted-classes</parameter> defined as <literal>false</literal>, the persistent entity classes should be listed with <literal>&lt;class&gt;</literal> elements."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:587
#, no-c-format
msgid "Defining a Domain Model"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:589
#, no-c-format
msgid "Developing a persistent application begins with defining a domain model. A domain model consists of a number of entities (classes) and relationships between them."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:595
#, no-c-format
msgid "illustrates a simple domain model as a UML class diagram. It has two entities: <classname>Country</classname> and <classname>Person</classname>. They have a \"country has persons\" relationship. This is a <emphasis>one-to-many relationship</emphasis> with one country having many persons, each of which belongs to just one country."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:605
#, no-c-format
msgid "A Domain Model"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:617
#, no-c-format
msgid "Realized in Java, the classes are as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:621
#, no-c-format
msgid ""
      "<![CDATA[public class Country {\n"
      "    private Long   id;\n"
      "    private String name;\n"
      "    private Set<Person> persons;\n"
      "\n"
      "    ... setters and getters ...\n"
      "}\n"
      "\n"
      "public class Person {\n"
      "    private Long    id;\n"
      "    private String  name;\n"
      "    private Integer age;\n"
      "    private Country country;\n"
      "\n"
      "    ... setters and getters ...\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:623
#, no-c-format
msgid "You should make the classes proper beans by defining a default constructor and implementing the <interfacename>Serializable</interfacename> interface. A default constructor is required by the JPA entity manager for instantiating entities. Having the classes serializable is not required but often useful for other reasons."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:631
#, no-c-format
msgid "After you have a basic domain model, you need to define the entity relationship metadata by annotating the classes."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:637
#, no-c-format
msgid "Persistence Metadata"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:639
#, no-c-format
msgid "The entity relationships are defined with metadata. The metadata can be defined in an XML metadata file or with Java annotations defined in the <package>javax.persistence</package> package. With Vaadin JPAContainer, you need to provide the metadata as annotations."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:646
#, no-c-format
msgid "For example, if we look at the Person class in the JPAContainer AddressBook Demo, we define various database-related metadata for the member variables of a class:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:652
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[@Entity\n"
      "public class Person {\n"
      "    @Id\n"
      "    @GeneratedValue(strategy = GenerationType.AUTO)\n"
      "    private Long    id;\n"
      "\n"
      "    private String  name;\n"
      "    private Integer age;\n"
      "\n"
      "    @ManyToOne\n"
      "    private Country country;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:654
#, no-c-format
msgid "The JPA implementation uses reflection to read the annotations and defines a database model automatically from the class definitions."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:659
#, no-c-format
msgid "Let us look at some of the basic JPA metadata annotations. The annotations are defined in the <package>javax.persistence</package> package. Please refer to JPA reference documentation for the complete list of possible annotations."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:667
#, no-c-format
msgid "Annotation: <literal>@Entity</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:669
#, no-c-format
msgid "Each class that is enabled as a persistent entity must have the <literal>@Entity</literal> annotation."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:674
#, no-c-format
msgid ""
      "<![CDATA[@Entity\n"
      "public class Country {]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:678
#, no-c-format
msgid "Annotation: <literal>@Id</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:680
#, no-c-format
msgid "Entities must have an identifier that is used as the primary key for the table. It is used for various purposes in database queries, most commonly for joining tables."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:686
#, no-c-format
msgid ""
      "<![CDATA[@Id\n"
      "@GeneratedValue(strategy = GenerationType.AUTO)\n"
      "private Long id;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:688
#, no-c-format
msgid "The identifier is generated automatically in the database. The strategy for generating the identifier is defined with the <literal>@GeneratedValue</literal> annotation. Any generation type should work."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:697
#, no-c-format
msgid "Annotation: <literal>@OneToOne</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:699
#, no-c-format
msgid "The <literal>@OneToOne</literal> annotation describes a one-to-one relationship where each entity of one type is associated with exactly one entity of another type. For example, the postal address of a person could be given as such."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:706
#, no-c-format
msgid ""
      "<![CDATA[@OneToOne\n"
      "private Address address;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:708
#, no-c-format
msgid "When using the JPAContainer <classname>FieldFactory</classname> to automatically create fields for a form, the <literal>@OneToOne</literal> relationship generates a nested <classname>Form</classname> to edit the data. See <xref linkend=\"jpacontainer.fieldfactory\"/> for more details."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:718
#, no-c-format
msgid "Annotation: <literal>@Embedded</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:720
#, no-c-format
msgid "Just as with the <literal>@OneToOne</literal> annotation, <literal>@Embedded</literal> describes a one-to-one relationship, but says that the referenced entity should be stored as columns in the same table as the referencing entity."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:727
#, no-c-format
msgid ""
      "<![CDATA[@Embedded\n"
      "private Address address;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:729
#, no-c-format
msgid "The referenced entity class must have <literal>@Embeddable</literal> annotation."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:734
#, no-c-format
msgid "The JPAContainer <classname>FieldFactory</classname> generates a nested <classname>Form</classname> for <literal>@Embedded</literal>, just as with <literal>@OneToOne</literal>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:742
#, no-c-format
msgid "Annotation: <literal>@OneToMany</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:744
#, no-c-format
msgid "The <classname>Country</classname> entity in the domain model has a <emphasis>one-to-many</emphasis> relationship with the <classname>Person</classname> entity (\"country has persons\"). This relationship is represented with the <literal>@OneToMany</literal> annotation. The <parameter>mappedBy</parameter> parameter names the corresponding back-reference in the <classname>Person</classname> entity."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:754
#, no-c-format
msgid ""
      "<![CDATA[@OneToMany(mappedBy = \"country\")\n"
      "private Set<Person> persons;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:756
#, no-c-format
msgid "When using the JPAContainer <classname>FieldFactory</classname> to automatically create fields for a form, the <literal>@OneToMany</literal> relationship generates a <classname>MasterDetailEditor</classname> for editing the items. See <xref linkend=\"jpacontainer.fieldfactory\"/> for more details."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:766
#, no-c-format
msgid "Annotation: <literal>@ElementCollection</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:768
#, no-c-format
msgid "The <literal>@ElementCollection</literal> annotation can be used for one-to-many relationships to a collection of basic values such as <classname>String</classname> or <classname>Integer</classname>, or to entities annotated as <literal>@Embeddable</literal>. The referenced entities are stored in a separate table defined with a <literal>@CollectionTable</literal> annotation."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:777
#, no-c-format
msgid ""
      "<![CDATA[@ElementCollection\n"
      "@CollectionTable(\n"
      "    name=\"OLDPEOPLE\",\n"
      "    joinColumns=@JoinColumn(name=\"COUNTRY_ID\"))\n"
      "private Set<Person> persons;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:779
#, no-c-format
msgid "JPAContainer <classname>FieldFactory</classname> generates a <classname>MasterDetailEditor</classname> for the <literal>@ElementCollection</literal> relationship, just as with <literal>@OneToMany</literal>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:788
#, no-c-format
msgid "Annotation: <literal>@ManyToOne</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:790
#, no-c-format
msgid "Many people can live in the same country. This would be represented with the <literal>@ManyToOne</literal> annotation in the <classname>Person</classname> class."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:796
#, no-c-format
msgid ""
      "<![CDATA[@ManyToOne\n"
      "private Country country;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:798
#, no-c-format
msgid "JPAContainer <classname>FieldFactory</classname> generates a <classname>NativeSelect</classname> for selecting an item from the collection. You can do so yourself as well in a custom field factory. Doing so you need to pay notice not to confuse the container between the referenced entity and its ID, which could even result in insertion of false entities in the database in some cases. You can translate between an entity and the entity ID using the <classname>SingleSelectTranslator</classname> as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:809
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[@Override\n"
      "public Field createField(Item item, Object propertyId,\n"
      "                         Component uiContext) {\n"
      "    if (propertyId.equals(\"station\")) {\n"
      "        ComboBox box = new ComboBox(\"Station\");\n"
      "\n"
      "        // Translate between referenced entity and its ID\n"
      "        box.setPropertyDataSource(\n"
      "                new SingleSelectTranslator(box));\n"
      "        \n"
      "        box.setContainerDataSource(stationContainer);\n"
      "        ...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:811
#, no-c-format
msgid "The JPAContainer <classname>FieldFactory</classname> uses the translator internally, so using it also avoids the problem."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:818
#, no-c-format
msgid "Annotation: <literal>@Transient</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:820
#, no-c-format
msgid "JPA assumes that all entity properties are persisted. Properties that should not be persisted should be marked as transient with the <literal>@Transient</literal> annotation."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:826
#, no-c-format
msgid ""
      "<![CDATA[@Transient\n"
      "private Boolean superDepartment;\n"
      "...\n"
      "@Transient\n"
      "public String getHierarchicalName() {\n"
      "...]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:832
#, no-c-format
msgid "Basic Use of JPAContainer"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:834
#, no-c-format
msgid "Vaadin JPAContainer offers a highly flexible API that makes things easy in simple cases while allowing extensive flexibility in demanding cases. To begin with, it is a <classname>Container</classname>, as described in <xref linkend=\"datamodel.container\"/>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:841
#, no-c-format
msgid "In this section, we look how to create and use <classname>JPAContainer</classname> instances. We assume that you have defined a domain model with JPA annotations, as described in the previous section."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:848
#, no-c-format
msgid "Creating <classname>JPAContainer</classname> with <classname>JPAContainerFactory</classname>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:850
#, no-c-format
msgid "The <classname>JPAContainerFactory</classname> is the easy way to create <classname>JPAContainer</classname>s. It provides a set of <emphasis>make...()</emphasis> factory methods for most cases that you will likely meet. Each factory method uses a different type of entity provider, which are described in <xref linkend=\"jpacontainer.entityprovider\"/>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:859
#, no-c-format
msgid "The factory methods take the class type of the entity class as the first parameter. The second parameter is either a persistence unit name (persistence context) or an <classname>EntityManager</classname> instance."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:866
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[// Create a persistent person container\n"
      "JPAContainer<Person> persons =\n"
      "    JPAContainerFactory.make(Person.class, \"book-examples\");\n"
      "\n"
      "// You can add entities to the container as well\n"
      "persons.addEntity(new Person(\"Marie-Louise Meilleur\", 117));\n"
      "\n"
      "// Set up sorting if the natural order is not appropriate\n"
      "persons.sort(new String[]{\"age\", \"name\"},\n"
      "             new boolean[]{false, false});\n"
      "\n"
      "// Bind it to a component\n"
      "Table personTable = new Table(\"The Persistent People\", persons);\n"
      "personTable.setVisibleColumns(new String[]{\"id\",\"name\",\"age\"});\n"
      "layout.addComponent(personTable);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:868
#, no-c-format
msgid "It's that easy. In fact, if you run the above code multiple times, you'll be annoyed by getting a new set of persons for each run - that's how persistent the container is. The basic <methodname>make()</methodname> uses a <classname>CachedMutableLocalEntityProvider</classname>, which allows modifying the container and its entities, as we do above by adding new entities."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:877
#, no-c-format
msgid "When using just the persistence unit name, the factory creates an instance of <classname>EntityManagerFactory</classname> for the persistence unit and uses it to build entity managers. You can also create the entity managers yourself, as described later."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:885
#, no-c-format
msgid "The entity providers associated with the different factory methods are as follows:"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:891
#, no-c-format
msgid "<classname>JPAContainerFactory</classname> Methods"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:895
#, no-c-format
msgid "make()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:896 chapter-jpacontainer.xml:1304
#, no-c-format
msgid "CachingMutableLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:899
#, no-c-format
msgid "makeReadOnly()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:900 chapter-jpacontainer.xml:1283
#, no-c-format
msgid "CachingLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:903
#, no-c-format
msgid "makeBatchable()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:904 chapter-jpacontainer.xml:1270
#, no-c-format
msgid "BatchableLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:907
#, no-c-format
msgid "makeNonCached()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:908 chapter-jpacontainer.xml:1248
#, no-c-format
msgid "MutableLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:911
#, no-c-format
msgid "makeNonCachedReadOnly()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:912 chapter-jpacontainer.xml:1233
#, no-c-format
msgid "LocalEntityProvider"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:918
#, no-c-format
msgid "<classname>JPAContainerFactory</classname> holds a cache of entity manager factories for the different persistence units, making sure that any entity manager factory is created only once, as it is a heavy operation. You can access the cache to get a new entity manager with the <methodname>createEntityManagerForPersistenceUnit()</methodname> method."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:927
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[// Get an entity manager\n"
      "EntityManager em = JPAContainerFactory.\n"
      "    createEntityManagerForPersistenceUnit(\"book-examples\");\n"
      "\n"
      "// Do a query\n"
      "em.getTransaction().begin();\n"
      "em.createQuery(\"DELETE FROM Person p\").executeUpdate();\n"
      "em.persist(new Person(\"Jeanne Calment\", 122));\n"
      "em.persist(new Person(\"Sarah Knauss\", 119));\n"
      "em.persist(new Person(\"Lucy Hannah\", 117));\n"
      "em.getTransaction().commit();\n"
      "\n"
      "...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:929
#, no-c-format
msgid "Notice that if you use update the persistent data with an entity manager outside a <classname>JPAContainer</classname> bound to the data, you need to refresh the container as described in <xref linkend=\"jpacontainer.usage.entitites\"/>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:937
#, no-c-format
msgid "Creating <classname>JPAContainer</classname> Manually"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:939
#, no-c-format
msgid "While it is normally easiest to use a <classname>JPAContainerFactory</classname> to create <classname>JPAContainer</classname> instances, you may need to create them manually. It is necessary, for example, when you need to use a custom entity provider or extend <classname>JPAContainer</classname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:947
#, no-c-format
msgid "First, we need to create an entity manager and then the entity provider, which we bind to a <classname>JPAContainer</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:953
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[// We need a factory to create entity manager\n"
      "EntityManagerFactory emf =\n"
      "    Persistence.createEntityManagerFactory(\"book-examples\");\n"
      "\n"
      "// We need an entity manager to create entity provider\n"
      "EntityManager em = emf.createEntityManager();\n"
      "\n"
      "// We need an entity provider to create a container        \n"
      "CachingMutableLocalEntityProvider<Person> entityProvider =\n"
      "    new CachingMutableLocalEntityProvider<Person>(Person.class,\n"
      "                                                  em);\n"
      "\n"
      "// And there we have it\n"
      "JPAContainer<Person> persons =\n"
      "        new JPAContainer<Person> (Person.class);\n"
      "persons.setEntityProvider(entityProvider);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:955
#, no-c-format
msgid "You could save the first step by asking the entity manager from the <classname>JPAContainerFactory</classname>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:963
#, no-c-format
msgid "Creating and Accessing Entities"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:965
#, no-c-format
msgid "JPAContainer integrates with the JPA entity manager, which you would normally use to create and access entities with JPA. You can use the entity manager for any purposes you may have, and then <classname>JPAContainer</classname> to bind entities to user interface components such as <classname>Table</classname>, <classname>Tree</classname>, any selection components, or a <classname>Form</classname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:975
#, no-c-format
msgid "You can add new entities to a <classname>JPAContainer</classname> with the <methodname>addEntity()</methodname> method. It returns the item ID of the new entity."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:981
#, no-c-format
msgid ""
      "<![CDATA[Country france = new Country(\"France\");\n"
      "Object itemId = countries.addEntity(france);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:983
#, no-c-format
msgid "The item ID used by <classname>JPAContainer</classname> is the value of the ID property (column) defined with the <literal>@Id</literal> annotation. In our <classname>Country</classname> entity, it would have <classname>Long</classname> type. It is generated by the entity manager when the entity is persisted and set with the setter for the ID proeprty."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:991
#, no-c-format
msgid "Notice that the <methodname>addEntity()</methodname> method does <emphasis>not</emphasis> attach the entity instance given as the parameter. Instead, it creates a new instance. If you need to use the entity for some purpose, you need to get the actual managed entity from the container. You can get it with the item ID returned by <methodname>addEntity()</methodname>."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1000
#, no-c-format
msgid ""
      "<![CDATA[// Create a new entity and add it to a container\n"
      "Country france = new Country(\"France\");\n"
      "Object itemId = countries.addEntity(france);\n"
      "\n"
      "// Get the managed entity\n"
      "france = countries.getItem(itemId).getEntity();\n"
      "\n"
      "// Use the managed entity in entity references\n"
      "persons.addEntity(new Person(\"Jeanne Calment\", 122, france));]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1003
#, no-c-format
msgid "Entity Items"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1005
#, no-c-format
msgid "The <methodname>getItem()</methodname> method is defined in the normal Vaadin <interfacename>Container</interfacename> interface. It returns an <classname>EntityItem</classname>, which is a wrapper over the actual entity object. You can get the entity object with <methodname>getEntity()</methodname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1013
#, no-c-format
msgid "An <classname>EntityItem</classname> can have a number of states: persistent, modified, dirty, and deleted. The dirty and deleted states are meaningful when using <emphasis>container buffering</emphasis>, while the modified state is meaningful when using <emphasis>item buffering</emphasis>. Both levels of buffering can be used together - user input is first written to the item buffer, then to the entity instance, and finally to the database."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1023
#, no-c-format
msgid "The <methodname>isPersistent()</methodname> method tells if the item is actually persistent, that is, fetched from a persistent storage, or if it is just a transient entity created and buffered by the container."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1029
#, no-c-format
msgid "The <methodname>isModified()</methodname> method checks whether the <classname>EntityItem</classname> has changes that are not yet committed to the entity instance. It is only relevant if the item buffering is enabled with <methodname>setBuffered(true)</methodname> for the item."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1037
#, no-c-format
msgid "The <methodname>isDirty()</methodname> method checks whether the entity object has been modified after it was fetched from the entity provider. The dirty state is possible only when buffering is enabled for the container."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1044
#, no-c-format
msgid "The <methodname>isDeleted()</methodname> method checks whether the item has been marked for deletion with <methodname>removeItem()</methodname> in a buffered container."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1052
#, no-c-format
msgid "Refreshing JPAContainer"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1054
#, no-c-format
msgid "In cases where you change <classname>JPAContainer</classname> items outside the container, for example by through an <interfacename>EntityManager</interfacename>, or when they change in the database, you need to refresh the container."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1061
#, no-c-format
msgid "The <interfacename>EntityContainer</interfacename> interface implemented by <classname>JPAContainer</classname> provides two methods to refresh a container. The <methodname>refresh()</methodname> discards all container caches and buffers and refreshes all loaded items in the container. All changes made to items provided by the container are discarded. The <methodname>refreshItem()</methodname> refreshes a single item."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1074 chapter-jpacontainer.xml:1102
#, no-c-format
msgid "Nested Properties"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1076
#, no-c-format
msgid "If you have a one-to-one or many-to-one relationship, you can define the properties of the referenced entity as <emphasis>nested</emphasis> in a <classname>JPAContainer</classname>. This way, you can access the properties directly through the container of the first entity type as if they were its properties. The interface is the same as with <classname>BeanContainer</classname> described in <xref linkend=\"datamodel.container.beancontainer\"/>. You just need to add each nested property with <methodname>addNestedContainerProperty()</methodname> using dot-separated path to the property."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1089
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[// Have a persistent container\n"
      "JPAContainer<Person> persons =\n"
      "    JPAContainerFactory.make(Person.class, \"book-examples\");\n"
      "\n"
      "// Add a nested property to a many-to-one property\n"
      "persons.addNestedContainerProperty(\"country.name\");\n"
      "        \n"
      "// Show the persons in a table, except the \"country\" column,\n"
      "// which is an object - show the nested property instead\n"
      "Table personTable = new Table(\"The Persistent People\", persons);\n"
      "personTable.setVisibleColumns(new String[]{\"name\",\"age\",\n"
      "                                           \"country.name\"});\n"
      "\n"
      "// Have a nicer caption for the country.name column\n"
      "personTable.setColumnHeader(\"country.name\", \"Nationality\");]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1091
#, no-c-format
msgid "The result is shown in <xref linkend=\"figure.jpacontainer.usage.nested-properties\"/>. Notice that the <literal>country</literal> property in the container remains after adding the nested property, so we had to make that column invisible. Alternatively, we could have redefined the <methodname>toString()</methodname> method in the country object to show the name instead of an object reference."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1110
#, no-c-format
msgid "You can use the <literal>*</literal> wildcard to add all properties in a nested item, for example, \"<literal>country.*</literal>\"."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1117
#, no-c-format
msgid "Hierarchical Container"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1119
#, no-c-format
msgid "<classname>JPAContainer</classname> implements the <interfacename>Container.Hierarchical</interfacename> interface and can be bound to hierarchical components such as a <classname>Tree</classname> or <classname>TreeTable</classname>. The feature requires that the hierarchy is represented with a <emphasis>parent</emphasis> property that refers to the parent item. At database level, this would be a column with IDs."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1128
#, no-c-format
msgid "The representation would be as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1133
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Entity\n"
      "public class CelestialBody implements Serializable {\n"
      "    @Id\n"
      "    @GeneratedValue(strategy = GenerationType.IDENTITY)\n"
      "    private Long    id;\n"
      "    \n"
      "    private String  name;\n"
      "\n"
      "    @ManyToOne\n"
      "    private CelestialBody parent;\n"
      "    ...\n"
      "} ...\n"
      "\n"
      "// Create some entities\n"
      "CelestialBody sun     = new CelestialBody(\"The Sun\", null);\n"
      "CelestialBody mercury = new CelestialBody(\"Mercury\", sun);\n"
      "CelestialBody venus   = new CelestialBody(\"Venus\", sun); \n"
      "CelestialBody earth   = new CelestialBody(\"Earth\", sun);\n"
      "CelestialBody moon    = new CelestialBody(\"The Moon\", earth);\n"
      "CelestialBody mars    = new CelestialBody(\"Mars\", sun);\n"
      "...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1135
#, no-c-format
msgid "You set up a <classname>JPAContainer</classname> to have hierarchy by calling <methodname>setParentProperty()</methodname> with the name of the property that refers to the parent. Coincidentally, it is named \"<literal>parent</literal>\" in the example:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1143
#, no-c-format
msgid ""
      "<?pocket-size 65%?><![CDATA[// Create the container\n"
      "JPAContainer<CelestialBody> bodies =\n"
      "    JPAContainerFactory.make(CelestialBody.class, \"my-unit\");\n"
      "\n"
      "// Set it up for hierarchical representation\n"
      "bodies.setParentProperty(\"parent\");\n"
      "\n"
      "// Bind it to a hierarhical component\n"
      "Tree tree = new Tree(\"Celestial Bodies\", bodies);\n"
      "tree.setItemCaptionMode(Tree.ITEM_CAPTION_MODE_PROPERTY);\n"
      "tree.setItemCaptionPropertyId(\"name\");]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1145
#, no-c-format
msgid "You can use the <methodname>rootItemIds()</methodname> to acquire the item IDs of the root elements with no parent."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1150
#, no-c-format
msgid ""
      "<![CDATA[// Expand the tree\n"
      "for (Object rootId: bodies.rootItemIds())\n"
      "    tree.expandItemsRecursively(rootId);]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1153
#, no-c-format
msgid "Unsupported Hierarchical Features"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1155
#, no-c-format
msgid "Using <methodname>setParent()</methodname> in the container to define parenthood is not supported."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1160
#, no-c-format
msgid "Also, the current implementation does not support <emphasis>setChildrenAllowed()</emphasis>, which controls whether the user can expand a node by clicking a toggle. The toggle is by default visible for all nodes, even if they have no children. The method is not supported because it would require storing the information outside the entities. You can override <methodname>areChildrenAllowed()</methodname> to implement the functionality using a custom logic."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1172
#, no-c-format
msgid ""
      "<?pocket-size 65%?><![CDATA[// Customize JPAContainer to define the logic for\n"
      "// displaying the node expansion indicator\n"
      "JPAContainer<CelestialBody> bodies =\n"
      "        new JPAContainer<CelestialBody>(CelestialBody.class) {\n"
      "    @Override\n"
      "    public boolean areChildrenAllowed(Object itemId) {\n"
      "        // Some simple logic\n"
      "        return getChildren(itemId).size() > 0;\n"
      "    }\n"
      "};\n"
      "bodies.setEntityProvider(\n"
      "    new CachingLocalEntityProvider<CelestialBody>(\n"
      "        CelestialBody.class, em));]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1179
#, no-c-format
msgid "Entity Providers"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1181
#, no-c-format
msgid "Entity providers provide access to entities persisted in a data store. They are essentially wrappers over a JPA entity manager with optimizations and other features important when binding persistent data to a user interface."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1187
#, no-c-format
msgid "The choice and use of entity providers is largely invisible if you create your <classname>JPAContainer</classname> instances with the <classname>JPAContainerFactory</classname>, which hides such details."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1193
#, no-c-format
msgid "JPAContainer entity providers can be customized, which is necessary for some purposes. Entity providers can be Enterprise JavaBeans (EJBs), which is useful when you use them in a Java EE application server."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1200
#, no-c-format
msgid "Built-In Entity Providers"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1202
#, no-c-format
msgid "JPAContainer includes various kinds of built-in entity providers: caching and non-caching, read-write and read-only, and batchable."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1207
#, no-c-format
msgid "<emphasis>Caching</emphasis> is useful for performance, but takes some memory for the cache and makes the provider stateful. <emphasis>Batching</emphasis>, that is, running updates in larger batches, can also enhance performance and be used together with caching. It is stateless, but doing updates is a bit more complex than otherwise."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1216
#, no-c-format
msgid "Using a <emphasis>read-only</emphasis> container is preferable if read-write capability is not needed."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1221
#, no-c-format
msgid "All built-in providers are <emphasis>local</emphasis> in the sense that they provide access to entities using a local JPA entity manager."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1226
#, no-c-format
msgid "The <classname>CachingMutableLocalEntityProvider</classname> is usually recommended as the first choise for read-write access and <classname>CachingLocalEntityProvider</classname> for read-only access."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1235
#, no-c-format
msgid "A read-only, lazy loading entity provider that does not perform caching and reads its data directly from an entity manager."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1240
#, no-c-format
msgid "You can create the provider with <methodname>makeNonCachedReadOnly()</methodname> method in <classname>JPAContainerFactory</classname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1250
#, no-c-format
msgid "Extends <classname>LocalEntityProvider</classname> with write support. All changes are directly sent to the entity manager."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1256
#, no-c-format
msgid "Transactions can be handled either internally by the provider, which is the default, or by the container. In the latter case, you can extend the class and annotate it, for example, as described in <xref linkend=\"jpacontainer.entityprovider.built-in\"/>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1263
#, no-c-format
msgid "The provider can notify about updates to entities through the <interfacename>EntityProviderChangeNotifier</interfacename> interface."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1272
#, no-c-format
msgid "A simple non-caching implementation of the <interfacename>BatchableEntityProvider</interfacename> interface. It extends <classname>MutableLocalEntityProvider</classname> and simply passes itself to the <methodname>batchUpdate()</methodname> callback method. This will work properly if the entities do not contain any references to other entities that are managed by the same container."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1285
#, no-c-format
msgid "A read-only, lazy loading entity provider that caches both entities and query results for different filter/sortBy combinations. When the cache gets full, the oldest entries in the cache are removed. The maximum number of entities and entity IDs to cache for each filter/sortBy combination can be configured in the provider. The cache can also be manually flushed. When the cache grows full, the oldest items are removed."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1296
#, no-c-format
msgid "You can create the provider with <methodname>makeReadOnly()</methodname> method in <classname>JPAContainerFactory</classname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1306
#, no-c-format
msgid "Just like <classname>CachingLocalEntityProvider</classname>, but with read-write access. For read access, caching works just like in the read-only provider. When an entity is added or updated, the cache is flushed in order to make sure the added or updated entity shows up correctly when using filters and/or sorting. When an entity is removed, only the filter/sortBy-caches that actually contain the item are flushed."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1316
#, no-c-format
msgid "This is perhaps the most commonly entity provider that you should consider using for most tasks. You can create it with the <methodname>make()</methodname> method in <classname>JPAContainerFactory</classname>."
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:1325
#, no-c-format
msgid "CachingBatchableLocalEntityProvider"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1327
#, no-c-format
msgid "This provider supports making updates in <emphasis>batches</emphasis>. You need to implement a <interfacename>BatchUpdateCallback</interfacename> that does all the updates and execute the batch by calling <methodname>batchUpdate()</methodname> on the provider."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1335
#, no-c-format
msgid "The provider is an extension of the <classname>CachingMutableLocalEntityProvider</classname> that implements the <interfacename>BatchableEntityProvider</interfacename> interface. This will work properly if the entities do not contain any references to other entities that are managed by the same container."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1345
#, no-c-format
msgid "You can create the provider with <methodname>makeBatchable()</methodname> method in <classname>JPAContainerFactory</classname>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1354
#, no-c-format
msgid "Using JNDI Entity Providers in JEE6 Environment"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1356
#, no-c-format
msgid "JPAContainer 2.0 introduced a new set of entity providers specifically for working in a <literal>JEE6</literal> environment. In a JEE environment, you should use an entity manager provided by the application server and, usually, <literal>JTA</literal> transactions instead of transactions provided by JPA. Entity providers in <package>com.vaadin.addon.jpacontainer.provider.jndijta</package> package work mostly the same way as the normal providers discussed earlier, but use JNDI lookups to get reference to an <interfacename>EntityManager</interfacename> and to a JTA transaction."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1368
#, no-c-format
msgid "The JNDI providers work with almost no special configuration at all. The <classname>JPAContainerFactory</classname> has factory methods for creating various JNDI provider types. The only thing that you commonly need to do is to expose the <interfacename>EntityManager</interfacename> to a JNDI address. By default, the JNDI providers look for the <interfacename>EntityManager</interfacename> from \"<uri>java:comp/env/persistence/em</uri>\". This can be done with the following snippet in <filename>web.xml</filename> or with similar configuration with annotations."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1380
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[<persistence-context-ref>\n"
      "  <persistence-context-ref-name>\n"
      "    persistence/em\n"
      "  </persistence-context-ref-name>\n"
      "  <persistence-unit-name>MYPU</persistence-unit-name>\n"
      "</persistence-context-ref>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1382
#, no-c-format
msgid "The \"<literal>MYPU</literal>\" is the identifier of your persistence unit defined in your <filename>persistence.xml</filename> file."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1387
#, no-c-format
msgid "If you choose to annotate your servlets (instead of using the <filename>web.xml</filename> file as described above), you can simply add the following annotation to your servlet."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1393
#, no-c-format
msgid "<?pocket-size 70% ?><![CDATA[@PersistenceContext(name=\"persistence/em\",unitName=\"MYPU\")]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1395
#, no-c-format
msgid "If you wish to use another address for the persistence context, you can define them with the <methodname>setJndiAddresses()</methodname> method. You can also define the location for the JTA <classname>UserTransaction</classname>, but that should be always accessible from \"<uri>java:comp/UserTransaction</uri>\" by the JEE6 specification."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1406
#, no-c-format
msgid "Entity Providers as Enterprise Beans"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1408
#, no-c-format
msgid "Entity providers can be Enterprise JavaBeans (EJB). This may be useful if you use JPAContainer in a Java EE application server. In such case, you need to implement a custom entity provider that allows the server to inject the entity manager."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1415
#, no-c-format
msgid "For example, if you need to use Java Transaction API (JTA) for JPA transactions, you can implement such entity provider as follows. Just extend a built-in entity provider of your choise and annotate the entity manager member as <literal>@PersistenceContext</literal>. Entity providers can be either stateless or stateful session beans. If you extend a caching entity provider, it has to be stateful."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1424
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[@Stateless\n"
      "@TransactionManagement\n"
      "public class MyEntityProviderBean extends\n"
      "    MutableLocalEntityProvider<MyEntity> {\n"
      "\n"
      "    @PersistenceContext\n"
      "    private EntityManager em;\n"
      "\n"
      "    protected LocalEntityProviderBean() {\n"
      "        super(MyEntity.class);\n"
      "        setTransactionsHandledByProvider(false);\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    @TransactionAttribute(TransactionAttributeType.REQUIRED)\n"
      "    protected void runInTransaction(Runnable operation) {\n"
      "        super.runInTransaction(operation);\n"
      "    }\n"
      "\n"
      "    @PostConstruct\n"
      "    public void init() {\n"
      "        setEntityManager(em);\n"
      "        /*\n"
      "         * The entity manager is transaction-scoped, which means\n"
      "         * that the entities will be automatically detached when\n"
      "         * the transaction is closed. Therefore, we do not need\n"
      "         * to explicitly detach them.\n"
      "         */\n"
      "        setEntitiesDetached(false);\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1426
#, no-c-format
msgid "If you have more than one EJB provider, you might want to create an abstract super class of the above and only define the entity type in implementations. You can implement an entity provider as a managed bean in Spring Framefork the same way."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1437
#, no-c-format
msgid "Filtering <classname>JPAContainer</classname>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1439
#, no-c-format
msgid "Normally, a <classname>JPAContainer</classname> contains all instances of a particular entity type in the persistence context. Hence, it is equivalent to a database table or query. Just like with database queries, you often want to narrow the results down. <classname>JPAContainer</classname> implements the <interfacename>Filterable</interfacename> interface in Vaadin containers, described in <xref linkend=\"datamodel.container.filtered\"/>. All filtering is done at the database level with queries, not in the container."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1450
#, no-c-format
msgid "For example, let us filter all the people older than 117:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1455
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[Filter filter = new Compare.Greater(\"age\", 117);\n"
      "persons.addContainerFilter(filter);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1458
#, no-c-format
msgid "This would create a JPQL query somewhat as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1462
#, no-c-format
msgid "<?pocket-size 75% ?><![CDATA[SELECT id FROM Person WHERE (AGE > 117)]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1464
#, no-c-format
msgid "The filtering implementation uses the JPA 2.0 Criteria API transparently. As the filtering is done at the database-level, custom filters that use the <interfacename>Filterable</interfacename> API do not work."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1472
#, no-c-format
msgid "When using Hibernate, note that it does not support implicit joins. See <xref linkend=\"jpacontainer.hibernate.joins\"/> for more details."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1479
#, no-c-format
msgid "Querying with the Criteria API"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1481
#, no-c-format
msgid "When the <interfacename>Filterable</interfacename> API is not enough and you need to have more control, you can make queries directly with the JPA Criteria API. You may also need to customize sorting or joins, or otherwise modify the query in some way. To do so, you need to implement a <interfacename>QueryModifierDelegate</interfacename> that the JPAContainer entity provider calls when making a query. The easiest way to do this is to extend <classname>DefaultQueryModifierDelegate</classname>, which has empty implementations of all the methods so that you can only override the ones you need."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1493
#, no-c-format
msgid "The entity provider calls specific <interfacename>QueryModifierDelegate</interfacename> methods at different stages while making a query. The stages are:"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1500
#, no-c-format
msgid "Start building a query"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1501
#, no-c-format
msgid "Add \"<literal>ORDER BY</literal>\" expression"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1502
#, no-c-format
msgid "Add \"<literal>WHERE</literal>\" expression (filter)"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1503
#, no-c-format
msgid "Finish building a query"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1507
#, no-c-format
msgid "Methods where you can modify the query are called before and after each stage as listed in the following table:"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1513
#, no-c-format
msgid "<classname>QueryModifierDelegate</classname> Methods"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1517
#, no-c-format
msgid "queryWillBeBuilt()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1520
#, no-c-format
msgid "orderByWillBeAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1523
#, no-c-format
msgid "orderByWasAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1526
#, no-c-format
msgid "filtersWillBeAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1529
#, no-c-format
msgid "filtersWereAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1532
#, no-c-format
msgid "queryHasBeenBuilt()"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1538
#, no-c-format
msgid "All the methods get two parameters. The <interfacename>CriteriaBuilder</interfacename> is a builder that you can use to build queries. The <interfacename>CriteriaQuery</interfacename> is the query being built."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1545
#, no-c-format
msgid "You can use the <methodname>getRoots().iterator().next()</methodname> in <interfacename>CriteriaQuery</interfacename> to get the \"root\" that is queried, for example, the <literal>PERSON</literal> table, etc."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1552
#, no-c-format
msgid "Filtering the Query"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1554
#, no-c-format
msgid "Let us consider a case where we modify the query for a <classname>Person</classname> container so that it includes only people over 116. This trivial example is identical to the one given earlier using the <classname>Filterable</classname> interface."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1562
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[\n"
      "persons.getEntityProvider().setQueryModifierDelegate(\n"
      "        new DefaultQueryModifierDelegate () {\n"
      "    @Override\n"
      "    public void filtersWillBeAdded(\n"
      "            CriteriaBuilder criteriaBuilder,\n"
      "            CriteriaQuery<?> query,\n"
      "            List<Predicate> predicates) {\n"
      "        Root<?> fromPerson = query.getRoots().iterator().next();\n"
      "\n"
      "        // Add a \"WHERE age > 116\" expression\n"
      "        Path<Integer> age = fromPerson.<Integer>get(\"age\");\n"
      "        predicates.add(criteriaBuilder.gt(age, 116));\n"
      "    }\n"
      "});]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1566
#, no-c-format
msgid "Compatibility"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1568
#, no-c-format
msgid "When building queries, you should consider the capabilities of the different JPA implementations. Regarding Hibernate, see <xref linkend=\"jpacontainer.hibernate.joins\"/>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1577
#, no-c-format
msgid "Automatic Form Generation"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1579
#, no-c-format
msgid "The JPAContainer <classname>FieldFactory</classname> is an implementation of the <interfacename>FormFieldFactory</interfacename> and <interfacename>TableFieldFactory</interfacename> interfaces that can generate fields based on JPA annotations in a POJO. It goes further than the <classname>DefaultFieldFactory</classname>, which only creates simple fields for the basic data types. This way, you can easily create forms to input entities or enable editing in tables."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1590
#, no-c-format
msgid "The generated defaults are as follows:"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1598
#, no-c-format
msgid "Annotation"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1599
#, no-c-format
msgid "Class Mapping"
msgstr ""

#. Tag: literal
#: chapter-jpacontainer.xml:1604
#, no-c-format
msgid "@ManyToOne"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:1605
#, no-c-format
msgid "NativeSelect"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1608
#, no-c-format
msgid "<literal>@OneToOne</literal>, <literal>@Embedded</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1609
#, no-c-format
msgid "Nested <classname>Form</classname>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1612
#, no-c-format
msgid "<literal>@OneToMany</literal>, <literal>@ElementCollection</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1613
#, no-c-format
msgid "<classname>MasterDetailEditor</classname> (see below)"
msgstr ""

#. Tag: literal
#: chapter-jpacontainer.xml:1616
#, no-c-format
msgid "@ManyToMany"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1617
#, no-c-format
msgid "Selectable <classname>Table</classname>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1625
#, no-c-format
msgid "The field factory is recusive, so that you can edit a complex object tree with one form."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1631
#, no-c-format
msgid "Configuring the Field Factory"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1633
#, no-c-format
msgid "The <classname>FieldFactory</classname> is highly configurable with various configuration settings and by extending."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1639
#, no-c-format
msgid "The <methodname>setMultiSelectType()</methodname> and <methodname>setSingleSelectType()</methodname> allow you to specify a selection component that is used instead of the default for a field with <literal>@ManyToMany</literal> and <literal>@ManyToOne</literal> annotation, respectively. The first parameter is the class type of the field, and the second parameter is the class type of a selection component. It must be a sub-class of <classname>AbstractSelect</classname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1650
#, no-c-format
msgid "The <methodname>setVisibleProperties()</methodname> controls which properties (fields) are visible in generated forms, subforms, and tables. The first paramater is the class type for which the setting should be made, followed by the IDs of the visible properties."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1657
#, no-c-format
msgid "The configuration should be done before binding the form to a data source as that is when the field generation is done."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1662
#, no-c-format
msgid "Further configuration must be done by extending the many protected methods. Please see the API documentation for the complete list."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1669
#, no-c-format
msgid "Using the Field Factory"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1672
#, no-c-format
msgid "The most basic use case for the JPAContainer <classname>FieldFactory</classname> is with a <classname>Form</classname> bound to a container item:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1679
#, no-c-format
msgid ""
      "<?pocket-size 65% ?><![CDATA[// Have a persistent container\n"
      "final JPAContainer<Country> countries =\n"
      "    JPAContainerFactory.make(Country.class, \"book-examples\");\n"
      "\n"
      "// For selecting an item to edit\n"
      "final ComboBox countrySelect =\n"
      "    new ComboBox(\"Select a Country\", countries);\n"
      "countrySelect.setItemCaptionMode(Select.ITEM_CAPTION_MODE_PROPERTY);\n"
      "countrySelect.setItemCaptionPropertyId(\"name\");\n"
      "\n"
      "// Country Editor\n"
      "final Form  countryForm  = new Form();\n"
      "countryForm.setCaption(\"Country Editor\");\n"
      "countryForm.addStyleName(\"bordered\"); // Custom style\n"
      "countryForm.setWidth(\"420px\");\n"
      "countryForm.setBuffered(true);\n"
      "countryForm.setEnabled(false);\n"
      "\n"
      "// When an item is selected from the list...\n"
      "countrySelect.addValueChangeListener(new ValueChangeListener(){\n"
      "    @Override\n"
      "    public void valueChange(ValueChangeEvent event) {\n"
      "        // Get the item to edit in the form\n"
      "        Item countryItem =\n"
      "            countries.getItem(event.getProperty().getValue());\n"
      "        \n"
      "        // Use a JPAContainer field factory\n"
      "        //  - no configuration is needed here\n"
      "        final FieldFactory fieldFactory = new FieldFactory();\n"
      "        countryForm.setFormFieldFactory(fieldFactory);\n"
      "\n"
      "        // Edit the item in the form\n"
      "        countryForm.setItemDataSource(countryItem);\n"
      "        countryForm.setEnabled(true);\n"
      "        \n"
      "        // Handle saves on the form\n"
      "        final Button save = new Button(\"Save\");\n"
      "        countryForm.getFooter().removeAllComponents();\n"
      "        countryForm.getFooter().addComponent(save);\n"
      "        save.addClickListener(new ClickListener() {\n"
      "            @Override\n"
      "            public void buttonClick(ClickEvent event) {\n"
      "                try {\n"
      "                    countryForm.commit();\n"
      "                    countryForm.setEnabled(false);\n"
      "                } catch (InvalidValueException e) {\n"
      "                }\n"
      "            }\n"
      "        });\n"
      "    }\n"
      "});\n"
      "countrySelect.setImmediate(true);\n"
      "countrySelect.setNullSelectionAllowed(false);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1681
#, no-c-format
msgid "This would create a form shown in <xref linkend=\"figure.jpacontainer.fieldfactory.using\"/>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1687
#, no-c-format
msgid "Using FieldFactory with One-to-Many Relationship"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1695
#, no-c-format
msgid "If you use Hibernate, you also need to pass an <classname>EntityManagerPerRequestHelper</classname>, either for the constructor or with <methodname>setEntityManagerPerRequestHelper()</methodname><phrase condition=\"web\">, as described in <xref linkend=\"jpacontainer.hibernate.em-per-request\"/></phrase>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1706
#, no-c-format
msgid "Master-Detail Editor"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1708
#, no-c-format
msgid "The <classname>MasterDetailEditor</classname> is a field component that allows editing an item property that has one-to-many relationship. The item can be a row in a table or bound to a form. It displays the referenced collection as an editable <classname>Table</classname> and allows adding and removing items in it."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1716
#, no-c-format
msgid "You can use the <classname>MasterDetailEditor</classname> manually, or perhaps more commonly use a JPAContainer <classname>FieldFactory</classname> to create it automatically. As shown in the example in <xref linkend=\"figure.jpacontainer.fieldfactory.using\"/>, the factory creates a <classname>MasterDetailEditor</classname> for all properties with a <literal>@OneToMany</literal> or an <literal>@ElementCollection</literal> annotation."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1732
#, no-c-format
msgid "Using JPAContainer with Hibernate"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1734
#, no-c-format
msgid "Hibernate needs special handling in some cases."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1739
#, no-c-format
msgid "Lazy loading"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1741
#, no-c-format
msgid "In order for lazy loading to work automatically, an entity must be attached to an entity manager. Unfortunately, Hibernate can not keep entity managers for long without problems. To work around the problem, you need to use a special lazy loading delegate for Hibernate."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1748
#, no-c-format
msgid "JPAContainer entity providers handle lazy loading in delegates defined by the <interfacename>LazyLoadingDelegate</interfacename> interface. The default implementation for Hibernate is defined in <classname>HibernateLazyLoadingDelegate</classname>. You can instantiate one and use it in an entity provider with <methodname>setLazyLoadingDelegate()</methodname>."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1757
#, no-c-format
msgid "The default implementation works so that whenever a lazy property is accessed through the Vaadin <interface>Property</interface> interface, the value is retrieved with a separate (JPA Criteria API) query using the currently active entity manager. The value is then manually attached to the entity instance, which is detached from the entity manager. If this default implementation is not good enough, you may need to make your own implementation."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1769
#, no-c-format
msgid "The EntityManager-Per-Request pattern"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1771
#, no-c-format
msgid "One issue with Hibernate is that it is designed for short-lived sessions, but the lifetime of an entity manager is normally roughly that of a user session. The problem is that if an error occurs in a session or an entity manager, the manager becomes unuseable. This causes big problems with long-lived sessions that would work fine with EclipseLink."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1779
#, no-c-format
msgid "The recommended solution is to use the <emphasis>EntityManager-per-Request</emphasis> pattern. It is highly recommended always when using Hibernate."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1785
#, no-c-format
msgid "An entity manager can only be open during the request-response cycle of the Vaadin servlet, so that one is created at the beginning of the request and closed at the end."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1792
#, no-c-format
msgid "Storing an Entity Manager"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1794
#, no-c-format
msgid "You first need to implement an <interfacename>EntityManagerProvider</interfacename> that returns a stored <interfacename>EntityManager</interfacename> with <methodname>getEntityManager()</methodname>. The entity manager must be stored in a <classname>ThreadLocal</classname> variable."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1802
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class LazyHibernateEntityManagerProvider\n"
      "       implements EntityManagerProvider {\n"
      "    private static ThreadLocal<EntityManager>\n"
      "        entityManagerThreadLocal =\n"
      "            new ThreadLocal<EntityManager>();\n"
      "\n"
      "    @Override\n"
      "    public EntityManager getEntityManager() {\n"
      "        return entityManagerThreadLocal.get();\n"
      "    }\n"
      "\n"
      "    public static void setCurrentEntityManager(\n"
      "                               EntityManager em) {\n"
      "        entityManagerThreadLocal.set(em);\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1804
#, no-c-format
msgid "You need to create and store the per-request instance at the beginning of each request with <methodname>setCurrentEntityManager()</methodname> and clear it at the end by setting it as <literal>null</literal>."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1813
#, no-c-format
msgid "Creating Entity Managers in a Servlet Filter"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1815
#, no-c-format
msgid "You can create the entity managers for each request either by extending <classname>VaadinServlet</classname> and overriding the <methodname>service()</methodname> method or by implementing a servlet filter. In the following, we describe how to implement a servlet filter to do the task, but overriding the servlet could be even easier."
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1824
#, no-c-format
msgid ""
      "<?pocket-size 75% ?><![CDATA[public class LazyHibernateServletFilter\n"
      "       implements Filter {\n"
      "\n"
      "    private EntityManagerFactory entityManagerFactory;\n"
      "\n"
      "    @Override\n"
      "    public void init(FilterConfig filterConfig)\n"
      "            throws ServletException {\n"
      "        entityManagerFactory = Persistence\n"
      "            .createEntityManagerFactory(\"lazyhibernate\");\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    public void doFilter(ServletRequest servletRequest,\n"
      "                         ServletResponse servletResponse,\n"
      "                         FilterChain filterChain)\n"
      "            throws IOException, ServletException {\n"
      "        try {\n"
      "            // Create and set the entity manager\n"
      "            LazyHibernateEntityManagerProvider\n"
      "                .setCurrentEntityManager(\n"
      "                    entityManagerFactory\n"
      "                        .createEntityManager());\n"
      "\n"
      "            // Handle the request\n"
      "            filterChain.doFilter(servletRequest,\n"
      "                                 servletResponse);\n"
      "        } finally {\n"
      "            // Reset the entity manager\n"
      "            LazyHibernateEntityManagerProvider\n"
      "                    .setCurrentEntityManager(null);\n"
      "        }\n"
      "    }\n"
      "\n"
      "    @Override\n"
      "    public void destroy() {\n"
      "        entityManagerFactory = null;\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1826
#, no-c-format
msgid "You need to define the servlet filter in the <filename>web.xml</filename> deployment descriptor as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1831
#, no-c-format
msgid ""
      "<?pocket-size 65% ?>&lt;filter&gt;\n"
      "    &lt;filter-name&gt;<emphasis role=\"bold\">LazyHibernateServletFilter</emphasis>&lt;/filter-name&gt;\n"
      "    &lt;filter-class&gt;<emphasis role=\"bold\">com.example.LazyHibernateServletFilter</emphasis>&lt;/filter-class&gt;\n"
      "&lt;/filter&gt;\n"
      "&lt;filter-mapping&gt;\n"
      "    &lt;filter-name&gt;<emphasis role=\"bold\">LazyHibernateServletFilter</emphasis>&lt;/filter-name&gt;\n"
      "    &lt;url-pattern&gt;<emphasis role=\"bold\">/*</emphasis>&lt;/url-pattern&gt;\n"
      "&lt;/filter-mapping&gt;"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1833
#, no-c-format
msgid "The <literal>url-pattern</literal> must match the pattern for your Vaadin servlet."
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1841
#, no-c-format
msgid "Joins in Hibernate vs EclipseLink"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1843
#, no-c-format
msgid "EclipseLink supports implicit joins, while Hibernate requires explicit joins. In SQL terms, an explicit join is a \"<literal>FROM a INNER JOIN b ON a.bid = b.id</literal>\" expression, while an implicit join is done in a WHERE clause, such as: \"<literal>FROM a,b WHERE a.bid = b.id</literal>\"."
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1850
#, no-c-format
msgid "In a JPAContainer filter with EclipseLink, an implicit join would have form:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1855
#, no-c-format
msgid "<?pocket-size 65% ?><![CDATA[new Equal(\"skills.skill\", s)]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1857
#, no-c-format
msgid "In Hibernate you would need to use <classname>JoinFilter</classname> for the explicit join:"
msgstr ""

#. Tag: programlisting
#: chapter-jpacontainer.xml:1862
#, no-c-format
msgid "<?pocket-size 65% ?><![CDATA[new JoinFilter(\"skills\", new Equal(\"skill\", s))]]>"
msgstr ""

